var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/playwright/lib/utils/errors.js
var require_errors = __commonJS({
  "node_modules/playwright/lib/utils/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isSafeCloseError = exports2.kBrowserOrContextClosedError = exports2.kBrowserClosedError = exports2.TimeoutError = void 0;
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var TimeoutError = class extends CustomError {
    };
    exports2.TimeoutError = TimeoutError;
    exports2.kBrowserClosedError = "Browser has been closed";
    exports2.kBrowserOrContextClosedError = "Target page, context or browser has been closed";
    function isSafeCloseError(error3) {
      return error3.message.endsWith(exports2.kBrowserClosedError) || error3.message.endsWith(exports2.kBrowserOrContextClosedError);
    }
    exports2.isSafeCloseError = isSafeCloseError;
  }
});

// node_modules/playwright/lib/protocol/serializers.js
var require_serializers = __commonJS({
  "node_modules/playwright/lib/protocol/serializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.serializeValue = exports2.parseSerializedValue = exports2.parseError = exports2.serializeError = void 0;
    var errors_1 = require_errors();
    function serializeError(e) {
      if (isError2(e))
        return {error: {message: e.message, stack: e.stack, name: e.name}};
      return {value: serializeValue(e, (value) => ({fallThrough: value}), new Set())};
    }
    exports2.serializeError = serializeError;
    function parseError(error3) {
      if (!error3.error) {
        if (error3.value === void 0)
          throw new Error("Serialized error must have either an error or a value");
        return parseSerializedValue(error3.value, void 0);
      }
      if (error3.error.name === "TimeoutError") {
        const e2 = new errors_1.TimeoutError(error3.error.message);
        e2.stack = error3.error.stack || "";
        return e2;
      }
      const e = new Error(error3.error.message);
      e.stack = error3.error.stack || "";
      e.name = error3.error.name;
      return e;
    }
    exports2.parseError = parseError;
    function parseSerializedValue(value, handles) {
      if (value.n !== void 0)
        return value.n;
      if (value.s !== void 0)
        return value.s;
      if (value.b !== void 0)
        return value.b;
      if (value.v !== void 0) {
        if (value.v === "undefined")
          return void 0;
        if (value.v === "null")
          return null;
        if (value.v === "NaN")
          return NaN;
        if (value.v === "Infinity")
          return Infinity;
        if (value.v === "-Infinity")
          return -Infinity;
        if (value.v === "-0")
          return -0;
      }
      if (value.d !== void 0)
        return new Date(value.d);
      if (value.r !== void 0)
        return new RegExp(value.r.p, value.r.f);
      if (value.a !== void 0)
        return value.a.map((a) => parseSerializedValue(a, handles));
      if (value.o !== void 0) {
        const result = {};
        for (const {k, v} of value.o)
          result[k] = parseSerializedValue(v, handles);
        return result;
      }
      if (value.h !== void 0) {
        if (handles === void 0)
          throw new Error("Unexpected handle");
        return handles[value.h];
      }
      throw new Error("Unexpected value");
    }
    exports2.parseSerializedValue = parseSerializedValue;
    function serializeValue(value, handleSerializer, visited) {
      const handle = handleSerializer(value);
      if ("fallThrough" in handle)
        value = handle.fallThrough;
      else
        return handle;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {v: "undefined"};
      if (Object.is(value, void 0))
        return {v: "undefined"};
      if (Object.is(value, null))
        return {v: "null"};
      if (Object.is(value, NaN))
        return {v: "NaN"};
      if (Object.is(value, Infinity))
        return {v: "Infinity"};
      if (Object.is(value, -Infinity))
        return {v: "-Infinity"};
      if (Object.is(value, -0))
        return {v: "-0"};
      if (typeof value === "boolean")
        return {b: value};
      if (typeof value === "number")
        return {n: value};
      if (typeof value === "string")
        return {s: value};
      if (isError2(value)) {
        const error3 = value;
        if ("captureStackTrace" in global.Error) {
          return {s: error3.stack || ""};
        }
        return {s: `${error3.name}: ${error3.message}
${error3.stack}`};
      }
      if (isDate(value))
        return {d: value.toJSON()};
      if (isRegExp(value))
        return {r: {p: value.source, f: value.flags}};
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serializeValue(value[i], handleSerializer, visited));
        visited.delete(value);
        return {a};
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value))
          o.push({k: name, v: serializeValue(value[name], handleSerializer, visited)});
        visited.delete(value);
        return {o};
      }
      throw new Error("Unexpected value");
    }
    exports2.serializeValue = serializeValue;
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError2(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize2 = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = {sep: "/"};
    try {
      path = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
      "?": {open: "(?:", close: ")?"},
      "+": {open: "(?:", close: ")+"},
      "*": {open: "(?:", close: ")*"},
      "@": {open: "(?:", close: ")"}
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options2) {
      options2 = options2 || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options2);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options2) {
        return orig.minimatch(p, pattern, ext(def, options2));
      };
      m.Minimatch = function Minimatch2(pattern, options2) {
        return new orig.Minimatch(pattern, ext(def, options2));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options2) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options2).match(p);
    }
    function Minimatch(pattern, options2) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options2);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options2;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options2.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s2, si, set2) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options2 = this.options;
      var negateOffset = 0;
      if (options2.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options2) {
      return braceExpand(pattern, options2);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options2) {
      if (!options2) {
        if (this instanceof Minimatch) {
          options2 = this.options;
        } else {
          options2 = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options2.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options2 = this.options;
      if (!options2.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options2.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options2.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options2.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options2) {
      return new Minimatch(pattern, options2 || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options2 = this.options;
      var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      var flags = options2.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options2) {
      options2 = options2 || {};
      var mm = new Minimatch(pattern, options2);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options2 = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options2.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options2.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options2 = this.options;
      this.debug("matchOne", {"this": this, file, pattern});
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options2.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options2) {
      self2.ignore = options2.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, {dot: true});
      }
      return {
        matcher: new Minimatch(pattern, {dot: true}),
        gmatcher
      };
    }
    function setopts(self2, pattern, options2) {
      if (!options2)
        options2 = {};
      if (options2.matchBase && pattern.indexOf("/") === -1) {
        if (options2.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options2.silent;
      self2.pattern = pattern;
      self2.strict = options2.strict !== false;
      self2.realpath = !!options2.realpath;
      self2.realpathCache = options2.realpathCache || Object.create(null);
      self2.follow = !!options2.follow;
      self2.dot = !!options2.dot;
      self2.mark = !!options2.mark;
      self2.nodir = !!options2.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options2.sync;
      self2.nounique = !!options2.nounique;
      self2.nonull = !!options2.nonull;
      self2.nosort = !!options2.nosort;
      self2.nocase = !!options2.nocase;
      self2.stat = !!options2.stat;
      self2.noprocess = !!options2.noprocess;
      self2.absolute = !!options2.absolute;
      self2.maxLength = options2.maxLength || Infinity;
      self2.cache = options2.cache || Object.create(null);
      self2.statCache = options2.statCache || Object.create(null);
      self2.symlinks = options2.symlinks || Object.create(null);
      setupIgnores(self2, options2);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options2, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options2.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options2.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options2.nomount;
      options2.nonegate = true;
      options2.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options2);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options2) {
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options2).found;
    }
    function GlobSync(pattern, options2) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options2);
      setopts(this, pattern, options2);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index2) {
          var set = self2.matches[index2] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index2, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index2);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar);
      else
        this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index2, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index2, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index2, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index2][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index2][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error3 = new Error(er.code + " invalid cwd " + this.cwd);
            error3.path = this.cwd;
            error3.code = er.code;
            throw error3;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index2, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index2, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index2) {
      var exists = this._stat(prefix);
      if (!this.matches[index2])
        this.matches[index2] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret2 = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret2 === "function" && ret2 !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret2[k] = cb2[k];
          });
        }
        return ret2;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var fs = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits2 = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = {};
      if (!options2)
        options2 = {};
      if (options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options2);
      }
      return new Glob(pattern, options2, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options2 = extend({}, options_);
      options2.noprocess = true;
      var g = new Glob(pattern, options2);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits2(Glob, EE);
    function Glob(pattern, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      if (options2 && options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options2);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options2, cb);
      setopts(this, pattern, options2);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index2, cb) {
      var matchset = this.matches[index2];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index2] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index2] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index2, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index2, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index2, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar, cb);
      else
        this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index2, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index2, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index2, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index2, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index2][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index2][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error3 = new Error(er.code + " invalid cwd " + this.cwd);
            error3.path = this.cwd;
            error3.code = er.code;
            this.emit("error", error3);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index2, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index2, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index2, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index2, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index2, er, exists, cb) {
      if (!this.matches[index2])
        this.matches[index2] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/rimraf/rimraf.js"(exports2, module2) {
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options2) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options2[m] = options2[m] || fs[m];
        m = m + "Sync";
        options2[m] = options2[m] || fs[m];
      });
      options2.maxBusyTries = options2.maxBusyTries || 3;
      options2.emfileWait = options2.emfileWait || 1e3;
      if (options2.glob === false) {
        options2.disableGlob = true;
      }
      if (options2.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options2.disableGlob = options2.disableGlob || false;
      options2.glob = options2.glob || defaultGlobOpts;
    };
    var rimraf = (p, options2, cb) => {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options2, "rimraf: invalid options argument provided");
      assert.equal(typeof options2, "object", "rimraf: options should be object");
      defaults(options2);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options2.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options2, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options2.emfileWait) {
                return setTimeout(() => rimraf_(p2, options2, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options2, CB);
        });
      };
      if (options2.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options2.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options2.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options2, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options2, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options2, er, cb);
        options2.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options2, er2, cb) : rmdir(p, options2, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options2, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options2, er, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options2.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options2, er, cb);
            else
              options2.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options2, er) => {
      assert(p);
      assert(options2);
      try {
        options2.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options2.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options2, er);
      else
        options2.unlinkSync(p);
    };
    var rmdir = (p, options2, originalEr, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options2, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options2, cb) => {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options2.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path.join(p, f), options2, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options2.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options2) => {
      options2 = options2 || {};
      defaults(options2);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options2, "rimraf: missing options");
      assert.equal(typeof options2, "object", "rimraf: options should be object");
      let results;
      if (options2.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options2.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options2.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options2.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options2, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options2, null);
          else
            options2.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options2, er) : rmdirSync(p2, options2, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options2, er);
        }
      }
    };
    var rmdirSync = (p, options2, originalEr) => {
      assert(p);
      assert(options2);
      try {
        options2.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options2);
      }
    };
    var rmkidsSync = (p, options2) => {
      assert(p);
      assert(options2);
      options2.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options2));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret2 = options2.rmdirSync(p, options2);
          threw = false;
          return ret2;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/playwright/lib/utils/utils.js
var require_utils = __commonJS({
  "node_modules/playwright/lib/utils/utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.canAccessFile = exports2.removeFolders = exports2.createGuid = exports2.calculateSha1 = exports2.monotonicTime = exports2.headersArrayToObject = exports2.headersObjectToArray = exports2.mkdirIfNeeded = exports2.getAsBooleanFromENV = exports2.getFromENV = exports2.isUnderTest = exports2.setUnderTest = exports2.debugMode = exports2.isError = exports2.isObject = exports2.isRegExp = exports2.isString = exports2.debugAssert = exports2.assert = exports2.makeWaitForNextTask = void 0;
    var path_1 = __importDefault(require("path"));
    var fs_1 = __importDefault(require("fs"));
    var rimraf_1 = __importDefault(require_rimraf());
    var util = __importStar(require("util"));
    var crypto = __importStar(require("crypto"));
    var mkdirAsync = util.promisify(fs_1.default.mkdir.bind(fs_1.default));
    function makeWaitForNextTask() {
      if (process.versions.electron)
        return (callback) => setTimeout(callback, 0);
      if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
      let spinning = false;
      const callbacks = [];
      const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
          spinning = false;
          return;
        }
        setImmediate(loop);
        callback();
      };
      return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
          spinning = true;
          setImmediate(loop);
        }
      };
    }
    exports2.makeWaitForNextTask = makeWaitForNextTask;
    function assert(value, message) {
      if (!value)
        throw new Error(message);
    }
    exports2.assert = assert;
    function debugAssert(value, message) {
      if (isUnderTest() && !value)
        throw new Error(message);
    }
    exports2.debugAssert = debugAssert;
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    exports2.isString = isString;
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(obj) {
      return typeof obj === "object" && obj !== null;
    }
    exports2.isObject = isObject2;
    function isError2(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    exports2.isError = isError2;
    var debugEnv = getFromENV("PWDEBUG") || "";
    function debugMode() {
      if (debugEnv === "console")
        return "console";
      return debugEnv ? "inspector" : "";
    }
    exports2.debugMode = debugMode;
    var _isUnderTest = false;
    function setUnderTest() {
      _isUnderTest = true;
    }
    exports2.setUnderTest = setUnderTest;
    function isUnderTest() {
      return _isUnderTest;
    }
    exports2.isUnderTest = isUnderTest;
    function getFromENV(name) {
      let value = process.env[name];
      value = value === void 0 ? process.env[`npm_config_${name.toLowerCase()}`] : value;
      value = value === void 0 ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
      return value;
    }
    exports2.getFromENV = getFromENV;
    function getAsBooleanFromENV(name) {
      const value = getFromENV(name);
      return !!value && value !== "false" && value !== "0";
    }
    exports2.getAsBooleanFromENV = getAsBooleanFromENV;
    async function mkdirIfNeeded(filePath) {
      await mkdirAsync(path_1.default.dirname(filePath), {recursive: true}).catch(() => {
      });
    }
    exports2.mkdirIfNeeded = mkdirIfNeeded;
    function headersObjectToArray(headers) {
      const result = [];
      for (const name in headers) {
        if (!Object.is(headers[name], void 0))
          result.push({name, value: headers[name]});
      }
      return result;
    }
    exports2.headersObjectToArray = headersObjectToArray;
    function headersArrayToObject(headers, lowerCase) {
      const result = {};
      for (const {name, value} of headers)
        result[lowerCase ? name.toLowerCase() : name] = value;
      return result;
    }
    exports2.headersArrayToObject = headersArrayToObject;
    function monotonicTime() {
      const [seconds, nanoseconds] = process.hrtime();
      return seconds * 1e3 + (nanoseconds / 1e3 | 0) / 1e3;
    }
    exports2.monotonicTime = monotonicTime;
    function calculateSha1(buffer) {
      const hash2 = crypto.createHash("sha1");
      hash2.update(buffer);
      return hash2.digest("hex");
    }
    exports2.calculateSha1 = calculateSha1;
    function createGuid() {
      return crypto.randomBytes(16).toString("hex");
    }
    exports2.createGuid = createGuid;
    async function removeFolders(dirs) {
      await Promise.all(dirs.map((dir) => {
        return new Promise((fulfill) => {
          rimraf_1.default(dir, {maxBusyTries: 10}, (error3) => {
            if (error3)
              console.error(error3);
            fulfill();
          });
        });
      }));
    }
    exports2.removeFolders = removeFolders;
    function canAccessFile(file) {
      if (!file)
        return false;
      try {
        fs_1.default.accessSync(file);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.canAccessFile = canAccessFile;
  }
});

// node_modules/playwright/lib/protocol/validatorPrimitives.js
var require_validatorPrimitives = __commonJS({
  "node_modules/playwright/lib/protocol/validatorPrimitives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.tEnum = exports2.tObject = exports2.tArray = exports2.tOptional = exports2.tAny = exports2.tUndefined = exports2.tBinary = exports2.tString = exports2.tBoolean = exports2.tNumber = exports2.ValidationError = void 0;
    var utils_1 = require_utils();
    var ValidationError = class extends Error {
    };
    exports2.ValidationError = ValidationError;
    exports2.tNumber = (arg, path) => {
      if (arg instanceof Number)
        return arg.valueOf();
      if (typeof arg === "number")
        return arg;
      throw new ValidationError(`${path}: expected number, got ${typeof arg}`);
    };
    exports2.tBoolean = (arg, path) => {
      if (arg instanceof Boolean)
        return arg.valueOf();
      if (typeof arg === "boolean")
        return arg;
      throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);
    };
    exports2.tString = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected string, got ${typeof arg}`);
    };
    exports2.tBinary = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);
    };
    exports2.tUndefined = (arg, path) => {
      if (Object.is(arg, void 0))
        return arg;
      throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);
    };
    exports2.tAny = (arg, path) => {
      return arg;
    };
    exports2.tOptional = (v) => {
      return (arg, path) => {
        if (Object.is(arg, void 0))
          return arg;
        return v(arg, path);
      };
    };
    exports2.tArray = (v) => {
      return (arg, path) => {
        if (!Array.isArray(arg))
          throw new ValidationError(`${path}: expected array, got ${typeof arg}`);
        return arg.map((x, index2) => v(x, path + "[" + index2 + "]"));
      };
    };
    exports2.tObject = (s2) => {
      return (arg, path) => {
        if (Object.is(arg, null))
          throw new ValidationError(`${path}: expected object, got null`);
        if (typeof arg !== "object")
          throw new ValidationError(`${path}: expected object, got ${typeof arg}`);
        const result = {};
        for (const [key, v] of Object.entries(s2)) {
          const value = v(arg[key], path ? path + "." + key : key);
          if (!Object.is(value, void 0))
            result[key] = value;
        }
        if (utils_1.isUnderTest()) {
          for (const [key, value] of Object.entries(arg)) {
            if (key.startsWith("__testHook"))
              result[key] = value;
          }
        }
        return result;
      };
    };
    exports2.tEnum = (e) => {
      return (arg, path) => {
        if (!e.includes(arg))
          throw new ValidationError(`${path}: expected one of (${e.join("|")})`);
        return arg;
      };
    };
  }
});

// node_modules/playwright/lib/protocol/validator.js
var require_validator = __commonJS({
  "node_modules/playwright/lib/protocol/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createScheme = exports2.ValidationError = void 0;
    var validatorPrimitives_1 = require_validatorPrimitives();
    var validatorPrimitives_2 = require_validatorPrimitives();
    Object.defineProperty(exports2, "ValidationError", {enumerable: true, get: function() {
      return validatorPrimitives_2.ValidationError;
    }});
    function createScheme(tChannel) {
      const scheme = {};
      const tType = (name) => {
        return (arg, path) => {
          const v = scheme[name];
          if (!v)
            throw new validatorPrimitives_1.ValidationError(path + ': unknown type "' + name + '"');
          return v(arg, path);
        };
      };
      scheme.StackFrame = validatorPrimitives_1.tObject({
        file: validatorPrimitives_1.tString,
        line: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        column: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        function: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.Metadata = validatorPrimitives_1.tObject({
        stack: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("StackFrame"))),
        apiName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.WaitForEventInfo = validatorPrimitives_1.tObject({
        waitId: validatorPrimitives_1.tString,
        phase: validatorPrimitives_1.tEnum(["before", "after", "log"]),
        apiName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        message: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        error: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.Point = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber
      });
      scheme.Rect = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
        width: validatorPrimitives_1.tNumber,
        height: validatorPrimitives_1.tNumber
      });
      scheme.SerializedValue = validatorPrimitives_1.tObject({
        n: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        b: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        s: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        v: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["null", "undefined", "NaN", "Infinity", "-Infinity", "-0"])),
        d: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        r: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          p: validatorPrimitives_1.tString,
          f: validatorPrimitives_1.tString
        })),
        a: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("SerializedValue"))),
        o: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
          k: validatorPrimitives_1.tString,
          v: tType("SerializedValue")
        }))),
        h: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.SerializedArgument = validatorPrimitives_1.tObject({
        value: tType("SerializedValue"),
        handles: validatorPrimitives_1.tArray(tChannel("*"))
      });
      scheme.AXNode = validatorPrimitives_1.tObject({
        role: validatorPrimitives_1.tString,
        name: validatorPrimitives_1.tString,
        valueString: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        valueNumber: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        description: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        keyshortcuts: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        roledescription: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        valuetext: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        disabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        expanded: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        focused: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modal: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        multiline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        multiselectable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        readonly: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        required: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        selected: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        checked: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["checked", "unchecked", "mixed"])),
        pressed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["pressed", "released", "mixed"])),
        level: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        valuemin: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        valuemax: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        autocomplete: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        haspopup: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        invalid: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        orientation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        children: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("AXNode")))
      });
      scheme.SetNetworkCookie = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString,
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        domain: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        path: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        expires: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        httpOnly: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        secure: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        sameSite: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["Strict", "Lax", "None"]))
      });
      scheme.NetworkCookie = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString,
        domain: validatorPrimitives_1.tString,
        path: validatorPrimitives_1.tString,
        expires: validatorPrimitives_1.tNumber,
        httpOnly: validatorPrimitives_1.tBoolean,
        secure: validatorPrimitives_1.tBoolean,
        sameSite: validatorPrimitives_1.tEnum(["Strict", "Lax", "None"])
      });
      scheme.NameValue = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString
      });
      scheme.OriginStorage = validatorPrimitives_1.tObject({
        origin: validatorPrimitives_1.tString,
        localStorage: validatorPrimitives_1.tArray(tType("NameValue"))
      });
      scheme.SerializedError = validatorPrimitives_1.tObject({
        error: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          message: validatorPrimitives_1.tString,
          name: validatorPrimitives_1.tString,
          stack: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
        })),
        value: validatorPrimitives_1.tOptional(tType("SerializedValue"))
      });
      scheme.SelectorsRegisterParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        source: validatorPrimitives_1.tString,
        contentScript: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.BrowserTypeLaunchParams = validatorPrimitives_1.tObject({
        channel: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["chrome", "chrome-beta", "chrome-dev", "chrome-canary", "msedge", "msedge-beta", "msedge-dev", "msedge-canary", "firefox-stable"])),
        executablePath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        ignoreAllDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        ignoreDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        handleSIGINT: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGTERM: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGHUP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        env: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        headless: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        devtools: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          server: validatorPrimitives_1.tString,
          bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
        })),
        downloadsPath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        _traceDir: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        chromiumSandbox: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        firefoxUserPrefs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny),
        slowMo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.BrowserTypeLaunchPersistentContextParams = validatorPrimitives_1.tObject({
        channel: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["chrome", "chrome-beta", "chrome-dev", "chrome-canary", "msedge", "msedge-beta", "msedge-dev", "msedge-canary", "firefox-stable"])),
        executablePath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        ignoreAllDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        ignoreDefaultArgs: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        handleSIGINT: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGTERM: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        handleSIGHUP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        env: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        headless: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        devtools: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          server: validatorPrimitives_1.tString,
          bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
        })),
        downloadsPath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        _traceDir: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        chromiumSandbox: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        sdkLanguage: validatorPrimitives_1.tString,
        noDefaultViewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        viewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          width: validatorPrimitives_1.tNumber,
          height: validatorPrimitives_1.tNumber
        })),
        screen: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          width: validatorPrimitives_1.tNumber,
          height: validatorPrimitives_1.tNumber
        })),
        ignoreHTTPSErrors: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        javaScriptEnabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        bypassCSP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        userAgent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        locale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        timezoneId: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          longitude: validatorPrimitives_1.tNumber,
          latitude: validatorPrimitives_1.tNumber,
          accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
        })),
        permissions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        extraHTTPHeaders: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        offline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          username: validatorPrimitives_1.tString,
          password: validatorPrimitives_1.tString
        })),
        deviceScaleFactor: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        isMobile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasTouch: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["dark", "light", "no-preference"])),
        acceptDownloads: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        _debugName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        recordVideo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          dir: validatorPrimitives_1.tString,
          size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber
          }))
        })),
        recordHar: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          omitContent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
          path: validatorPrimitives_1.tString
        })),
        userDataDir: validatorPrimitives_1.tString,
        slowMo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.BrowserTypeConnectOverCDPParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        endpointURL: validatorPrimitives_1.tString,
        headers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        slowMo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.BrowserCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserKillForTestsParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserNewContextParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        noDefaultViewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        viewport: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          width: validatorPrimitives_1.tNumber,
          height: validatorPrimitives_1.tNumber
        })),
        screen: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          width: validatorPrimitives_1.tNumber,
          height: validatorPrimitives_1.tNumber
        })),
        ignoreHTTPSErrors: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        javaScriptEnabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        bypassCSP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        userAgent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        locale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        timezoneId: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          longitude: validatorPrimitives_1.tNumber,
          latitude: validatorPrimitives_1.tNumber,
          accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
        })),
        permissions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        extraHTTPHeaders: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        offline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          username: validatorPrimitives_1.tString,
          password: validatorPrimitives_1.tString
        })),
        deviceScaleFactor: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        isMobile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasTouch: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["dark", "light", "no-preference"])),
        acceptDownloads: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        _debugName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        recordVideo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          dir: validatorPrimitives_1.tString,
          size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber
          }))
        })),
        recordHar: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          omitContent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
          path: validatorPrimitives_1.tString
        })),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          server: validatorPrimitives_1.tString,
          bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
        })),
        storageState: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          cookies: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("SetNetworkCookie"))),
          origins: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("OriginStorage")))
        }))
      });
      scheme.BrowserNewBrowserCDPSessionParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserStartTracingParams = validatorPrimitives_1.tObject({
        page: validatorPrimitives_1.tOptional(tChannel("Page")),
        path: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        screenshots: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        categories: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString))
      });
      scheme.BrowserStopTracingParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextAddCookiesParams = validatorPrimitives_1.tObject({
        cookies: validatorPrimitives_1.tArray(tType("SetNetworkCookie"))
      });
      scheme.BrowserContextAddInitScriptParams = validatorPrimitives_1.tObject({
        source: validatorPrimitives_1.tString
      });
      scheme.BrowserContextClearCookiesParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextClearPermissionsParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextCookiesParams = validatorPrimitives_1.tObject({
        urls: validatorPrimitives_1.tArray(validatorPrimitives_1.tString)
      });
      scheme.BrowserContextExposeBindingParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        needsHandle: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.BrowserContextGrantPermissionsParams = validatorPrimitives_1.tObject({
        permissions: validatorPrimitives_1.tArray(validatorPrimitives_1.tString),
        origin: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.BrowserContextNewPageParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber
      });
      scheme.BrowserContextSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber
      });
      scheme.BrowserContextSetExtraHTTPHeadersParams = validatorPrimitives_1.tObject({
        headers: validatorPrimitives_1.tArray(tType("NameValue"))
      });
      scheme.BrowserContextSetGeolocationParams = validatorPrimitives_1.tObject({
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          longitude: validatorPrimitives_1.tNumber,
          latitude: validatorPrimitives_1.tNumber,
          accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
        }))
      });
      scheme.BrowserContextSetHTTPCredentialsParams = validatorPrimitives_1.tObject({
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          username: validatorPrimitives_1.tString,
          password: validatorPrimitives_1.tString
        }))
      });
      scheme.BrowserContextSetNetworkInterceptionEnabledParams = validatorPrimitives_1.tObject({
        enabled: validatorPrimitives_1.tBoolean
      });
      scheme.BrowserContextSetOfflineParams = validatorPrimitives_1.tObject({
        offline: validatorPrimitives_1.tBoolean
      });
      scheme.BrowserContextStorageStateParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextPauseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextRecorderSupplementEnableParams = validatorPrimitives_1.tObject({
        language: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        startRecording: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        pauseOnNextStatement: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        launchOptions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny),
        contextOptions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny),
        device: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        saveStorage: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        outputFile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.BrowserContextNewCDPSessionParams = validatorPrimitives_1.tObject({
        page: tChannel("Page")
      });
      scheme.BrowserContextTracingStartParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        snapshots: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        screenshots: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.BrowserContextTracingStopParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BrowserContextTracingExportParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.PageSetDefaultNavigationTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber
      });
      scheme.PageSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber
      });
      scheme.PageSetFileChooserInterceptedNoReplyParams = validatorPrimitives_1.tObject({
        intercepted: validatorPrimitives_1.tBoolean
      });
      scheme.PageAddInitScriptParams = validatorPrimitives_1.tObject({
        source: validatorPrimitives_1.tString
      });
      scheme.PageCloseParams = validatorPrimitives_1.tObject({
        runBeforeUnload: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.PageEmulateMediaParams = validatorPrimitives_1.tObject({
        media: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["screen", "print", "null"])),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["dark", "light", "no-preference", "null"]))
      });
      scheme.PageExposeBindingParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString,
        needsHandle: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.PageGoBackParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["load", "domcontentloaded", "networkidle"]))
      });
      scheme.PageGoForwardParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["load", "domcontentloaded", "networkidle"]))
      });
      scheme.PageReloadParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["load", "domcontentloaded", "networkidle"]))
      });
      scheme.PageScreenshotParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        type: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["png", "jpeg"])),
        quality: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        omitBackground: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        fullPage: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        clip: validatorPrimitives_1.tOptional(tType("Rect"))
      });
      scheme.PageSetExtraHTTPHeadersParams = validatorPrimitives_1.tObject({
        headers: validatorPrimitives_1.tArray(tType("NameValue"))
      });
      scheme.PageSetNetworkInterceptionEnabledParams = validatorPrimitives_1.tObject({
        enabled: validatorPrimitives_1.tBoolean
      });
      scheme.PageSetViewportSizeParams = validatorPrimitives_1.tObject({
        viewportSize: validatorPrimitives_1.tObject({
          width: validatorPrimitives_1.tNumber,
          height: validatorPrimitives_1.tNumber
        })
      });
      scheme.PageKeyboardDownParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString
      });
      scheme.PageKeyboardUpParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString
      });
      scheme.PageKeyboardInsertTextParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString
      });
      scheme.PageKeyboardTypeParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.PageKeyboardPressParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.PageMouseMoveParams = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
        steps: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.PageMouseDownParams = validatorPrimitives_1.tObject({
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["left", "right", "middle"])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.PageMouseUpParams = validatorPrimitives_1.tObject({
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["left", "right", "middle"])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.PageMouseClickParams = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["left", "right", "middle"])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.PageTouchscreenTapParams = validatorPrimitives_1.tObject({
        x: validatorPrimitives_1.tNumber,
        y: validatorPrimitives_1.tNumber
      });
      scheme.PageAccessibilitySnapshotParams = validatorPrimitives_1.tObject({
        interestingOnly: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        root: validatorPrimitives_1.tOptional(tChannel("ElementHandle"))
      });
      scheme.PagePdfParams = validatorPrimitives_1.tObject({
        scale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        displayHeaderFooter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        headerTemplate: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        footerTemplate: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        printBackground: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        landscape: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        pageRanges: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        format: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        width: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        height: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        preferCSSPageSize: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        margin: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          top: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          bottom: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          left: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          right: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
        }))
      });
      scheme.PageStartJSCoverageParams = validatorPrimitives_1.tObject({
        resetOnNavigation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        reportAnonymousScripts: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.PageStopJSCoverageParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.PageStartCSSCoverageParams = validatorPrimitives_1.tObject({
        resetOnNavigation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.PageStopCSSCoverageParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.PageBringToFrontParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.FrameEvalOnSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameEvalOnSelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameAddScriptTagParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        content: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        type: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.FrameAddStyleTagParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        content: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.FrameCheckParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameClickParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["left", "right", "middle"])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameContentParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.FrameDblclickParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["left", "right", "middle"])),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameDispatchEventParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        type: validatorPrimitives_1.tString,
        eventInit: tType("SerializedArgument"),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument"),
        world: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["main", "utility"]))
      });
      scheme.FrameEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument"),
        world: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["main", "utility"]))
      });
      scheme.FrameFillParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        value: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameFocusParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameFrameElementParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.FrameGetAttributeParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        name: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameGotoParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["load", "domcontentloaded", "networkidle"])),
        referer: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.FrameHoverParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameInnerHTMLParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameInnerTextParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameIsCheckedParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameIsDisabledParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameIsEnabledParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameIsHiddenParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameIsVisibleParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameIsEditableParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FramePressParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        key: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameQuerySelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString
      });
      scheme.FrameQuerySelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString
      });
      scheme.FrameSelectOptionParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        elements: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tChannel("ElementHandle"))),
        options: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
          value: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          label: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          index: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
        }))),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameSetContentParams = validatorPrimitives_1.tObject({
        html: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        waitUntil: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["load", "domcontentloaded", "networkidle"]))
      });
      scheme.FrameSetInputFilesParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        files: validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
          name: validatorPrimitives_1.tString,
          mimeType: validatorPrimitives_1.tString,
          buffer: validatorPrimitives_1.tBinary
        })),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameTapParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameTextContentParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameTitleParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.FrameTypeParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        text: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameUncheckParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.FrameWaitForFunctionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument"),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        pollingInterval: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.FrameWaitForSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        state: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["attached", "detached", "visible", "hidden"]))
      });
      scheme.WorkerEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.WorkerEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.JSHandleDisposeParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleDisposeParams = tType("JSHandleDisposeParams");
      scheme.JSHandleEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvaluateExpressionParams = tType("JSHandleEvaluateExpressionParams");
      scheme.JSHandleEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvaluateExpressionHandleParams = tType("JSHandleEvaluateExpressionHandleParams");
      scheme.JSHandleGetPropertyListParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleGetPropertyListParams = tType("JSHandleGetPropertyListParams");
      scheme.JSHandleGetPropertyParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString
      });
      scheme.ElementHandleGetPropertyParams = tType("JSHandleGetPropertyParams");
      scheme.JSHandleJsonValueParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleJsonValueParams = tType("JSHandleJsonValueParams");
      scheme.ElementHandleEvalOnSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvalOnSelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleBoundingBoxParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleCheckParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleClickParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["left", "right", "middle"])),
        clickCount: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleContentFrameParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleDblclickParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        button: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["left", "right", "middle"])),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleDispatchEventParams = validatorPrimitives_1.tObject({
        type: validatorPrimitives_1.tString,
        eventInit: tType("SerializedArgument")
      });
      scheme.ElementHandleFillParams = validatorPrimitives_1.tObject({
        value: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleFocusParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleGetAttributeParams = validatorPrimitives_1.tObject({
        name: validatorPrimitives_1.tString
      });
      scheme.ElementHandleHoverParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleInnerHTMLParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleInnerTextParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleIsCheckedParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleIsDisabledParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleIsEditableParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleIsEnabledParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleIsHiddenParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleIsVisibleParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleOwnerFrameParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandlePressParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleQuerySelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString
      });
      scheme.ElementHandleQuerySelectorAllParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString
      });
      scheme.ElementHandleScreenshotParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        type: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["png", "jpeg"])),
        quality: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        omitBackground: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleScrollIntoViewIfNeededParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.ElementHandleSelectOptionParams = validatorPrimitives_1.tObject({
        elements: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tChannel("ElementHandle"))),
        options: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
          value: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          label: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          index: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
        }))),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleSelectTextParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.ElementHandleSetInputFilesParams = validatorPrimitives_1.tObject({
        files: validatorPrimitives_1.tArray(validatorPrimitives_1.tObject({
          name: validatorPrimitives_1.tString,
          mimeType: validatorPrimitives_1.tString,
          buffer: validatorPrimitives_1.tBinary
        })),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleTapParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        modifiers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tEnum(["Alt", "Control", "Meta", "Shift"]))),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleTextContentParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElementHandleTypeParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString,
        delay: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.ElementHandleUncheckParams = validatorPrimitives_1.tObject({
        force: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        noWaitAfter: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        position: validatorPrimitives_1.tOptional(tType("Point")),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        trial: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ElementHandleWaitForElementStateParams = validatorPrimitives_1.tObject({
        state: validatorPrimitives_1.tEnum(["visible", "hidden", "stable", "enabled", "disabled", "editable"]),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.ElementHandleWaitForSelectorParams = validatorPrimitives_1.tObject({
        selector: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        state: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["attached", "detached", "visible", "hidden"]))
      });
      scheme.RequestResponseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.RouteAbortParams = validatorPrimitives_1.tObject({
        errorCode: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.RouteContinueParams = validatorPrimitives_1.tObject({
        url: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        method: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        headers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        postData: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBinary)
      });
      scheme.RouteFulfillParams = validatorPrimitives_1.tObject({
        status: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        headers: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        body: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        isBase64: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean)
      });
      scheme.ResourceTiming = validatorPrimitives_1.tObject({
        startTime: validatorPrimitives_1.tNumber,
        domainLookupStart: validatorPrimitives_1.tNumber,
        domainLookupEnd: validatorPrimitives_1.tNumber,
        connectStart: validatorPrimitives_1.tNumber,
        secureConnectionStart: validatorPrimitives_1.tNumber,
        connectEnd: validatorPrimitives_1.tNumber,
        requestStart: validatorPrimitives_1.tNumber,
        responseStart: validatorPrimitives_1.tNumber
      });
      scheme.ResponseBodyParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ResponseFinishedParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.BindingCallRejectParams = validatorPrimitives_1.tObject({
        error: tType("SerializedError")
      });
      scheme.BindingCallResolveParams = validatorPrimitives_1.tObject({
        result: tType("SerializedArgument")
      });
      scheme.DialogAcceptParams = validatorPrimitives_1.tObject({
        promptText: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.DialogDismissParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ArtifactPathAfterFinishedParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ArtifactSaveAsParams = validatorPrimitives_1.tObject({
        path: validatorPrimitives_1.tString
      });
      scheme.ArtifactSaveAsStreamParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ArtifactFailureParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ArtifactStreamParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ArtifactDeleteParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.StreamReadParams = validatorPrimitives_1.tObject({
        size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.StreamCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.CDPSessionSendParams = validatorPrimitives_1.tObject({
        method: validatorPrimitives_1.tString,
        params: validatorPrimitives_1.tOptional(validatorPrimitives_1.tAny)
      });
      scheme.CDPSessionDetachParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.ElectronLaunchParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        executablePath: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        cwd: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        env: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.ElectronApplicationBrowserWindowParams = validatorPrimitives_1.tObject({
        page: tChannel("Page")
      });
      scheme.ElectronApplicationEvaluateExpressionParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElectronApplicationEvaluateExpressionHandleParams = validatorPrimitives_1.tObject({
        expression: validatorPrimitives_1.tString,
        isFunction: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElectronApplicationCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.AndroidDevicesParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.AndroidSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber
      });
      scheme.AndroidSocketWriteParams = validatorPrimitives_1.tObject({
        data: validatorPrimitives_1.tBinary
      });
      scheme.AndroidSocketCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.AndroidDeviceWaitParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        state: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["gone"])),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceFillParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        text: validatorPrimitives_1.tString,
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceTapParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        duration: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceDragParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        dest: tType("Point"),
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceFlingParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        direction: validatorPrimitives_1.tEnum(["up", "down", "left", "right"]),
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceLongTapParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDevicePinchCloseParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDevicePinchOpenParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceScrollParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        direction: validatorPrimitives_1.tEnum(["up", "down", "left", "right"]),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceSwipeParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector"),
        direction: validatorPrimitives_1.tEnum(["up", "down", "left", "right"]),
        percent: validatorPrimitives_1.tNumber,
        speed: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        timeout: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceInfoParams = validatorPrimitives_1.tObject({
        selector: tType("AndroidSelector")
      });
      scheme.AndroidDeviceScreenshotParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.AndroidDeviceInputTypeParams = validatorPrimitives_1.tObject({
        text: validatorPrimitives_1.tString
      });
      scheme.AndroidDeviceInputPressParams = validatorPrimitives_1.tObject({
        key: validatorPrimitives_1.tString
      });
      scheme.AndroidDeviceInputTapParams = validatorPrimitives_1.tObject({
        point: tType("Point")
      });
      scheme.AndroidDeviceInputSwipeParams = validatorPrimitives_1.tObject({
        segments: validatorPrimitives_1.tArray(tType("Point")),
        steps: validatorPrimitives_1.tNumber
      });
      scheme.AndroidDeviceInputDragParams = validatorPrimitives_1.tObject({
        from: tType("Point"),
        to: tType("Point"),
        steps: validatorPrimitives_1.tNumber
      });
      scheme.AndroidDeviceLaunchBrowserParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        pkg: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        ignoreHTTPSErrors: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        javaScriptEnabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        bypassCSP: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        userAgent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        locale: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        timezoneId: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        geolocation: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          longitude: validatorPrimitives_1.tNumber,
          latitude: validatorPrimitives_1.tNumber,
          accuracy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
        })),
        permissions: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString)),
        extraHTTPHeaders: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("NameValue"))),
        offline: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        httpCredentials: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          username: validatorPrimitives_1.tString,
          password: validatorPrimitives_1.tString
        })),
        deviceScaleFactor: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        isMobile: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasTouch: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        colorScheme: validatorPrimitives_1.tOptional(validatorPrimitives_1.tEnum(["dark", "light", "no-preference"])),
        acceptDownloads: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        _debugName: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        recordVideo: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          dir: validatorPrimitives_1.tString,
          size: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
            width: validatorPrimitives_1.tNumber,
            height: validatorPrimitives_1.tNumber
          }))
        })),
        recordHar: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          omitContent: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
          path: validatorPrimitives_1.tString
        })),
        proxy: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          server: validatorPrimitives_1.tString,
          bypass: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          username: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
          password: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
        }))
      });
      scheme.AndroidDeviceOpenParams = validatorPrimitives_1.tObject({
        command: validatorPrimitives_1.tString
      });
      scheme.AndroidDeviceShellParams = validatorPrimitives_1.tObject({
        command: validatorPrimitives_1.tString
      });
      scheme.AndroidDeviceInstallApkParams = validatorPrimitives_1.tObject({
        file: validatorPrimitives_1.tBinary,
        args: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(validatorPrimitives_1.tString))
      });
      scheme.AndroidDevicePushParams = validatorPrimitives_1.tObject({
        file: validatorPrimitives_1.tBinary,
        path: validatorPrimitives_1.tString,
        mode: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
      });
      scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = validatorPrimitives_1.tObject({
        timeout: validatorPrimitives_1.tNumber
      });
      scheme.AndroidDeviceConnectToWebViewParams = validatorPrimitives_1.tObject({
        sdkLanguage: validatorPrimitives_1.tString,
        pid: validatorPrimitives_1.tNumber
      });
      scheme.AndroidDeviceCloseParams = validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({}));
      scheme.AndroidWebView = validatorPrimitives_1.tObject({
        pid: validatorPrimitives_1.tNumber,
        pkg: validatorPrimitives_1.tString
      });
      scheme.AndroidSelector = validatorPrimitives_1.tObject({
        checkable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        checked: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        clazz: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        clickable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        depth: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber),
        desc: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        enabled: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        focusable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        focused: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        hasChild: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          selector: tType("AndroidSelector")
        })),
        hasDescendant: validatorPrimitives_1.tOptional(validatorPrimitives_1.tObject({
          selector: tType("AndroidSelector"),
          maxDepth: validatorPrimitives_1.tOptional(validatorPrimitives_1.tNumber)
        })),
        longClickable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        pkg: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        res: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString),
        scrollable: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        selected: validatorPrimitives_1.tOptional(validatorPrimitives_1.tBoolean),
        text: validatorPrimitives_1.tOptional(validatorPrimitives_1.tString)
      });
      scheme.AndroidElementInfo = validatorPrimitives_1.tObject({
        children: validatorPrimitives_1.tOptional(validatorPrimitives_1.tArray(tType("AndroidElementInfo"))),
        clazz: validatorPrimitives_1.tString,
        desc: validatorPrimitives_1.tString,
        res: validatorPrimitives_1.tString,
        pkg: validatorPrimitives_1.tString,
        text: validatorPrimitives_1.tString,
        bounds: tType("Rect"),
        checkable: validatorPrimitives_1.tBoolean,
        checked: validatorPrimitives_1.tBoolean,
        clickable: validatorPrimitives_1.tBoolean,
        enabled: validatorPrimitives_1.tBoolean,
        focusable: validatorPrimitives_1.tBoolean,
        focused: validatorPrimitives_1.tBoolean,
        longClickable: validatorPrimitives_1.tBoolean,
        scrollable: validatorPrimitives_1.tBoolean,
        selected: validatorPrimitives_1.tBoolean
      });
      return scheme;
    }
    exports2.createScheme = createScheme;
  }
});

// node_modules/playwright/lib/server/instrumentation.js
var require_instrumentation = __commonJS({
  "node_modules/playwright/lib/server/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.internalCallMetadata = exports2.createInstrumentation = exports2.SdkObject = void 0;
    var events_1 = require("events");
    var utils_1 = require_utils();
    var SdkObject = class extends events_1.EventEmitter {
      constructor(parent, guidPrefix, guid) {
        super();
        this.guid = guid || `${guidPrefix || ""}@${utils_1.createGuid()}`;
        this.setMaxListeners(0);
        this.attribution = {...parent.attribution};
        this.instrumentation = parent.instrumentation;
      }
    };
    exports2.SdkObject = SdkObject;
    function createInstrumentation() {
      const listeners = [];
      return new Proxy({}, {
        get: (obj, prop) => {
          if (prop === "addListener")
            return (listener) => listeners.push(listener);
          if (prop === "removeListener")
            return (listener) => listeners.splice(listeners.indexOf(listener), 1);
          if (!prop.startsWith("on"))
            return obj[prop];
          return async (...params) => {
            var _a, _b;
            for (const listener of listeners)
              await ((_b = (_a = listener)[prop]) === null || _b === void 0 ? void 0 : _b.call(_a, ...params));
          };
        }
      });
    }
    exports2.createInstrumentation = createInstrumentation;
    function internalCallMetadata() {
      return {
        id: "",
        startTime: 0,
        endTime: 0,
        type: "Internal",
        method: "",
        params: {},
        log: [],
        snapshots: []
      };
    }
    exports2.internalCallMetadata = internalCallMetadata;
  }
});

// node_modules/stack-utils/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/stack-utils/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "node_modules/stack-utils/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var natives = [].concat(require("module").builtinModules, "bootstrap_node", "node").map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
    var StackUtils = class {
      constructor(opts) {
        opts = {
          ignoredPackages: [],
          ...opts
        };
        if ("internals" in opts === false) {
          opts.internals = StackUtils.nodeInternals();
        }
        if ("cwd" in opts === false) {
          opts.cwd = process.cwd();
        }
        this._cwd = opts.cwd.replace(/\\/g, "/");
        this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
        this._wrapCallSite = opts.wrapCallSite || false;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent);
        if (!Array.isArray(stack)) {
          stack = stack.split("\n");
        }
        if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
          stack = stack.slice(1);
        }
        let outdent = false;
        let lastNonAtLine = null;
        const result = [];
        stack.forEach((st) => {
          st = st.replace(/\\/g, "/");
          if (this._internals.some((internal) => internal.test(st))) {
            return;
          }
          const isAtLine = /^\s*at /.test(st);
          if (outdent) {
            st = st.trimEnd().replace(/^(\s+)at /, "$1");
          } else {
            st = st.trim();
            if (isAtLine) {
              st = st.slice(3);
            }
          }
          st = st.replace(`${this._cwd}/`, "");
          if (st) {
            if (isAtLine) {
              if (lastNonAtLine) {
                result.push(lastNonAtLine);
                lastNonAtLine = null;
              }
              result.push(st);
            } else {
              outdent = true;
              lastNonAtLine = st;
            }
          }
        });
        return result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const {stackTraceLimit} = Error;
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const {stack} = obj;
        Error.stackTraceLimit = stackTraceLimit;
        return this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const {prepareStackTrace, stackTraceLimit} = Error;
        Error.prepareStackTrace = (obj2, site) => {
          if (this._wrapCallSite) {
            return site.map(this._wrapCallSite);
          }
          return site;
        };
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const {stack} = obj;
        Object.assign(Error, {prepareStackTrace, stackTraceLimit});
        return stack;
      }
      at(fn = this.at) {
        const [site] = this.capture(1, fn);
        if (!site) {
          return {};
        }
        const res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd);
        if (site.isConstructor()) {
          res.constructor = true;
        }
        if (site.isEval()) {
          res.evalOrigin = site.getEvalOrigin();
        }
        if (site.isNative()) {
          res.native = true;
        }
        let typename;
        try {
          typename = site.getTypeName();
        } catch (_) {
        }
        if (typename && typename !== "Object" && typename !== "[object Object]") {
          res.type = typename;
        }
        const fname = site.getFunctionName();
        if (fname) {
          res.function = fname;
        }
        const meth = site.getMethodName();
        if (meth && fname !== meth) {
          res.method = meth;
        }
        return res;
      }
      parseLine(line) {
        const match = line && line.match(re);
        if (!match) {
          return null;
        }
        const ctor = match[1] === "new";
        let fname = match[2];
        const evalOrigin = match[3];
        const evalFile = match[4];
        const evalLine = Number(match[5]);
        const evalCol = Number(match[6]);
        let file = match[7];
        const lnum = match[8];
        const col = match[9];
        const native = match[10] === "native";
        const closeParen = match[11] === ")";
        let method;
        const res = {};
        if (lnum) {
          res.line = Number(lnum);
        }
        if (col) {
          res.column = Number(col);
        }
        if (closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--) {
            if (file.charAt(i) === ")") {
              closes++;
            } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
              closes--;
              if (closes === -1 && file.charAt(i - 1) === " ") {
                const before = file.slice(0, i - 1);
                const after = file.slice(i + 1);
                file = after;
                fname += ` (${before}`;
                break;
              }
            }
          }
        }
        if (fname) {
          const methodMatch = fname.match(methodRe);
          if (methodMatch) {
            fname = methodMatch[1];
            method = methodMatch[2];
          }
        }
        setFile(res, file, this._cwd);
        if (ctor) {
          res.constructor = true;
        }
        if (evalOrigin) {
          res.evalOrigin = evalOrigin;
          res.evalLine = evalLine;
          res.evalColumn = evalCol;
          res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
        }
        if (native) {
          res.native = true;
        }
        if (fname) {
          res.function = fname;
        }
        if (method && fname !== method) {
          res.method = method;
        }
        return res;
      }
    };
    function setFile(result, filename, cwd) {
      if (filename) {
        filename = filename.replace(/\\/g, "/");
        if (filename.startsWith(`${cwd}/`)) {
          filename = filename.slice(cwd.length + 1);
        }
        result.file = filename;
      }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0) {
        return [];
      }
      const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$");
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    module2.exports = StackUtils;
  }
});

// node_modules/playwright/lib/utils/stackTrace.js
var require_stackTrace = __commonJS({
  "node_modules/playwright/lib/utils/stackTrace.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.splitErrorMessage = exports2.captureStackTrace = exports2.rewriteErrorMessage = exports2.getCallerFilePath = void 0;
    var path_1 = __importDefault(require("path"));
    var stack_utils_1 = __importDefault(require_stack_utils());
    var utils_1 = require_utils();
    var stackUtils = new stack_utils_1.default();
    function getCallerFilePath(ignorePrefix) {
      const frame = captureStackTrace().frames.find((f) => !f.file.startsWith(ignorePrefix));
      return frame ? frame.file : null;
    }
    exports2.getCallerFilePath = getCallerFilePath;
    function rewriteErrorMessage(e, newMessage) {
      if (e.stack) {
        const index2 = e.stack.indexOf(e.message);
        if (index2 !== -1)
          e.stack = e.stack.substring(0, index2) + newMessage + e.stack.substring(index2 + e.message.length);
      }
      e.message = newMessage;
      return e;
    }
    exports2.rewriteErrorMessage = rewriteErrorMessage;
    var PW_LIB_DIRS = [
      "playwright",
      "playwright-chromium",
      "playwright-firefox",
      "playwright-webkit"
    ].map((packageName) => path_1.default.sep + path_1.default.join(packageName, "lib"));
    function captureStackTrace() {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 30;
      const stack = new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      const frames = [];
      for (const line of stack.split("\n")) {
        const frame = stackUtils.parseLine(line);
        if (!frame || !frame.file)
          continue;
        if (frame.file.startsWith("internal"))
          continue;
        const fileName = path_1.default.resolve(process.cwd(), frame.file);
        if (PW_LIB_DIRS.some((libDir) => fileName.includes(libDir)))
          continue;
        if (utils_1.isUnderTest() && fileName.includes(path_1.default.join("playwright", "src")))
          continue;
        if (utils_1.isUnderTest() && fileName.includes(path_1.default.join("playwright", "tests", "config", "coverage.js")))
          continue;
        frames.push({
          file: fileName,
          line: frame.line,
          column: frame.column,
          function: frame.function
        });
      }
      return {stack, frames};
    }
    exports2.captureStackTrace = captureStackTrace;
    function splitErrorMessage(message) {
      const separationIdx = message.indexOf(":");
      return {
        name: separationIdx !== -1 ? message.slice(0, separationIdx) : "",
        message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
      };
    }
    exports2.splitErrorMessage = splitErrorMessage;
  }
});

// node_modules/playwright/lib/dispatchers/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/dispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.DispatcherConnection = exports2.Dispatcher = exports2.lookupNullableDispatcher = exports2.existingDispatcher = exports2.lookupDispatcher = exports2.dispatcherSymbol = void 0;
    var events_1 = require("events");
    var serializers_1 = require_serializers();
    var validator_1 = require_validator();
    var utils_1 = require_utils();
    var validatorPrimitives_1 = require_validatorPrimitives();
    var errors_1 = require_errors();
    var instrumentation_1 = require_instrumentation();
    var stackTrace_1 = require_stackTrace();
    exports2.dispatcherSymbol = Symbol("dispatcher");
    function lookupDispatcher(object) {
      const result = object[exports2.dispatcherSymbol];
      utils_1.debugAssert(result);
      return result;
    }
    exports2.lookupDispatcher = lookupDispatcher;
    function existingDispatcher(object) {
      return object[exports2.dispatcherSymbol];
    }
    exports2.existingDispatcher = existingDispatcher;
    function lookupNullableDispatcher(object) {
      return object ? lookupDispatcher(object) : void 0;
    }
    exports2.lookupNullableDispatcher = lookupNullableDispatcher;
    var Dispatcher = class extends events_1.EventEmitter {
      constructor(parent, object, type, initializer, isScope) {
        super();
        this._dispatchers = new Map();
        this._disposed = false;
        this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
        this._isScope = !!isScope;
        this._parent = parent instanceof DispatcherConnection ? void 0 : parent;
        this._scope = isScope ? this : this._parent;
        const guid = object.guid;
        utils_1.assert(!this._connection._dispatchers.has(guid));
        this._connection._dispatchers.set(guid, this);
        if (this._parent) {
          utils_1.assert(!this._parent._dispatchers.has(guid));
          this._parent._dispatchers.set(guid, this);
        }
        this._type = type;
        this._guid = guid;
        this._object = object;
        object[exports2.dispatcherSymbol] = this;
        if (this._parent)
          this._connection.sendMessageToClient(this._parent._guid, type, "__create__", {type, initializer, guid});
      }
      _dispatchEvent(method, params = {}) {
        if (this._disposed) {
          if (utils_1.isUnderTest())
            throw new Error(`${this._guid} is sending "${method}" event after being disposed`);
          return;
        }
        const sdkObject = this._object instanceof instrumentation_1.SdkObject ? this._object : void 0;
        this._connection.sendMessageToClient(this._guid, this._type, method, params, sdkObject);
      }
      _dispose() {
        utils_1.assert(!this._disposed);
        this._disposed = true;
        if (this._parent)
          this._parent._dispatchers.delete(this._guid);
        this._connection._dispatchers.delete(this._guid);
        for (const dispatcher of [...this._dispatchers.values()])
          dispatcher._dispose();
        this._dispatchers.clear();
        if (this._isScope)
          this._connection.sendMessageToClient(this._guid, this._type, "__dispose__", {});
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._dispatchers.values()).map((o) => o._debugScopeState())
        };
      }
      async waitForEventInfo() {
      }
    };
    exports2.Dispatcher = Dispatcher;
    var Root2 = class extends Dispatcher {
      constructor(connection) {
        super(connection, {guid: ""}, "", {}, true);
      }
    };
    var DispatcherConnection = class {
      constructor() {
        this._dispatchers = new Map();
        this.onmessage = (message) => {
        };
        this._waitOperations = new Map();
        this._rootDispatcher = new Root2(this);
        const tChannel = (name) => {
          return (arg, path) => {
            if (arg && typeof arg === "object" && typeof arg.guid === "string") {
              const guid = arg.guid;
              const dispatcher = this._dispatchers.get(guid);
              if (!dispatcher)
                throw new validator_1.ValidationError(`${path}: no object with guid ${guid}`);
              if (name !== "*" && dispatcher._type !== name)
                throw new validator_1.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${name}`);
              return dispatcher;
            }
            throw new validator_1.ValidationError(`${path}: expected ${name}`);
          };
        };
        const scheme = validator_1.createScheme(tChannel);
        this._validateParams = (type, method, params) => {
          if (method === "waitForEventInfo")
            return validatorPrimitives_1.tOptional(scheme["WaitForEventInfo"])(params.info, "");
          const name = type + method[0].toUpperCase() + method.substring(1) + "Params";
          if (!scheme[name])
            throw new validator_1.ValidationError(`Unknown scheme for ${type}.${method}`);
          return scheme[name](params, "");
        };
        this._validateMetadata = (metadata) => {
          return validatorPrimitives_1.tOptional(scheme["Metadata"])(metadata, "");
        };
      }
      sendMessageToClient(guid, type, method, params, sdkObject) {
        var _a, _b;
        params = this._replaceDispatchersWithGuids(params);
        if (sdkObject) {
          const eventMetadata = {
            id: `event@${++lastEventId}`,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: (_a = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.page) === null || _a === void 0 ? void 0 : _a.guid,
            frameId: (_b = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.frame) === null || _b === void 0 ? void 0 : _b.guid,
            startTime: utils_1.monotonicTime(),
            endTime: 0,
            type,
            method,
            params: params || {},
            log: [],
            snapshots: []
          };
          sdkObject.instrumentation.onEvent(sdkObject, eventMetadata);
        }
        this.onmessage({guid, method, params});
      }
      rootDispatcher() {
        return this._rootDispatcher;
      }
      async dispatch(message) {
        var _a, _b, _c;
        const {id, guid, method, params, metadata} = message;
        const dispatcher = this._dispatchers.get(guid);
        if (!dispatcher) {
          this.onmessage({id, error: serializers_1.serializeError(new Error(errors_1.kBrowserOrContextClosedError))});
          return;
        }
        if (method === "debugScopeState") {
          this.onmessage({id, result: this._rootDispatcher._debugScopeState()});
          return;
        }
        let validParams;
        let validMetadata;
        try {
          validParams = this._validateParams(dispatcher._type, method, params);
          validMetadata = this._validateMetadata(metadata);
          if (typeof dispatcher[method] !== "function")
            throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
        } catch (e) {
          this.onmessage({id, error: serializers_1.serializeError(e)});
          return;
        }
        const sdkObject = dispatcher._object instanceof instrumentation_1.SdkObject ? dispatcher._object : void 0;
        const callMetadata = {
          id: `call@${id}`,
          ...validMetadata,
          objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
          pageId: (_a = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.page) === null || _a === void 0 ? void 0 : _a.guid,
          frameId: (_b = sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.attribution.frame) === null || _b === void 0 ? void 0 : _b.guid,
          startTime: utils_1.monotonicTime(),
          endTime: 0,
          type: dispatcher._type,
          method,
          params: params || {},
          log: [],
          snapshots: []
        };
        if (sdkObject && ((_c = params === null || params === void 0 ? void 0 : params.info) === null || _c === void 0 ? void 0 : _c.waitId)) {
          const info = params.info;
          switch (info.phase) {
            case "before": {
              callMetadata.apiName = info.apiName;
              this._waitOperations.set(info.waitId, callMetadata);
              await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
              return;
            }
            case "log": {
              const originalMetadata = this._waitOperations.get(info.waitId);
              originalMetadata.log.push(info.message);
              sdkObject.instrumentation.onCallLog("api", info.message, sdkObject, originalMetadata);
              return;
            }
            case "after": {
              const originalMetadata = this._waitOperations.get(info.waitId);
              originalMetadata.endTime = utils_1.monotonicTime();
              originalMetadata.error = info.error;
              this._waitOperations.delete(info.waitId);
              await sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
              return;
            }
          }
        }
        let result;
        let error3;
        await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata));
        try {
          result = await dispatcher[method](validParams, callMetadata);
        } catch (e) {
          callMetadata.error = e.message;
          if (callMetadata.log.length)
            stackTrace_1.rewriteErrorMessage(e, e.message + formatLogRecording(callMetadata.log) + kLoggingNote);
          error3 = serializers_1.serializeError(e);
        } finally {
          callMetadata.endTime = utils_1.monotonicTime();
          await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata));
        }
        if (error3)
          this.onmessage({id, error: error3});
        else
          this.onmessage({id, result: this._replaceDispatchersWithGuids(result)});
      }
      _replaceDispatchersWithGuids(payload) {
        if (!payload)
          return payload;
        if (payload instanceof Dispatcher)
          return {guid: payload._guid};
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceDispatchersWithGuids(p));
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceDispatchersWithGuids(payload[key]);
          return result;
        }
        return payload;
      }
    };
    exports2.DispatcherConnection = DispatcherConnection;
    var kLoggingNote = `
Note: use DEBUG=pw:api environment variable to capture Playwright logs.`;
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
    var lastEventId = 0;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module2.exports = require_common2()(exports2);
    var {formatters} = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var {env: env2} = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error3) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const {namespace: name, useColors: useColors2} = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var {formatters} = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var {EMPTY_BUFFER} = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var {kStatusCode, NOOP} = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var {Writable} = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var {concat, toArrayBuffer, unmask} = require_buffer_util();
    var {isValidStatusCode, isValidUTF8} = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error3(RangeError, "RSV2 and RSV3 must be clear", true, 1002);
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error3(RangeError, "RSV1 must be clear", true, 1002);
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error3(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (!this._fragmented) {
            this._loop = false;
            return error3(RangeError, "invalid opcode 0", true, 1002);
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error3(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error3(RangeError, "FIN must be set", true, 1002);
          }
          if (compressed) {
            this._loop = false;
            return error3(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error3(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002);
          }
        } else {
          this._loop = false;
          return error3(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error3(RangeError, "MASK must be set", true, 1002);
          }
        } else if (this._masked) {
          this._loop = false;
          return error3(RangeError, "MASK must be clear", true, 1002);
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error3(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009);
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error3(RangeError, "Max payload size exceeded", false, 1009);
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error3(RangeError, "Max payload size exceeded", false, 1009));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error3(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error3(RangeError, "invalid payload length 1", true, 1002);
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error3(RangeError, `invalid status code ${code}`, true, 1002);
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error3(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error3(ErrorCtor, message, prefix, statusCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error3);
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var {randomFillSync} = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var {EMPTY_BUFFER} = require_constants();
    var {isValidStatusCode} = require_validation();
    var {mask: applyMask, toBuffer} = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options2) {
        const merge = options2.mask && options2.readOnly;
        let offset = options2.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options2.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data, options2, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options2.fin,
            rsv1,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(buf, {
            fin: options2.fin,
            rsv1: false,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options2.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options2.readOnly = false;
          this.sendFrame(Sender.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event2 = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event2 {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event2 {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event2 {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event2 {
      constructor(error3, target) {
        super("error", target);
        this.message = error3.message;
        this.error = error3;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options2) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error3) {
          listener.call(this, new ErrorEvent(error3, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options2 && options2.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format2(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = {format: format2, parse};
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https2 = require("https");
    var http2 = require("http");
    var net = require("net");
    var tls = require("tls");
    var {randomBytes: randomBytes2, createHash} = require("crypto");
    var {URL: URL2} = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {addEventListener, removeEventListener} = require_event_target();
    var {format: format2, parse} = require_extension();
    var {toBuffer} = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options2 = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && this._closeFrameReceived)
            this._socket.end();
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived)
            this._socket.end();
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options2
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    readyStates.forEach((readyState, i) => {
      const descriptor = {enumerable: true, value: i};
      Object.defineProperty(WebSocket.prototype, readyState, descriptor);
      Object.defineProperty(WebSocket, readyState, descriptor);
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, {enumerable: true});
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        configurable: true,
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options2) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options2,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        throw new Error(`Invalid URL: ${websocket.url}`);
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes2(16).toString("base64");
      const get2 = isSecure ? https2.get : http2.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format2({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req = websocket._req = get2(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        websocket._readyState = WebSocket.CLOSING;
        websocket.emit("error", err);
        websocket.emitClose();
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          const addr = new URL2(location2, address);
          initAsClient(websocket, addr, protocols, options2);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        if (perMessageDeflate) {
          try {
            const extensions = parse(res.headers["sec-websocket-extensions"]);
            if (extensions[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
              websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
            return;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function netConnect(options2) {
      options2.path = options2.socketPath;
      return net.connect(options2);
    }
    function tlsConnect(options2) {
      options2.path = void 0;
      if (!options2.servername && options2.servername !== "") {
        options2.servername = net.isIP(options2.host) ? "" : options2.host;
      }
      return tls.connect(options2);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._socket.resume();
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._readyState = WebSocket.CLOSING;
      websocket._closeCode = err[kStatusCode];
      websocket.emit("error", err);
      websocket._socket.destroy();
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      websocket._socket.read();
      websocket._receiver.end();
      this.removeListener("data", socketOnData);
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var {Duplex} = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options2) {
      let resumeOnReceiverDrain = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options2,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error3(err) {
        if (duplex.destroyed)
          return;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error3(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var {createHash} = require("crypto");
    var {createServer, STATUS_CODES} = require("http");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var {format: format2, parse} = require_extension();
    var {GUID, kWebSocket} = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var WebSocketServer = class extends EventEmitter {
      constructor(options2, callback) {
        super();
        options2 = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          ...options2
        };
        if (options2.port == null && !options2.server && !options2.noServer) {
          throw new TypeError('One of the "port", "server", or "noServer" options must be specified');
        }
        if (options2.port != null) {
          this._server = createServer((req, res) => {
            const body = STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options2.port, options2.host, options2.backlog, callback);
        } else if (options2.server) {
          this._server = options2.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options2.perMessageDeflate === true)
          options2.perMessageDeflate = {};
        if (options2.clientTracking)
          this.clients = new Set();
        this.options = options2;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(() => this.emit("close"));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index2 = req.url.indexOf("?");
          const pathname = index2 !== -1 ? req.url.slice(0, index2) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format2({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(`HTTP/1.1 ${code} ${STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// node_modules/playwright/lib/utils/timeoutSettings.js
var require_timeoutSettings = __commonJS({
  "node_modules/playwright/lib/utils/timeoutSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.TimeoutSettings = exports2.DEFAULT_TIMEOUT = void 0;
    var utils_1 = require_utils();
    exports2.DEFAULT_TIMEOUT = 3e4;
    var TIMEOUT = utils_1.debugMode() ? 0 : exports2.DEFAULT_TIMEOUT;
    var TimeoutSettings = class {
      constructor(parent) {
        this._defaultTimeout = null;
        this._defaultNavigationTimeout = null;
        this._parent = parent;
      }
      setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
      }
      setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
      }
      navigationTimeout(options2) {
        if (typeof options2.timeout === "number")
          return options2.timeout;
        if (this._defaultNavigationTimeout !== null)
          return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== null)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.navigationTimeout(options2);
        return TIMEOUT;
      }
      timeout(options2) {
        if (typeof options2.timeout === "number")
          return options2.timeout;
        if (this._defaultTimeout !== null)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.timeout(options2);
        return TIMEOUT;
      }
      static timeout(options2) {
        if (typeof options2.timeout === "number")
          return options2.timeout;
        return TIMEOUT;
      }
    };
    exports2.TimeoutSettings = TimeoutSettings;
  }
});

// node_modules/playwright/lib/utils/debugLogger.js
var require_debugLogger = __commonJS({
  "node_modules/playwright/lib/utils/debugLogger.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.RecentLogsCollector = exports2.debugLogger = void 0;
    var debug_1 = __importDefault(require_src());
    var fs_1 = __importDefault(require("fs"));
    var debugLoggerColorMap = {
      "api": 45,
      "protocol": 34,
      "browser": 0,
      "error": 160,
      "channel:command": 33,
      "channel:response": 202,
      "channel:event": 207
    };
    var DebugLogger = class {
      constructor() {
        this._debuggers = new Map();
        if (process.env.DEBUG_FILE) {
          const ansiRegex = new RegExp([
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
          ].join("|"), "g");
          const stream = fs_1.default.createWriteStream(process.env.DEBUG_FILE);
          debug_1.default.log = (data) => {
            stream.write(data.replace(ansiRegex, ""));
            stream.write("\n");
          };
        }
      }
      log(name, message) {
        let cachedDebugger = this._debuggers.get(name);
        if (!cachedDebugger) {
          cachedDebugger = debug_1.default(`pw:${name}`);
          this._debuggers.set(name, cachedDebugger);
          cachedDebugger.color = debugLoggerColorMap[name];
        }
        cachedDebugger(message);
      }
      isEnabled(name) {
        return debug_1.default.enabled(`pw:${name}`);
      }
    };
    exports2.debugLogger = new DebugLogger();
    var kLogCount = 50;
    var RecentLogsCollector = class {
      constructor() {
        this._logs = [];
      }
      log(message) {
        this._logs.push(message);
        if (this._logs.length === kLogCount * 2)
          this._logs.splice(0, kLogCount);
      }
      recentLogs() {
        if (this._logs.length > kLogCount)
          return this._logs.slice(-kLogCount);
        return this._logs;
      }
    };
    exports2.RecentLogsCollector = RecentLogsCollector;
  }
});

// node_modules/playwright/lib/server/helper.js
var require_helper = __commonJS({
  "node_modules/playwright/lib/server/helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.helper = void 0;
    var debugLogger_1 = require_debugLogger();
    var Helper = class {
      static addEventListener(emitter, eventName, handler2) {
        emitter.on(eventName, handler2);
        return {emitter, eventName, handler: handler2};
      }
      static removeEventListeners(listeners) {
        for (const listener of listeners)
          listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
      }
      static completeUserURL(urlString) {
        if (urlString.startsWith("localhost") || urlString.startsWith("127.0.0.1"))
          urlString = "http://" + urlString;
        return urlString;
      }
      static enclosingIntRect(rect) {
        const x = Math.floor(rect.x + 1e-3);
        const y = Math.floor(rect.y + 1e-3);
        const x2 = Math.ceil(rect.x + rect.width - 1e-3);
        const y2 = Math.ceil(rect.y + rect.height - 1e-3);
        return {x, y, width: x2 - x, height: y2 - y};
      }
      static enclosingIntSize(size) {
        return {width: Math.floor(size.width + 1e-3), height: Math.floor(size.height + 1e-3)};
      }
      static getViewportSizeFromWindowFeatures(features) {
        const widthString = features.find((f) => f.startsWith("width="));
        const heightString = features.find((f) => f.startsWith("height="));
        const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
        const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
        if (!Number.isNaN(width) && !Number.isNaN(height))
          return {width, height};
        return null;
      }
      static waitForEvent(progress, emitter, event, predicate) {
        const listeners = [];
        const promise = new Promise((resolve2, reject) => {
          listeners.push(exports2.helper.addEventListener(emitter, event, (eventArg) => {
            try {
              if (predicate && !predicate(eventArg))
                return;
              exports2.helper.removeEventListeners(listeners);
              resolve2(eventArg);
            } catch (e) {
              exports2.helper.removeEventListeners(listeners);
              reject(e);
            }
          }));
        });
        const dispose = () => exports2.helper.removeEventListeners(listeners);
        if (progress)
          progress.cleanupWhenAborted(dispose);
        return {promise, dispose};
      }
      static secondsToRoundishMillis(value) {
        return (value * 1e6 | 0) / 1e3;
      }
      static millisToRoundishMillis(value) {
        return (value * 1e3 | 0) / 1e3;
      }
      static debugProtocolLogger(protocolLogger) {
        return (direction, message) => {
          if (protocolLogger)
            protocolLogger(direction, message);
          if (debugLogger_1.debugLogger.isEnabled("protocol"))
            debugLogger_1.debugLogger.log("protocol", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message));
        };
      }
      static formatBrowserLogs(logs) {
        if (!logs.length)
          return "";
        return "\n" + "=".repeat(20) + " Browser output: " + "=".repeat(20) + "\n" + logs.join("\n");
      }
    };
    exports2.helper = Helper;
  }
});

// node_modules/playwright/lib/server/network.js
var require_network = __commonJS({
  "node_modules/playwright/lib/server/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.mergeHeaders = exports2.singleHeader = exports2.STATUS_TEXTS = exports2.WebSocket = exports2.Response = exports2.Route = exports2.Request = exports2.stripFragmentFromUrl = exports2.parsedURL = exports2.rewriteCookies = exports2.filterCookies = void 0;
    var utils_1 = require_utils();
    var instrumentation_1 = require_instrumentation();
    function filterCookies(cookies, urls) {
      const parsedURLs = urls.map((s2) => new URL(s2));
      return cookies.filter((c) => {
        if (!c.value)
          return false;
        if (!parsedURLs.length)
          return true;
        for (const parsedURL2 of parsedURLs) {
          let domain = c.domain;
          if (!domain.startsWith("."))
            domain = "." + domain;
          if (!("." + parsedURL2.hostname).endsWith(domain))
            continue;
          if (!parsedURL2.pathname.startsWith(c.path))
            continue;
          if (parsedURL2.protocol !== "https:" && c.secure)
            continue;
          return true;
        }
        return false;
      });
    }
    exports2.filterCookies = filterCookies;
    function rewriteCookies(cookies) {
      return cookies.map((c) => {
        utils_1.assert(c.name, "Cookie should have a name");
        utils_1.assert(c.value, "Cookie should have a value");
        utils_1.assert(c.url || c.domain && c.path, "Cookie should have a url or a domain/path pair");
        utils_1.assert(!(c.url && c.domain), "Cookie should have either url or domain");
        utils_1.assert(!(c.url && c.path), "Cookie should have either url or domain");
        const copy = {...c};
        if (copy.url) {
          utils_1.assert(copy.url !== "about:blank", `Blank page can not have cookie "${c.name}"`);
          utils_1.assert(!copy.url.startsWith("data:"), `Data URL page can not have cookie "${c.name}"`);
          const url = new URL(copy.url);
          copy.domain = url.hostname;
          copy.path = url.pathname.substring(0, url.pathname.lastIndexOf("/") + 1);
          copy.secure = url.protocol === "https:";
        }
        return copy;
      });
    }
    exports2.rewriteCookies = rewriteCookies;
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    exports2.parsedURL = parsedURL;
    function stripFragmentFromUrl(url) {
      if (!url.includes("#"))
        return url;
      return url.substring(0, url.indexOf("#"));
    }
    exports2.stripFragmentFromUrl = stripFragmentFromUrl;
    var Request2 = class extends instrumentation_1.SdkObject {
      constructor(routeDelegate, frame, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
        super(frame, "request");
        this._response = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._headersMap = new Map();
        this._waitForResponsePromiseCallback = () => {
        };
        this._responseEndTiming = -1;
        utils_1.assert(!url.startsWith("data:"), "Data urls should not fire requests");
        utils_1.assert(!(routeDelegate && redirectedFrom), "Should not be able to intercept redirects");
        this._routeDelegate = routeDelegate;
        this._frame = frame;
        this._redirectedFrom = redirectedFrom;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        for (const {name, value} of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._waitForResponsePromise = new Promise((f) => this._waitForResponsePromiseCallback = f);
        this._isFavicon = url.endsWith("/favicon.ico");
      }
      _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForResponsePromiseCallback(null);
      }
      url() {
        return this._url;
      }
      resourceType() {
        return this._resourceType;
      }
      method() {
        return this._method;
      }
      postDataBuffer() {
        return this._postData;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      response() {
        return this._waitForResponsePromise;
      }
      _existingResponse() {
        return this._response;
      }
      _setResponse(response) {
        this._response = response;
        this._waitForResponsePromiseCallback(response);
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
      frame() {
        return this._frame;
      }
      isNavigationRequest() {
        return !!this._documentId;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      _route() {
        if (!this._routeDelegate)
          return null;
        return new Route(this, this._routeDelegate);
      }
      updateWithRawHeaders(headers) {
        this._headers = headers;
        this._headersMap.clear();
        for (const {name, value} of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        if (!this._headersMap.has("host")) {
          const host = new URL(this._url).host;
          this._headers.push({name: "host", value: host});
          this._headersMap.set("host", host);
        }
      }
    };
    exports2.Request = Request2;
    var Route = class extends instrumentation_1.SdkObject {
      constructor(request, delegate) {
        super(request.frame(), "route");
        this._handled = false;
        this._request = request;
        this._delegate = delegate;
      }
      request() {
        return this._request;
      }
      async abort(errorCode = "failed") {
        utils_1.assert(!this._handled, "Route is already handled!");
        this._handled = true;
        await this._delegate.abort(errorCode);
      }
      async fulfill(response) {
        utils_1.assert(!this._handled, "Route is already handled!");
        this._handled = true;
        await this._delegate.fulfill({
          status: response.status === void 0 ? 200 : response.status,
          headers: response.headers || [],
          body: response.body || "",
          isBase64: response.isBase64 || false
        });
      }
      async continue(overrides = {}) {
        utils_1.assert(!this._handled, "Route is already handled!");
        if (overrides.url) {
          const newUrl = new URL(overrides.url);
          const oldUrl = new URL(this._request.url());
          if (oldUrl.protocol !== newUrl.protocol)
            throw new Error("New URL must have same protocol as overridden URL");
        }
        await this._delegate.continue(overrides);
      }
    };
    exports2.Route = Route;
    var Response3 = class extends instrumentation_1.SdkObject {
      constructor(request, status, statusText, headers, timing, getResponseBodyCallback) {
        super(request.frame(), "response");
        this._contentPromise = null;
        this._finishedPromiseCallback = () => {
        };
        this._headersMap = new Map();
        this._request = request;
        this._timing = timing;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        for (const {name, value} of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._finishedPromise = new Promise((f) => {
          this._finishedPromiseCallback = f;
        });
        this._request._setResponse(this);
      }
      _requestFinished(responseEndTiming, error3) {
        this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
        this._finishedPromiseCallback({error: error3});
      }
      url() {
        return this._url;
      }
      status() {
        return this._status;
      }
      statusText() {
        return this._statusText;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      finished() {
        return this._finishedPromise.then(({error: error3}) => error3 ? new Error(error3) : null);
      }
      timing() {
        return this._timing;
      }
      body() {
        if (!this._contentPromise) {
          this._contentPromise = this._finishedPromise.then(async ({error: error3}) => {
            if (error3)
              throw new Error(error3);
            return this._getResponseBodyCallback();
          });
        }
        return this._contentPromise;
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
    };
    exports2.Response = Response3;
    var WebSocket = class extends instrumentation_1.SdkObject {
      constructor(parent, url) {
        super(parent, "ws");
        this._url = url;
      }
      url() {
        return this._url;
      }
      frameSent(opcode, data) {
        this.emit(WebSocket.Events.FrameSent, {opcode, data});
      }
      frameReceived(opcode, data) {
        this.emit(WebSocket.Events.FrameReceived, {opcode, data});
      }
      error(errorMessage) {
        this.emit(WebSocket.Events.SocketError, errorMessage);
      }
      closed() {
        this.emit(WebSocket.Events.Close);
      }
    };
    exports2.WebSocket = WebSocket;
    WebSocket.Events = {
      Close: "close",
      SocketError: "socketerror",
      FrameReceived: "framereceived",
      FrameSent: "framesent"
    };
    exports2.STATUS_TEXTS = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "Switch Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    function singleHeader(name, value) {
      return [{name, value}];
    }
    exports2.singleHeader = singleHeader;
    function mergeHeaders(headers) {
      const lowerCaseToValue = new Map();
      const lowerCaseToOriginalCase = new Map();
      for (const h of headers) {
        if (!h)
          continue;
        for (const {name, value} of h) {
          const lower = name.toLowerCase();
          lowerCaseToOriginalCase.set(lower, name);
          lowerCaseToValue.set(lower, value);
        }
      }
      const result = [];
      for (const [lower, value] of lowerCaseToValue)
        result.push({name: lowerCaseToOriginalCase.get(lower), value});
      return result;
    }
    exports2.mergeHeaders = mergeHeaders;
  }
});

// node_modules/playwright/lib/generated/injectedScriptSource.js
var require_injectedScriptSource = __commonJS({
  "node_modules/playwright/lib/generated/injectedScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.source = void 0;
    exports2.source = `var pwExport =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/injected/injectedScript.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\\
  !*** (webpack)/buildin/global.js ***!
  \\***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/server/common/cssParser.ts":
/*!****************************************!*\\
  !*** ./src/server/common/cssParser.ts ***!
  \\****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeSelector = exports.parseCSS = void 0;
const css = __importStar(__webpack_require__(/*! ./cssTokenizer */ "./src/server/common/cssTokenizer.js"));
function parseCSS(selector, customNames) {
    let tokens;
    try {
        tokens = css.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))
            tokens.push(new css.EOFToken());
    }
    catch (e) {
        const newMessage = e.message + \` while parsing selector "\${selector}"\`;
        const index = (e.stack || '').indexOf(e.message);
        if (index !== -1)
            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
    }
    const unsupportedToken = tokens.find(token => {
        return (token instanceof css.AtKeywordToken) ||
            (token instanceof css.BadStringToken) ||
            (token instanceof css.BadURLToken) ||
            (token instanceof css.ColumnToken) ||
            (token instanceof css.CDOToken) ||
            (token instanceof css.CDCToken) ||
            (token instanceof css.SemicolonToken) ||
            // TODO: Consider using these for something, e.g. to escape complex strings.
            // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }
            // Or this way :xpath( {complex-xpath-goes-here("hello")} )
            (token instanceof css.OpenCurlyToken) ||
            (token instanceof css.CloseCurlyToken) ||
            // TODO: Consider treating these as strings?
            (token instanceof css.URLToken) ||
            (token instanceof css.PercentageToken);
    });
    if (unsupportedToken)
        throw new Error(\`Unsupported token "\${unsupportedToken.toSource()}" while parsing selector "\${selector}"\`);
    let pos = 0;
    const names = new Set();
    function unexpected() {
        return new Error(\`Unexpected token "\${tokens[pos].toSource()}" while parsing selector "\${selector}"\`);
    }
    function skipWhitespace() {
        while (tokens[pos] instanceof css.WhitespaceToken)
            pos++;
    }
    function isIdent(p = pos) {
        return tokens[p] instanceof css.IdentToken;
    }
    function isString(p = pos) {
        return tokens[p] instanceof css.StringToken;
    }
    function isNumber(p = pos) {
        return tokens[p] instanceof css.NumberToken;
    }
    function isComma(p = pos) {
        return tokens[p] instanceof css.CommaToken;
    }
    function isCloseParen(p = pos) {
        return tokens[p] instanceof css.CloseParenToken;
    }
    function isStar(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';
    }
    function isEOF(p = pos) {
        return tokens[p] instanceof css.EOFToken;
    }
    function isClauseCombinator(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));
    }
    function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);
    }
    function consumeFunctionArguments() {
        const result = [consumeArgument()];
        while (true) {
            skipWhitespace();
            if (!isComma())
                break;
            pos++;
            result.push(consumeArgument());
        }
        return result;
    }
    function consumeArgument() {
        skipWhitespace();
        if (isNumber())
            return tokens[pos++].value;
        if (isString())
            return tokens[pos++].value;
        return consumeComplexSelector();
    }
    function consumeComplexSelector() {
        skipWhitespace();
        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };
        while (true) {
            skipWhitespace();
            if (isClauseCombinator()) {
                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;
                skipWhitespace();
            }
            else if (isSelectorClauseEnd()) {
                break;
            }
            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });
        }
        return result;
    }
    function consumeSimpleSelector() {
        let rawCSSString = '';
        const functions = [];
        while (!isSelectorClauseEnd()) {
            if (isIdent() || isStar()) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if (tokens[pos] instanceof css.HashToken) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {
                pos++;
                if (isIdent())
                    rawCSSString += '.' + tokens[pos++].toSource();
                else
                    throw unexpected();
            }
            else if (tokens[pos] instanceof css.ColonToken) {
                pos++;
                if (isIdent()) {
                    if (!customNames.has(tokens[pos].value.toLowerCase())) {
                        rawCSSString += ':' + tokens[pos++].toSource();
                    }
                    else {
                        const name = tokens[pos++].value.toLowerCase();
                        functions.push({ name, args: [] });
                        names.add(name);
                    }
                }
                else if (tokens[pos] instanceof css.FunctionToken) {
                    const name = tokens[pos++].value.toLowerCase();
                    if (!customNames.has(name)) {
                        rawCSSString += \`:\${name}(\${consumeBuiltinFunctionArguments()})\`;
                    }
                    else {
                        functions.push({ name, args: consumeFunctionArguments() });
                        names.add(name);
                    }
                    skipWhitespace();
                    if (!isCloseParen())
                        throw unexpected();
                    pos++;
                }
                else {
                    throw unexpected();
                }
            }
            else if (tokens[pos] instanceof css.OpenSquareToken) {
                rawCSSString += '[';
                pos++;
                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())
                    rawCSSString += tokens[pos++].toSource();
                if (!(tokens[pos] instanceof css.CloseSquareToken))
                    throw unexpected();
                rawCSSString += ']';
                pos++;
            }
            else {
                throw unexpected();
            }
        }
        if (!rawCSSString && !functions.length)
            throw unexpected();
        return { css: rawCSSString || undefined, functions };
    }
    function consumeBuiltinFunctionArguments() {
        let s = '';
        while (!isCloseParen() && !isEOF())
            s += tokens[pos++].toSource();
        return s;
    }
    const result = consumeFunctionArguments();
    if (!isEOF())
        throw new Error(\`Error while parsing selector "\${selector}"\`);
    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))
        throw new Error(\`Error while parsing selector "\${selector}"\`);
    return { selector: result, names: Array.from(names) };
}
exports.parseCSS = parseCSS;
function serializeSelector(args) {
    return args.map(arg => {
        if (typeof arg === 'string')
            return \`"\${arg}"\`;
        if (typeof arg === 'number')
            return String(arg);
        return arg.simples.map(({ selector, combinator }) => {
            let s = selector.css || '';
            s = s + selector.functions.map(func => \`:\${func.name}(\${serializeSelector(func.args)})\`).join('');
            if (combinator)
                s += ' ' + combinator;
            return s;
        }).join(' ');
    }).join(', ');
}
exports.serializeSelector = serializeSelector;


/***/ }),

/***/ "./src/server/common/cssTokenizer.js":
/*!*******************************************!*\\
  !*** ./src/server/common/cssTokenizer.js ***!
  \\*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
/*
 * Original at https://github.com/tabatkins/parse-css
 * licensed under http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Changes from https://github.com/tabatkins/parse-css
//   - Tabs are replaced with two spaces.
//   - Everything not related to tokenizing - below the first exports block - is removed.
// @ts-nocheck
(function (root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else {}
}(this, function (exports) {
    var between = function (num, first, last) { return num >= first && num <= last; };
    function digit(code) { return between(code, 0x30, 0x39); }
    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }
    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }
    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }
    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
    function nonascii(code) { return code >= 0x80; }
    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }
    function newline(code) { return code == 0xa; }
    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
    function badescape(code) { return newline(code) || isNaN(code); }
    var maximumallowedcodepoint = 0x10ffff;
    var InvalidCharacterError = function (message) {
        this.message = message;
    };
    InvalidCharacterError.prototype = new Error;
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';
    function preprocess(str) {
        // Turn a string into an array of code points,
        // following the preprocessing cleanup rules.
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {
                code = 0xa;
                i++;
            }
            if (code == 0xd || code == 0xc)
                code = 0xa;
            if (code == 0x0)
                code = 0xfffd;
            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {
                // Decode a surrogate pair into an astral codepoint.
                var lead = code - 0xd800;
                var trail = str.charCodeAt(i + 1) - 0xdc00;
                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
                i++;
            }
            codepoints.push(code);
        }
        return codepoints;
    }
    function stringFromCode(code) {
        if (code <= 0xffff)
            return String.fromCharCode(code);
        // Otherwise, encode astral char as surrogate pair.
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;
        var trail = code % Math.pow(2, 10) + 0xdc00;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
    }
    function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        // Line number information.
        var line = 0;
        var column = 0;
        // The only use of lastLineLength is in reconsume().
        var lastLineLength = 0;
        var incrLineno = function () {
            line += 1;
            lastLineLength = column;
            column = 0;
        };
        var locStart = { line: line, column: column };
        var codepoint = function (i) {
            if (i >= str.length) {
                return -1;
            }
            return str[i];
        };
        var next = function (num) {
            if (num === undefined)
                num = 1;
            if (num > 3)
                throw "Spec Error: no more than three codepoints of lookahead.";
            return codepoint(i + num);
        };
        var consume = function (num) {
            if (num === undefined)
                num = 1;
            i += num;
            code = codepoint(i);
            if (newline(code))
                incrLineno();
            else
                column += num;
            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
            return true;
        };
        var reconsume = function () {
            i -= 1;
            if (newline(code)) {
                line -= 1;
                column = lastLineLength;
            }
            else {
                column -= 1;
            }
            locStart.line = line;
            locStart.column = column;
            return true;
        };
        var eof = function (codepoint) {
            if (codepoint === undefined)
                codepoint = code;
            return codepoint == -1;
        };
        var donothing = function () { };
        var parseerror = function () { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + "."); return true; };
        var consumeAToken = function () {
            consumeComments();
            consume();
            if (whitespace(code)) {
                while (whitespace(next()))
                    consume();
                return new WhitespaceToken;
            }
            else if (code == 0x22)
                return consumeAStringToken();
            else if (code == 0x23) {
                if (namechar(next()) || areAValidEscape(next(1), next(2))) {
                    var token = new HashToken();
                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                        token.type = "id";
                    token.value = consumeAName();
                    return token;
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x24) {
                if (next() == 0x3d) {
                    consume();
                    return new SuffixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x27)
                return consumeAStringToken();
            else if (code == 0x28)
                return new OpenParenToken();
            else if (code == 0x29)
                return new CloseParenToken();
            else if (code == 0x2a) {
                if (next() == 0x3d) {
                    consume();
                    return new SubstringMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2b) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2c)
                return new CommaToken();
            else if (code == 0x2d) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else if (next(1) == 0x2d && next(2) == 0x3e) {
                    consume(2);
                    return new CDCToken();
                }
                else if (startsWithAnIdentifier()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2e) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x3a)
                return new ColonToken;
            else if (code == 0x3b)
                return new SemicolonToken;
            else if (code == 0x3c) {
                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
                    consume(3);
                    return new CDOToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x40) {
                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                    return new AtKeywordToken(consumeAName());
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5b)
                return new OpenSquareToken();
            else if (code == 0x5c) {
                if (startsWithAValidEscape()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    parseerror();
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5d)
                return new CloseSquareToken();
            else if (code == 0x5e) {
                if (next() == 0x3d) {
                    consume();
                    return new PrefixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7b)
                return new OpenCurlyToken();
            else if (code == 0x7c) {
                if (next() == 0x3d) {
                    consume();
                    return new DashMatchToken();
                }
                else if (next() == 0x7c) {
                    consume();
                    return new ColumnToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7d)
                return new CloseCurlyToken();
            else if (code == 0x7e) {
                if (next() == 0x3d) {
                    consume();
                    return new IncludeMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (digit(code)) {
                reconsume();
                return consumeANumericToken();
            }
            else if (namestartchar(code)) {
                reconsume();
                return consumeAnIdentlikeToken();
            }
            else if (eof())
                return new EOFToken();
            else
                return new DelimToken(code);
        };
        var consumeComments = function () {
            while (next(1) == 0x2f && next(2) == 0x2a) {
                consume(2);
                while (true) {
                    consume();
                    if (code == 0x2a && next() == 0x2f) {
                        consume();
                        break;
                    }
                    else if (eof()) {
                        parseerror();
                        return;
                    }
                }
            }
        };
        var consumeANumericToken = function () {
            var num = consumeANumber();
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                var token = new DimensionToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                token.unit = consumeAName();
                return token;
            }
            else if (next() == 0x25) {
                consume();
                var token = new PercentageToken();
                token.value = num.value;
                token.repr = num.repr;
                return token;
            }
            else {
                var token = new NumberToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                return token;
            }
        };
        var consumeAnIdentlikeToken = function () {
            var str = consumeAName();
            if (str.toLowerCase() == "url" && next() == 0x28) {
                consume();
                while (whitespace(next(1)) && whitespace(next(2)))
                    consume();
                if (next() == 0x22 || next() == 0x27) {
                    return new FunctionToken(str);
                }
                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
                    return new FunctionToken(str);
                }
                else {
                    return consumeAURLToken();
                }
            }
            else if (next() == 0x28) {
                consume();
                return new FunctionToken(str);
            }
            else {
                return new IdentToken(str);
            }
        };
        var consumeAStringToken = function (endingCodePoint) {
            if (endingCodePoint === undefined)
                endingCodePoint = code;
            var string = "";
            while (consume()) {
                if (code == endingCodePoint || eof()) {
                    return new StringToken(string);
                }
                else if (newline(code)) {
                    parseerror();
                    reconsume();
                    return new BadStringToken();
                }
                else if (code == 0x5c) {
                    if (eof(next())) {
                        donothing();
                    }
                    else if (newline(next())) {
                        consume();
                    }
                    else {
                        string += stringFromCode(consumeEscape());
                    }
                }
                else {
                    string += stringFromCode(code);
                }
            }
        };
        var consumeAURLToken = function () {
            var token = new URLToken("");
            while (whitespace(next()))
                consume();
            if (eof(next()))
                return token;
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return token;
                }
                else if (whitespace(code)) {
                    while (whitespace(next()))
                        consume();
                    if (next() == 0x29 || eof(next())) {
                        consume();
                        return token;
                    }
                    else {
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
                    parseerror();
                    consumeTheRemnantsOfABadURL();
                    return new BadURLToken();
                }
                else if (code == 0x5c) {
                    if (startsWithAValidEscape()) {
                        token.value += stringFromCode(consumeEscape());
                    }
                    else {
                        parseerror();
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else {
                    token.value += stringFromCode(code);
                }
            }
        };
        var consumeEscape = function () {
            // Assume the the current character is the \\
            // and the next code point is not a newline.
            consume();
            if (hexdigit(code)) {
                // Consume 1-6 hex digits
                var digits = [code];
                for (var total = 0; total < 5; total++) {
                    if (hexdigit(next())) {
                        consume();
                        digits.push(code);
                    }
                    else {
                        break;
                    }
                }
                if (whitespace(next()))
                    consume();
                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);
                if (value > maximumallowedcodepoint)
                    value = 0xfffd;
                return value;
            }
            else if (eof()) {
                return 0xfffd;
            }
            else {
                return code;
            }
        };
        var areAValidEscape = function (c1, c2) {
            if (c1 != 0x5c)
                return false;
            if (newline(c2))
                return false;
            return true;
        };
        var startsWithAValidEscape = function () {
            return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function (c1, c2, c3) {
            if (c1 == 0x2d) {
                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
            }
            else if (namestartchar(c1)) {
                return true;
            }
            else if (c1 == 0x5c) {
                return areAValidEscape(c1, c2);
            }
            else {
                return false;
            }
        };
        var startsWithAnIdentifier = function () {
            return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function (c1, c2, c3) {
            if (c1 == 0x2b || c1 == 0x2d) {
                if (digit(c2))
                    return true;
                if (c2 == 0x2e && digit(c3))
                    return true;
                return false;
            }
            else if (c1 == 0x2e) {
                if (digit(c2))
                    return true;
                return false;
            }
            else if (digit(c1)) {
                return true;
            }
            else {
                return false;
            }
        };
        var startsWithANumber = function () {
            return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function () {
            var result = "";
            while (consume()) {
                if (namechar(code)) {
                    result += stringFromCode(code);
                }
                else if (startsWithAValidEscape()) {
                    result += stringFromCode(consumeEscape());
                }
                else {
                    reconsume();
                    return result;
                }
            }
        };
        var consumeANumber = function () {
            var repr = [];
            var type = "integer";
            if (next() == 0x2b || next() == 0x2d) {
                consume();
                repr += stringFromCode(code);
            }
            while (digit(next())) {
                consume();
                repr += stringFromCode(code);
            }
            if (next(1) == 0x2e && digit(next(2))) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var c1 = next(1), c2 = next(2), c3 = next(3);
            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var value = convertAStringToANumber(repr);
            return { type: type, value: value, repr: repr };
        };
        var convertAStringToANumber = function (string) {
            // CSS's number rules are identical to JS, afaik.
            return +string;
        };
        var consumeTheRemnantsOfABadURL = function () {
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return;
                }
                else if (startsWithAValidEscape()) {
                    consumeEscape();
                    donothing();
                }
                else {
                    donothing();
                }
            }
        };
        var iterationCount = 0;
        while (!eof(next())) {
            tokens.push(consumeAToken());
            iterationCount++;
            if (iterationCount > str.length * 2)
                return "I'm infinite-looping!";
        }
        return tokens;
    }
    function CSSParserToken() { throw "Abstract Base Class"; }
    CSSParserToken.prototype.toJSON = function () {
        return { token: this.tokenType };
    };
    CSSParserToken.prototype.toString = function () { return this.tokenType; };
    CSSParserToken.prototype.toSource = function () { return '' + this; };
    function BadStringToken() { return this; }
    BadStringToken.prototype = Object.create(CSSParserToken.prototype);
    BadStringToken.prototype.tokenType = "BADSTRING";
    function BadURLToken() { return this; }
    BadURLToken.prototype = Object.create(CSSParserToken.prototype);
    BadURLToken.prototype.tokenType = "BADURL";
    function WhitespaceToken() { return this; }
    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
    WhitespaceToken.prototype.tokenType = "WHITESPACE";
    WhitespaceToken.prototype.toString = function () { return "WS"; };
    WhitespaceToken.prototype.toSource = function () { return " "; };
    function CDOToken() { return this; }
    CDOToken.prototype = Object.create(CSSParserToken.prototype);
    CDOToken.prototype.tokenType = "CDO";
    CDOToken.prototype.toSource = function () { return "<!--"; };
    function CDCToken() { return this; }
    CDCToken.prototype = Object.create(CSSParserToken.prototype);
    CDCToken.prototype.tokenType = "CDC";
    CDCToken.prototype.toSource = function () { return "-->"; };
    function ColonToken() { return this; }
    ColonToken.prototype = Object.create(CSSParserToken.prototype);
    ColonToken.prototype.tokenType = ":";
    function SemicolonToken() { return this; }
    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
    SemicolonToken.prototype.tokenType = ";";
    function CommaToken() { return this; }
    CommaToken.prototype = Object.create(CSSParserToken.prototype);
    CommaToken.prototype.tokenType = ",";
    function GroupingToken() { throw "Abstract Base Class"; }
    GroupingToken.prototype = Object.create(CSSParserToken.prototype);
    function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
    OpenCurlyToken.prototype.tokenType = "{";
    function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
    CloseCurlyToken.prototype.tokenType = "}";
    function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
    OpenSquareToken.prototype.tokenType = "[";
    function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
    CloseSquareToken.prototype.tokenType = "]";
    function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
    OpenParenToken.prototype = Object.create(GroupingToken.prototype);
    OpenParenToken.prototype.tokenType = "(";
    function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
    CloseParenToken.prototype = Object.create(GroupingToken.prototype);
    CloseParenToken.prototype.tokenType = ")";
    function IncludeMatchToken() { return this; }
    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
    IncludeMatchToken.prototype.tokenType = "~=";
    function DashMatchToken() { return this; }
    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
    DashMatchToken.prototype.tokenType = "|=";
    function PrefixMatchToken() { return this; }
    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    PrefixMatchToken.prototype.tokenType = "^=";
    function SuffixMatchToken() { return this; }
    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SuffixMatchToken.prototype.tokenType = "$=";
    function SubstringMatchToken() { return this; }
    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SubstringMatchToken.prototype.tokenType = "*=";
    function ColumnToken() { return this; }
    ColumnToken.prototype = Object.create(CSSParserToken.prototype);
    ColumnToken.prototype.tokenType = "||";
    function EOFToken() { return this; }
    EOFToken.prototype = Object.create(CSSParserToken.prototype);
    EOFToken.prototype.tokenType = "EOF";
    EOFToken.prototype.toSource = function () { return ""; };
    function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
    }
    DelimToken.prototype = Object.create(CSSParserToken.prototype);
    DelimToken.prototype.tokenType = "DELIM";
    DelimToken.prototype.toString = function () { return "DELIM(" + this.value + ")"; };
    DelimToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    DelimToken.prototype.toSource = function () {
        if (this.value == "\\\\")
            return "\\\\\\n";
        else
            return this.value;
    };
    function StringValuedToken() { throw "Abstract Base Class"; }
    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
    StringValuedToken.prototype.ASCIIMatch = function (str) {
        return this.value.toLowerCase() == str.toLowerCase();
    };
    StringValuedToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    function IdentToken(val) {
        this.value = val;
    }
    IdentToken.prototype = Object.create(StringValuedToken.prototype);
    IdentToken.prototype.tokenType = "IDENT";
    IdentToken.prototype.toString = function () { return "IDENT(" + this.value + ")"; };
    IdentToken.prototype.toSource = function () {
        return escapeIdent(this.value);
    };
    function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
    }
    FunctionToken.prototype = Object.create(StringValuedToken.prototype);
    FunctionToken.prototype.tokenType = "FUNCTION";
    FunctionToken.prototype.toString = function () { return "FUNCTION(" + this.value + ")"; };
    FunctionToken.prototype.toSource = function () {
        return escapeIdent(this.value) + "(";
    };
    function AtKeywordToken(val) {
        this.value = val;
    }
    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
    AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
    AtKeywordToken.prototype.toString = function () { return "AT(" + this.value + ")"; };
    AtKeywordToken.prototype.toSource = function () {
        return "@" + escapeIdent(this.value);
    };
    function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
    }
    HashToken.prototype = Object.create(StringValuedToken.prototype);
    HashToken.prototype.tokenType = "HASH";
    HashToken.prototype.toString = function () { return "HASH(" + this.value + ")"; };
    HashToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
    };
    HashToken.prototype.toSource = function () {
        if (this.type == "id") {
            return "#" + escapeIdent(this.value);
        }
        else {
            return "#" + escapeHash(this.value);
        }
    };
    function StringToken(val) {
        this.value = val;
    }
    StringToken.prototype = Object.create(StringValuedToken.prototype);
    StringToken.prototype.tokenType = "STRING";
    StringToken.prototype.toString = function () {
        return '"' + escapeString(this.value) + '"';
    };
    function URLToken(val) {
        this.value = val;
    }
    URLToken.prototype = Object.create(StringValuedToken.prototype);
    URLToken.prototype.tokenType = "URL";
    URLToken.prototype.toString = function () { return "URL(" + this.value + ")"; };
    URLToken.prototype.toSource = function () {
        return 'url("' + escapeString(this.value) + '")';
    };
    function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
    }
    NumberToken.prototype = Object.create(CSSParserToken.prototype);
    NumberToken.prototype.tokenType = "NUMBER";
    NumberToken.prototype.toString = function () {
        if (this.type == "integer")
            return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
    };
    NumberToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
    };
    NumberToken.prototype.toSource = function () { return this.repr; };
    function PercentageToken() {
        this.value = null;
        this.repr = "";
    }
    PercentageToken.prototype = Object.create(CSSParserToken.prototype);
    PercentageToken.prototype.tokenType = "PERCENTAGE";
    PercentageToken.prototype.toString = function () { return "PERCENTAGE(" + this.value + ")"; };
    PercentageToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
    };
    PercentageToken.prototype.toSource = function () { return this.repr + "%"; };
    function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
    }
    DimensionToken.prototype = Object.create(CSSParserToken.prototype);
    DimensionToken.prototype.tokenType = "DIMENSION";
    DimensionToken.prototype.toString = function () { return "DIM(" + this.value + "," + this.unit + ")"; };
    DimensionToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
    };
    DimensionToken.prototype.toSource = function () {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
            // Unit is ambiguous with scinot
            // Remove the leading "e", replace with escape.
            unit = "\\\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
    };
    function escapeIdent(string) {
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f ||
                (i == 0 && between(code, 0x30, 0x39)) ||
                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {
                result += '\\\\' + code.toString(16) + ' ';
            }
            else if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\\\' + string[i];
            }
        }
        return result;
    }
    function escapeHash(string) {
        // Escapes the contents of "unrestricted"-type hash tokens.
        // Won't preserve the ID-ness of "id"-type hash tokens;
        // use escapeIdent() for that.
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\\\' + code.toString(16) + ' ';
            }
        }
        return result;
    }
    function escapeString(string) {
        string = '' + string;
        var result = '';
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f) {
                result += '\\\\' + code.toString(16) + ' ';
            }
            else if (code == 0x22 || code == 0x5c) {
                result += '\\\\' + string[i];
            }
            else {
                result += string[i];
            }
        }
        return result;
    }
    // Exportation.
    exports.tokenize = tokenize;
    exports.IdentToken = IdentToken;
    exports.FunctionToken = FunctionToken;
    exports.AtKeywordToken = AtKeywordToken;
    exports.HashToken = HashToken;
    exports.StringToken = StringToken;
    exports.BadStringToken = BadStringToken;
    exports.URLToken = URLToken;
    exports.BadURLToken = BadURLToken;
    exports.DelimToken = DelimToken;
    exports.NumberToken = NumberToken;
    exports.PercentageToken = PercentageToken;
    exports.DimensionToken = DimensionToken;
    exports.IncludeMatchToken = IncludeMatchToken;
    exports.DashMatchToken = DashMatchToken;
    exports.PrefixMatchToken = PrefixMatchToken;
    exports.SuffixMatchToken = SuffixMatchToken;
    exports.SubstringMatchToken = SubstringMatchToken;
    exports.ColumnToken = ColumnToken;
    exports.WhitespaceToken = WhitespaceToken;
    exports.CDOToken = CDOToken;
    exports.CDCToken = CDCToken;
    exports.ColonToken = ColonToken;
    exports.SemicolonToken = SemicolonToken;
    exports.CommaToken = CommaToken;
    exports.OpenParenToken = OpenParenToken;
    exports.CloseParenToken = CloseParenToken;
    exports.OpenSquareToken = OpenSquareToken;
    exports.CloseSquareToken = CloseSquareToken;
    exports.OpenCurlyToken = OpenCurlyToken;
    exports.CloseCurlyToken = CloseCurlyToken;
    exports.EOFToken = EOFToken;
    exports.CSSParserToken = CSSParserToken;
    exports.GroupingToken = GroupingToken;
}));


/***/ }),

/***/ "./src/server/common/selectorParser.ts":
/*!*********************************************!*\\
  !*** ./src/server/common/selectorParser.ts ***!
  \\*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSelector = exports.customCSSNames = void 0;
const cssParser_1 = __webpack_require__(/*! ./cssParser */ "./src/server/common/cssParser.ts");
exports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);
function parseSelector(selector) {
    const result = parseSelectorV1(selector);
    result.parts = result.parts.map(part => {
        if (Array.isArray(part))
            return part;
        if (part.name === 'css' || part.name === 'css:light') {
            if (part.name === 'css:light')
                part.body = ':light(' + part.body + ')';
            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);
            return parsedCSS.selector;
        }
        return part;
    });
    return {
        parts: result.parts,
        capture: result.capture,
    };
}
exports.parseSelector = parseSelector;
function parseSelectorV1(selector) {
    let index = 0;
    let quote;
    let start = 0;
    const result = { parts: [] };
    const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf('=');
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
            name = part.substring(0, eqIndex).trim();
            body = part.substring(eqIndex + 1);
        }
        else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
            name = 'text';
            body = part;
        }
        else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
            name = 'text';
            body = part;
        }
        else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {
            // If selector starts with '//' or '//' prefixed with multiple opening
            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
            // If selector starts with '..', consider xpath as well.
            name = 'xpath';
            body = part;
        }
        else {
            name = 'css';
            body = part;
        }
        let capture = false;
        if (name[0] === '*') {
            capture = true;
            name = name.substring(1);
        }
        result.parts.push({ name, body });
        if (capture) {
            if (result.capture !== undefined)
                throw new Error(\`Only one of the selectors can capture using * modifier\`);
            result.capture = result.parts.length - 1;
        }
    };
    if (!selector.includes('>>')) {
        index = selector.length;
        append();
        return result;
    }
    while (index < selector.length) {
        const c = selector[index];
        if (c === '\\\\' && index + 1 < selector.length) {
            index += 2;
        }
        else if (c === quote) {
            quote = undefined;
            index++;
        }
        else if (!quote && (c === '"' || c === '\\'' || c === '\`')) {
            quote = c;
            index++;
        }
        else if (!quote && c === '>' && selector[index + 1] === '>') {
            append();
            index += 2;
            start = index;
        }
        else {
            index++;
        }
    }
    append();
    return result;
}


/***/ }),

/***/ "./src/server/injected/injectedScript.ts":
/*!***********************************************!*\\
  !*** ./src/server/injected/injectedScript.ts ***!
  \\***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectedScript = void 0;
const xpathSelectorEngine_1 = __webpack_require__(/*! ./xpathSelectorEngine */ "./src/server/injected/xpathSelectorEngine.ts");
const selectorParser_1 = __webpack_require__(/*! ../common/selectorParser */ "./src/server/common/selectorParser.ts");
const selectorEvaluator_1 = __webpack_require__(/*! ./selectorEvaluator */ "./src/server/injected/selectorEvaluator.ts");
class InjectedScript {
    constructor(stableRafCount, replaceRafWithTimeout, customEngines) {
        this._enginesV1 = new Map();
        this._enginesV1.set('xpath', xpathSelectorEngine_1.XPathEngine);
        this._enginesV1.set('xpath:light', xpathSelectorEngine_1.XPathEngine);
        this._enginesV1.set('text', this._createTextEngine(true));
        this._enginesV1.set('text:light', this._createTextEngine(false));
        this._enginesV1.set('id', this._createAttributeEngine('id', true));
        this._enginesV1.set('id:light', this._createAttributeEngine('id', false));
        this._enginesV1.set('data-testid', this._createAttributeEngine('data-testid', true));
        this._enginesV1.set('data-testid:light', this._createAttributeEngine('data-testid', false));
        this._enginesV1.set('data-test-id', this._createAttributeEngine('data-test-id', true));
        this._enginesV1.set('data-test-id:light', this._createAttributeEngine('data-test-id', false));
        this._enginesV1.set('data-test', this._createAttributeEngine('data-test', true));
        this._enginesV1.set('data-test:light', this._createAttributeEngine('data-test', false));
        for (const { name, engine } of customEngines)
            this._enginesV1.set(name, engine);
        // No custom engines in V2 for now.
        this._evaluator = new selectorEvaluator_1.SelectorEvaluatorImpl(new Map());
        this._stableRafCount = stableRafCount;
        this._replaceRafWithTimeout = replaceRafWithTimeout;
    }
    parseSelector(selector) {
        const result = selectorParser_1.parseSelector(selector);
        for (const part of result.parts) {
            if (!Array.isArray(part) && !this._enginesV1.has(part.name))
                throw new Error(\`Unknown engine "\${part.name}" while parsing selector \${selector}\`);
        }
        return result;
    }
    querySelector(selector, root) {
        if (!root['querySelector'])
            throw new Error('Node is not queryable.');
        this._evaluator.begin();
        try {
            return this._querySelectorRecursively(root, selector, 0);
        }
        finally {
            this._evaluator.end();
        }
    }
    _querySelectorRecursively(root, selector, index) {
        const current = selector.parts[index];
        if (index === selector.parts.length - 1)
            return this._queryEngine(current, root);
        const all = this._queryEngineAll(current, root);
        for (const next of all) {
            const result = this._querySelectorRecursively(next, selector, index + 1);
            if (result)
                return selector.capture === index ? next : result;
        }
    }
    querySelectorAll(selector, root) {
        if (!root['querySelectorAll'])
            throw new Error('Node is not queryable.');
        this._evaluator.begin();
        try {
            const capture = selector.capture === undefined ? selector.parts.length - 1 : selector.capture;
            // Query all elements up to the capture.
            const partsToQueryAll = selector.parts.slice(0, capture + 1);
            // Check they have a descendant matching everything after the capture.
            const partsToCheckOne = selector.parts.slice(capture + 1);
            let set = new Set([root]);
            for (const part of partsToQueryAll) {
                const newSet = new Set();
                for (const prev of set) {
                    for (const next of this._queryEngineAll(part, prev)) {
                        if (newSet.has(next))
                            continue;
                        newSet.add(next);
                    }
                }
                set = newSet;
            }
            let result = Array.from(set);
            if (partsToCheckOne.length) {
                const partial = { parts: partsToCheckOne };
                result = result.filter(e => !!this._querySelectorRecursively(e, partial, 0));
            }
            return result;
        }
        finally {
            this._evaluator.end();
        }
    }
    _queryEngine(part, root) {
        if (Array.isArray(part))
            return this._evaluator.query({ scope: root, pierceShadow: true }, part)[0];
        return this._enginesV1.get(part.name).query(root, part.body);
    }
    _queryEngineAll(part, root) {
        if (Array.isArray(part))
            return this._evaluator.query({ scope: root, pierceShadow: true }, part);
        return this._enginesV1.get(part.name).queryAll(root, part.body);
    }
    _createAttributeEngine(attribute, shadow) {
        const toCSS = (selector) => {
            const css = \`[\${attribute}=\${JSON.stringify(selector)}]\`;
            return [{ simples: [{ selector: { css, functions: [] }, combinator: '' }] }];
        };
        return {
            query: (root, selector) => {
                return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector))[0];
            },
            queryAll: (root, selector) => {
                return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));
            }
        };
    }
    _createTextEngine(shadow) {
        const queryList = (root, selector, single) => {
            const { matcher, kind } = createTextMatcher(selector);
            const result = [];
            let lastDidNotMatchSelf = null;
            const checkElement = (element) => {
                // TODO: replace contains() with something shadow-dom-aware?
                if (kind === 'lax' && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))
                    return false;
                const matches = selectorEvaluator_1.elementMatchesText(this._evaluator, element, matcher);
                if (matches === 'none')
                    lastDidNotMatchSelf = element;
                if (matches === 'self' || (matches === 'selfAndChildren' && kind === 'strict'))
                    result.push(element);
                return single && result.length > 0;
            };
            if (root.nodeType === Node.ELEMENT_NODE && checkElement(root))
                return result;
            const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, '*');
            for (const element of elements) {
                if (checkElement(element))
                    return result;
            }
            return result;
        };
        return {
            query: (root, selector) => {
                return queryList(root, selector, true)[0];
            },
            queryAll: (root, selector) => {
                return queryList(root, selector, false);
            }
        };
    }
    extend(source, params) {
        const constrFunction = global.eval(\`
    (() => {
      \${source}
      return pwExport;
    })()\`);
        return new constrFunction(this, params);
    }
    isVisible(element) {
        return selectorEvaluator_1.isVisible(element);
    }
    pollRaf(predicate) {
        return this._runAbortableTask(progress => {
            let fulfill;
            let reject;
            const result = new Promise((f, r) => { fulfill = f; reject = r; });
            const onRaf = () => {
                if (progress.aborted)
                    return;
                try {
                    const continuePolling = Symbol('continuePolling');
                    const success = predicate(progress, continuePolling);
                    if (success !== continuePolling)
                        fulfill(success);
                    else
                        requestAnimationFrame(onRaf);
                }
                catch (e) {
                    reject(e);
                }
            };
            onRaf();
            return result;
        });
    }
    pollInterval(pollInterval, predicate) {
        return this._runAbortableTask(progress => {
            let fulfill;
            let reject;
            const result = new Promise((f, r) => { fulfill = f; reject = r; });
            const onTimeout = () => {
                if (progress.aborted)
                    return;
                try {
                    const continuePolling = Symbol('continuePolling');
                    const success = predicate(progress, continuePolling);
                    if (success !== continuePolling)
                        fulfill(success);
                    else
                        setTimeout(onTimeout, pollInterval);
                }
                catch (e) {
                    reject(e);
                }
            };
            onTimeout();
            return result;
        });
    }
    _runAbortableTask(task) {
        let unsentLogs = [];
        let takeNextLogsCallback;
        let taskFinished = false;
        const logReady = () => {
            if (!takeNextLogsCallback)
                return;
            takeNextLogsCallback(unsentLogs);
            unsentLogs = [];
            takeNextLogsCallback = undefined;
        };
        const takeNextLogs = () => new Promise(fulfill => {
            takeNextLogsCallback = fulfill;
            if (unsentLogs.length || taskFinished)
                logReady();
        });
        let lastLog = '';
        const progress = {
            aborted: false,
            log: (message) => {
                lastLog = message;
                unsentLogs.push(message);
                logReady();
            },
            logRepeating: (message) => {
                if (message !== lastLog)
                    progress.log(message);
            },
        };
        const run = () => {
            const result = task(progress);
            // After the task has finished, there should be no more logs.
            // Release any pending \`takeNextLogs\` call, and do not block any future ones.
            // This prevents non-finished protocol evaluation calls and memory leaks.
            result.finally(() => {
                taskFinished = true;
                logReady();
            });
            return result;
        };
        return {
            takeNextLogs,
            run,
            cancel: () => { progress.aborted = true; },
            takeLastLogs: () => unsentLogs,
        };
    }
    getElementBorderWidth(node) {
        if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)
            return { left: 0, top: 0 };
        const style = node.ownerDocument.defaultView.getComputedStyle(node);
        return { left: parseInt(style.borderLeftWidth || '', 10), top: parseInt(style.borderTopWidth || '', 10) };
    }
    _retarget(node, behavior) {
        let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
        if (!element)
            return null;
        if (!element.matches('input, textarea, select'))
            element = element.closest('button, [role=button], [role=checkbox], [role=radio]') || element;
        if (behavior === 'follow-label') {
            if (!element.matches('input, textarea, button, select, [role=button], [role=checkbox], [role=radio]') &&
                !element.isContentEditable) {
                // Go up to the label that might be connected to the input/textarea.
                element = element.closest('label') || element;
            }
            if (element.nodeName === 'LABEL')
                element = element.control || element;
        }
        return element;
    }
    waitForElementStatesAndPerformAction(node, states, callback) {
        let lastRect;
        let counter = 0;
        let samePositionCounter = 0;
        let lastTime = 0;
        const predicate = (progress, continuePolling) => {
            for (const state of states) {
                if (state !== 'stable') {
                    const result = this.checkElementState(node, state);
                    if (typeof result !== 'boolean')
                        return result;
                    if (!result) {
                        progress.logRepeating(\`    element is not \${state} - waiting...\`);
                        return continuePolling;
                    }
                    continue;
                }
                const element = this._retarget(node, 'no-follow-label');
                if (!element)
                    return 'error:notconnected';
                // First raf happens in the same animation frame as evaluation, so it does not produce
                // any client rect difference compared to synchronous call. We skip the synchronous call
                // and only force layout during actual rafs as a small optimisation.
                if (++counter === 1)
                    return continuePolling;
                // Drop frames that are shorter than 16ms - WebKit Win bug.
                const time = performance.now();
                if (this._stableRafCount > 1 && time - lastTime < 15)
                    return continuePolling;
                lastTime = time;
                const clientRect = element.getBoundingClientRect();
                const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };
                const samePosition = lastRect && rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;
                if (samePosition)
                    ++samePositionCounter;
                else
                    samePositionCounter = 0;
                const isStable = samePositionCounter >= this._stableRafCount;
                const isStableForLogs = isStable || !lastRect;
                lastRect = rect;
                if (!isStableForLogs)
                    progress.logRepeating(\`    element is not stable - waiting...\`);
                if (!isStable)
                    return continuePolling;
            }
            return callback(node, progress, continuePolling);
        };
        if (this._replaceRafWithTimeout)
            return this.pollInterval(16, predicate);
        else
            return this.pollRaf(predicate);
    }
    checkElementState(node, state) {
        const element = this._retarget(node, ['stable', 'visible', 'hidden'].includes(state) ? 'no-follow-label' : 'follow-label');
        if (!element || !element.isConnected) {
            if (state === 'hidden')
                return true;
            return 'error:notconnected';
        }
        if (state === 'visible')
            return this.isVisible(element);
        if (state === 'hidden')
            return !this.isVisible(element);
        const disabled = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].includes(element.nodeName) && element.hasAttribute('disabled');
        if (state === 'disabled')
            return disabled;
        if (state === 'enabled')
            return !disabled;
        const editable = !(['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName) && element.hasAttribute('readonly'));
        if (state === 'editable')
            return !disabled && editable;
        if (state === 'checked') {
            if (element.getAttribute('role') === 'checkbox')
                return element.getAttribute('aria-checked') === 'true';
            if (element.nodeName !== 'INPUT')
                return 'error:notcheckbox';
            if (!['radio', 'checkbox'].includes(element.type.toLowerCase()))
                return 'error:notcheckbox';
            return element.checked;
        }
        throw new Error(\`Unexpected element state "\${state}"\`);
    }
    selectOptions(optionsToSelect, node, progress, continuePolling) {
        const element = this._retarget(node, 'follow-label');
        if (!element)
            return 'error:notconnected';
        if (element.nodeName.toLowerCase() !== 'select')
            return 'error:notselect';
        const select = element;
        const options = Array.from(select.options);
        const selectedOptions = [];
        let remainingOptionsToSelect = optionsToSelect.slice();
        for (let index = 0; index < options.length; index++) {
            const option = options[index];
            const filter = (optionToSelect) => {
                if (optionToSelect instanceof Node)
                    return option === optionToSelect;
                let matches = true;
                if (optionToSelect.value !== undefined)
                    matches = matches && optionToSelect.value === option.value;
                if (optionToSelect.label !== undefined)
                    matches = matches && optionToSelect.label === option.label;
                if (optionToSelect.index !== undefined)
                    matches = matches && optionToSelect.index === index;
                return matches;
            };
            if (!remainingOptionsToSelect.some(filter))
                continue;
            selectedOptions.push(option);
            if (select.multiple) {
                remainingOptionsToSelect = remainingOptionsToSelect.filter(o => !filter(o));
            }
            else {
                remainingOptionsToSelect = [];
                break;
            }
        }
        if (remainingOptionsToSelect.length) {
            progress.logRepeating('    did not find some options - waiting... ');
            return continuePolling;
        }
        select.value = undefined;
        selectedOptions.forEach(option => option.selected = true);
        progress.log('    selected specified option(s)');
        select.dispatchEvent(new Event('input', { 'bubbles': true }));
        select.dispatchEvent(new Event('change', { 'bubbles': true }));
        return selectedOptions.map(option => option.value);
    }
    fill(value, node, progress) {
        const element = this._retarget(node, 'follow-label');
        if (!element)
            return 'error:notconnected';
        if (element.nodeName.toLowerCase() === 'input') {
            const input = element;
            const type = input.type.toLowerCase();
            const kDateTypes = new Set(['date', 'time', 'datetime', 'datetime-local', 'month', 'week']);
            const kTextInputTypes = new Set(['', 'email', 'number', 'password', 'search', 'tel', 'text', 'url']);
            if (!kTextInputTypes.has(type) && !kDateTypes.has(type)) {
                progress.log(\`    input of type "\${type}" cannot be filled\`);
                return 'error:notfillableinputtype';
            }
            if (type === 'number') {
                value = value.trim();
                if (isNaN(Number(value)))
                    return 'error:notfillablenumberinput';
            }
            if (kDateTypes.has(type)) {
                value = value.trim();
                input.focus();
                input.value = value;
                if (input.value !== value)
                    return 'error:notvaliddate';
                element.dispatchEvent(new Event('input', { 'bubbles': true }));
                element.dispatchEvent(new Event('change', { 'bubbles': true }));
                return 'done'; // We have already changed the value, no need to input it.
            }
        }
        else if (element.nodeName.toLowerCase() === 'textarea') {
            // Nothing to check here.
        }
        else if (!element.isContentEditable) {
            return 'error:notfillableelement';
        }
        this.selectText(element);
        return 'needsinput'; // Still need to input the value.
    }
    selectText(node) {
        const element = this._retarget(node, 'follow-label');
        if (!element)
            return 'error:notconnected';
        if (element.nodeName.toLowerCase() === 'input') {
            const input = element;
            input.select();
            input.focus();
            return 'done';
        }
        if (element.nodeName.toLowerCase() === 'textarea') {
            const textarea = element;
            textarea.selectionStart = 0;
            textarea.selectionEnd = textarea.value.length;
            textarea.focus();
            return 'done';
        }
        const range = element.ownerDocument.createRange();
        range.selectNodeContents(element);
        const selection = element.ownerDocument.defaultView.getSelection();
        if (selection) {
            selection.removeAllRanges();
            selection.addRange(range);
        }
        element.focus();
        return 'done';
    }
    focusNode(node, resetSelectionIfNotFocused) {
        if (!node.isConnected)
            return 'error:notconnected';
        if (node.nodeType !== Node.ELEMENT_NODE)
            return 'error:notelement';
        const wasFocused = node.getRootNode().activeElement === node && node.ownerDocument && node.ownerDocument.hasFocus();
        node.focus();
        if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === 'input') {
            try {
                const input = node;
                input.setSelectionRange(0, 0);
            }
            catch (e) {
                // Some inputs do not allow selection.
            }
        }
        return 'done';
    }
    setInputFiles(node, payloads) {
        if (node.nodeType !== Node.ELEMENT_NODE)
            return 'Node is not of type HTMLElement';
        const element = node;
        if (element.nodeName !== 'INPUT')
            return 'Not an <input> element';
        const input = element;
        const type = (input.getAttribute('type') || '').toLowerCase();
        if (type !== 'file')
            return 'Not an input[type=file] element';
        const files = payloads.map(file => {
            const bytes = Uint8Array.from(atob(file.buffer), c => c.charCodeAt(0));
            return new File([bytes], file.name, { type: file.mimeType });
        });
        const dt = new DataTransfer();
        for (const file of files)
            dt.items.add(file);
        input.files = dt.files;
        input.dispatchEvent(new Event('input', { 'bubbles': true }));
        input.dispatchEvent(new Event('change', { 'bubbles': true }));
    }
    checkHitTargetAt(node, point) {
        let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
        if (!element || !element.isConnected)
            return 'error:notconnected';
        element = element.closest('button, [role=button]') || element;
        let hitElement = this.deepElementFromPoint(document, point.x, point.y);
        const hitParents = [];
        while (hitElement && hitElement !== element) {
            hitParents.push(hitElement);
            hitElement = selectorEvaluator_1.parentElementOrShadowHost(hitElement);
        }
        if (hitElement === element)
            return 'done';
        const hitTargetDescription = this.previewNode(hitParents[0]);
        // Root is the topmost element in the hitTarget's chain that is not in the
        // element's chain. For example, it might be a dialog element that overlays
        // the target.
        let rootHitTargetDescription;
        while (element) {
            const index = hitParents.indexOf(element);
            if (index !== -1) {
                if (index > 1)
                    rootHitTargetDescription = this.previewNode(hitParents[index - 1]);
                break;
            }
            element = selectorEvaluator_1.parentElementOrShadowHost(element);
        }
        if (rootHitTargetDescription)
            return { hitTargetDescription: \`\${hitTargetDescription} from \${rootHitTargetDescription} subtree\` };
        return { hitTargetDescription };
    }
    dispatchEvent(node, type, eventInit) {
        let event;
        eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInit };
        switch (eventType.get(type)) {
            case 'mouse':
                event = new MouseEvent(type, eventInit);
                break;
            case 'keyboard':
                event = new KeyboardEvent(type, eventInit);
                break;
            case 'touch':
                event = new TouchEvent(type, eventInit);
                break;
            case 'pointer':
                event = new PointerEvent(type, eventInit);
                break;
            case 'focus':
                event = new FocusEvent(type, eventInit);
                break;
            case 'drag':
                event = new DragEvent(type, eventInit);
                break;
            default:
                event = new Event(type, eventInit);
                break;
        }
        node.dispatchEvent(event);
    }
    deepElementFromPoint(document, x, y) {
        let container = document;
        let element;
        while (container) {
            // elementFromPoint works incorrectly in Chromium (http://crbug.com/1188919),
            // so we use elementsFromPoint instead.
            const elements = container.elementsFromPoint(x, y);
            const innerElement = elements[0];
            if (!innerElement || element === innerElement)
                break;
            element = innerElement;
            container = element.shadowRoot;
        }
        return element;
    }
    previewNode(node) {
        if (node.nodeType === Node.TEXT_NODE)
            return oneLine(\`#text=\${node.nodeValue || ''}\`);
        if (node.nodeType !== Node.ELEMENT_NODE)
            return oneLine(\`<\${node.nodeName.toLowerCase()} />\`);
        const element = node;
        const attrs = [];
        for (let i = 0; i < element.attributes.length; i++) {
            const { name, value } = element.attributes[i];
            if (name === 'style')
                continue;
            if (!value && booleanAttributes.has(name))
                attrs.push(\` \${name}\`);
            else
                attrs.push(\` \${name}="\${value}"\`);
        }
        attrs.sort((a, b) => a.length - b.length);
        let attrText = attrs.join('');
        if (attrText.length > 50)
            attrText = attrText.substring(0, 49) + '\\u2026';
        if (autoClosingTags.has(element.nodeName))
            return oneLine(\`<\${element.nodeName.toLowerCase()}\${attrText}/>\`);
        const children = element.childNodes;
        let onlyText = false;
        if (children.length <= 5) {
            onlyText = true;
            for (let i = 0; i < children.length; i++)
                onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;
        }
        let text = onlyText ? (element.textContent || '') : (children.length ? '\\u2026' : '');
        if (text.length > 50)
            text = text.substring(0, 49) + '\\u2026';
        return oneLine(\`<\${element.nodeName.toLowerCase()}\${attrText}>\${text}</\${element.nodeName.toLowerCase()}>\`);
    }
}
exports.InjectedScript = InjectedScript;
const autoClosingTags = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'MENUITEM', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);
const booleanAttributes = new Set(['checked', 'selected', 'disabled', 'readonly', 'multiple']);
function oneLine(s) {
    return s.replace(/\\n/g, '\u21B5').replace(/\\t/g, '\u21C6');
}
const eventType = new Map([
    ['auxclick', 'mouse'],
    ['click', 'mouse'],
    ['dblclick', 'mouse'],
    ['mousedown', 'mouse'],
    ['mouseeenter', 'mouse'],
    ['mouseleave', 'mouse'],
    ['mousemove', 'mouse'],
    ['mouseout', 'mouse'],
    ['mouseover', 'mouse'],
    ['mouseup', 'mouse'],
    ['mouseleave', 'mouse'],
    ['mousewheel', 'mouse'],
    ['keydown', 'keyboard'],
    ['keyup', 'keyboard'],
    ['keypress', 'keyboard'],
    ['textInput', 'keyboard'],
    ['touchstart', 'touch'],
    ['touchmove', 'touch'],
    ['touchend', 'touch'],
    ['touchcancel', 'touch'],
    ['pointerover', 'pointer'],
    ['pointerout', 'pointer'],
    ['pointerenter', 'pointer'],
    ['pointerleave', 'pointer'],
    ['pointerdown', 'pointer'],
    ['pointerup', 'pointer'],
    ['pointermove', 'pointer'],
    ['pointercancel', 'pointer'],
    ['gotpointercapture', 'pointer'],
    ['lostpointercapture', 'pointer'],
    ['focus', 'focus'],
    ['blur', 'focus'],
    ['drag', 'drag'],
    ['dragstart', 'drag'],
    ['dragend', 'drag'],
    ['dragover', 'drag'],
    ['dragenter', 'drag'],
    ['dragleave', 'drag'],
    ['dragexit', 'drag'],
    ['drop', 'drag'],
]);
function unescape(s) {
    if (!s.includes('\\\\'))
        return s;
    const r = [];
    let i = 0;
    while (i < s.length) {
        if (s[i] === '\\\\' && i + 1 < s.length)
            i++;
        r.push(s[i++]);
    }
    return r.join('');
}
function createTextMatcher(selector) {
    if (selector[0] === '/' && selector.lastIndexOf('/') > 0) {
        const lastSlash = selector.lastIndexOf('/');
        const matcher = selectorEvaluator_1.createRegexTextMatcher(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));
        return { matcher, kind: 'regex' };
    }
    let strict = false;
    if (selector.length > 1 && selector[0] === '"' && selector[selector.length - 1] === '"') {
        selector = unescape(selector.substring(1, selector.length - 1));
        strict = true;
    }
    if (selector.length > 1 && selector[0] === "'" && selector[selector.length - 1] === "'") {
        selector = unescape(selector.substring(1, selector.length - 1));
        strict = true;
    }
    const matcher = strict ? selectorEvaluator_1.createStrictTextMatcher(selector) : selectorEvaluator_1.createLaxTextMatcher(selector);
    return { matcher, kind: strict ? 'strict' : 'lax' };
}
exports.default = InjectedScript;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/server/injected/selectorEvaluator.ts":
/*!**************************************************!*\\
  !*** ./src/server/injected/selectorEvaluator.ts ***!
  \\**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVisible = exports.parentElementOrShadowHost = exports.elementMatchesText = exports.elementText = exports.createRegexTextMatcher = exports.createStrictTextMatcher = exports.createLaxTextMatcher = exports.SelectorEvaluatorImpl = void 0;
const selectorParser_1 = __webpack_require__(/*! ../common/selectorParser */ "./src/server/common/selectorParser.ts");
class SelectorEvaluatorImpl {
    constructor(extraEngines) {
        this._engines = new Map();
        this._cacheQueryCSS = new Map();
        this._cacheMatches = new Map();
        this._cacheQuery = new Map();
        this._cacheMatchesSimple = new Map();
        this._cacheMatchesParents = new Map();
        this._cacheCallMatches = new Map();
        this._cacheCallQuery = new Map();
        this._cacheQuerySimple = new Map();
        this._cacheText = new Map();
        this._retainCacheCounter = 0;
        for (const [name, engine] of extraEngines)
            this._engines.set(name, engine);
        this._engines.set('not', notEngine);
        this._engines.set('is', isEngine);
        this._engines.set('where', isEngine);
        this._engines.set('has', hasEngine);
        this._engines.set('scope', scopeEngine);
        this._engines.set('light', lightEngine);
        this._engines.set('visible', visibleEngine);
        this._engines.set('text', textEngine);
        this._engines.set('text-is', textIsEngine);
        this._engines.set('text-matches', textMatchesEngine);
        this._engines.set('has-text', hasTextEngine);
        this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));
        this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));
        this._engines.set('above', createPositionEngine('above', boxAbove));
        this._engines.set('below', createPositionEngine('below', boxBelow));
        this._engines.set('near', createPositionEngine('near', boxNear));
        this._engines.set('nth-match', nthMatchEngine);
        const allNames = Array.from(this._engines.keys());
        allNames.sort();
        const parserNames = Array.from(selectorParser_1.customCSSNames).slice();
        parserNames.sort();
        if (allNames.join('|') !== parserNames.join('|'))
            throw new Error(\`Please keep customCSSNames in sync with evaluator engines: \${allNames.join('|')} vs \${parserNames.join('|')}\`);
    }
    begin() {
        ++this._retainCacheCounter;
    }
    end() {
        --this._retainCacheCounter;
        if (!this._retainCacheCounter) {
            this._cacheQueryCSS.clear();
            this._cacheMatches.clear();
            this._cacheQuery.clear();
            this._cacheMatchesSimple.clear();
            this._cacheMatchesParents.clear();
            this._cacheCallMatches.clear();
            this._cacheCallQuery.clear();
            this._cacheQuerySimple.clear();
            this._cacheText.clear();
        }
    }
    _cached(cache, main, rest, cb) {
        if (!cache.has(main))
            cache.set(main, []);
        const entries = cache.get(main);
        const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));
        if (entry)
            return entry.result;
        const result = cb();
        entries.push({ rest, result });
        return result;
    }
    _checkSelector(s) {
        const wellFormed = typeof s === 'object' && s &&
            (Array.isArray(s) || ('simples' in s) && (s.simples.length));
        if (!wellFormed)
            throw new Error(\`Malformed selector "\${s}"\`);
        return s;
    }
    matches(element, s, context) {
        const selector = this._checkSelector(s);
        this.begin();
        try {
            return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {
                if (Array.isArray(selector))
                    return this._matchesEngine(isEngine, element, selector, context);
                if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))
                    return false;
                return this._matchesParents(element, selector, selector.simples.length - 2, context);
            });
        }
        finally {
            this.end();
        }
    }
    query(context, s) {
        const selector = this._checkSelector(s);
        this.begin();
        try {
            return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {
                if (Array.isArray(selector))
                    return this._queryEngine(isEngine, context, selector);
                // query() recursively calls itself, so we set up a new map for this particular query() call.
                const previousScoreMap = this._scoreMap;
                this._scoreMap = new Map();
                let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);
                elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));
                if (this._scoreMap.size) {
                    elements.sort((a, b) => {
                        const aScore = this._scoreMap.get(a);
                        const bScore = this._scoreMap.get(b);
                        if (aScore === bScore)
                            return 0;
                        if (aScore === undefined)
                            return 1;
                        if (bScore === undefined)
                            return -1;
                        return aScore - bScore;
                    });
                }
                this._scoreMap = previousScoreMap;
                return elements;
            });
        }
        finally {
            this.end();
        }
    }
    _markScore(element, score) {
        // HACK ALERT: temporary marks an element with a score, to be used
        // for sorting at the end of the query().
        if (this._scoreMap)
            this._scoreMap.set(element, score);
    }
    _matchesSimple(element, simple, context) {
        return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {
            const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');
            if (!isPossiblyScopeClause && element === context.scope)
                return false;
            if (simple.css && !this._matchesCSS(element, simple.css))
                return false;
            for (const func of simple.functions) {
                if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))
                    return false;
            }
            return true;
        });
    }
    _querySimple(context, simple) {
        if (!simple.functions.length)
            return this._queryCSS(context, simple.css || '*');
        return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {
            let css = simple.css;
            const funcs = simple.functions;
            if (css === '*' && funcs.length)
                css = undefined;
            let elements;
            let firstIndex = -1;
            if (css !== undefined) {
                elements = this._queryCSS(context, css);
            }
            else {
                firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);
                if (firstIndex === -1)
                    firstIndex = 0;
                elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);
            }
            for (let i = 0; i < funcs.length; i++) {
                if (i === firstIndex)
                    continue;
                const engine = this._getEngine(funcs[i].name);
                if (engine.matches !== undefined)
                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));
            }
            for (let i = 0; i < funcs.length; i++) {
                if (i === firstIndex)
                    continue;
                const engine = this._getEngine(funcs[i].name);
                if (engine.matches === undefined)
                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));
            }
            return elements;
        });
    }
    _matchesParents(element, complex, index, context) {
        if (index < 0)
            return true;
        return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {
            const { selector: simple, combinator } = complex.simples[index];
            if (combinator === '>') {
                const parent = parentElementOrShadowHostInContext(element, context);
                if (!parent || !this._matchesSimple(parent, simple, context))
                    return false;
                return this._matchesParents(parent, complex, index - 1, context);
            }
            if (combinator === '+') {
                const previousSibling = previousSiblingInContext(element, context);
                if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))
                    return false;
                return this._matchesParents(previousSibling, complex, index - 1, context);
            }
            if (combinator === '') {
                let parent = parentElementOrShadowHostInContext(element, context);
                while (parent) {
                    if (this._matchesSimple(parent, simple, context)) {
                        if (this._matchesParents(parent, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '')
                            break;
                    }
                    parent = parentElementOrShadowHostInContext(parent, context);
                }
                return false;
            }
            if (combinator === '~') {
                let previousSibling = previousSiblingInContext(element, context);
                while (previousSibling) {
                    if (this._matchesSimple(previousSibling, simple, context)) {
                        if (this._matchesParents(previousSibling, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '~')
                            break;
                    }
                    previousSibling = previousSiblingInContext(previousSibling, context);
                }
                return false;
            }
            if (combinator === '>=') {
                let parent = element;
                while (parent) {
                    if (this._matchesSimple(parent, simple, context)) {
                        if (this._matchesParents(parent, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '')
                            break;
                    }
                    parent = parentElementOrShadowHostInContext(parent, context);
                }
                return false;
            }
            throw new Error(\`Unsupported combinator "\${combinator}"\`);
        });
    }
    _matchesEngine(engine, element, args, context) {
        if (engine.matches)
            return this._callMatches(engine, element, args, context);
        if (engine.query)
            return this._callQuery(engine, args, context).includes(element);
        throw new Error(\`Selector engine should implement "matches" or "query"\`);
    }
    _queryEngine(engine, context, args) {
        if (engine.query)
            return this._callQuery(engine, args, context);
        if (engine.matches)
            return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));
        throw new Error(\`Selector engine should implement "matches" or "query"\`);
    }
    _callMatches(engine, element, args, context) {
        return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {
            return engine.matches(element, args, context, this);
        });
    }
    _callQuery(engine, args, context) {
        return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {
            return engine.query(context, args, this);
        });
    }
    _matchesCSS(element, css) {
        return element.matches(css);
    }
    _queryCSS(context, css) {
        return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {
            let result = [];
            function query(root) {
                result = result.concat([...root.querySelectorAll(css)]);
                if (!context.pierceShadow)
                    return;
                if (root.shadowRoot)
                    query(root.shadowRoot);
                for (const element of root.querySelectorAll('*')) {
                    if (element.shadowRoot)
                        query(element.shadowRoot);
                }
            }
            query(context.scope);
            return result;
        });
    }
    _getEngine(name) {
        const engine = this._engines.get(name);
        if (!engine)
            throw new Error(\`Unknown selector engine "\${name}"\`);
        return engine;
    }
}
exports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;
const isEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"is" engine expects non-empty selector list\`);
        return args.some(selector => evaluator.matches(element, selector, context));
    },
    query(context, args, evaluator) {
        if (args.length === 0)
            throw new Error(\`"is" engine expects non-empty selector list\`);
        let elements = [];
        for (const arg of args)
            elements = elements.concat(evaluator.query(context, arg));
        return args.length === 1 ? elements : sortInDOMOrder(elements);
    },
};
const hasEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"has" engine expects non-empty selector list\`);
        return evaluator.query({ ...context, scope: element }, args).length > 0;
    },
};
const scopeEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 0)
            throw new Error(\`"scope" engine expects no arguments\`);
        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */)
            return element === context.scope.documentElement;
        return element === context.scope;
    },
    query(context, args, evaluator) {
        if (args.length !== 0)
            throw new Error(\`"scope" engine expects no arguments\`);
        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */) {
            const root = context.scope.documentElement;
            return root ? [root] : [];
        }
        if (context.scope.nodeType === 1 /* Node.ELEMENT_NODE */)
            return [context.scope];
        return [];
    },
};
const notEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"not" engine expects non-empty selector list\`);
        return !evaluator.matches(element, args, context);
    },
};
const lightEngine = {
    query(context, args, evaluator) {
        return evaluator.query({ ...context, pierceShadow: false }, args);
    },
    matches(element, args, context, evaluator) {
        return evaluator.matches(element, args, { ...context, pierceShadow: false });
    }
};
const visibleEngine = {
    matches(element, args, context, evaluator) {
        if (args.length)
            throw new Error(\`"visible" engine expects no arguments\`);
        return isVisible(element);
    }
};
const textEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"text" engine expects a single string\`);
        const matcher = createLaxTextMatcher(args[0]);
        return elementMatchesText(evaluator, element, matcher) === 'self';
    },
};
const textIsEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"text-is" engine expects a single string\`);
        const matcher = createStrictTextMatcher(args[0]);
        return elementMatchesText(evaluator, element, matcher) !== 'none';
    },
};
const textMatchesEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || (args.length === 2 && typeof args[1] !== 'string'))
            throw new Error(\`"text-matches" engine expects a regexp body and optional regexp flags\`);
        const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);
        return elementMatchesText(evaluator, element, matcher) === 'self';
    },
};
const hasTextEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"has-text" engine expects a single string\`);
        if (shouldSkipForTextMatching(element))
            return false;
        const matcher = createLaxTextMatcher(args[0]);
        return matcher(elementText(evaluator, element));
    },
};
function createLaxTextMatcher(text) {
    text = text.trim().replace(/\\s+/g, ' ').toLowerCase();
    return (elementText) => {
        const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();
        return s.includes(text);
    };
}
exports.createLaxTextMatcher = createLaxTextMatcher;
function createStrictTextMatcher(text) {
    text = text.trim().replace(/\\s+/g, ' ');
    return (elementText) => {
        return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);
    };
}
exports.createStrictTextMatcher = createStrictTextMatcher;
function createRegexTextMatcher(source, flags) {
    const re = new RegExp(source, flags);
    return (elementText) => {
        return re.test(elementText.full);
    };
}
exports.createRegexTextMatcher = createRegexTextMatcher;
function shouldSkipForTextMatching(element) {
    return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);
}
function elementText(evaluator, root) {
    let value = evaluator._cacheText.get(root);
    if (value === undefined) {
        value = { full: '', immediate: [] };
        if (!shouldSkipForTextMatching(root)) {
            let currentImmediate = '';
            if ((root instanceof HTMLInputElement) && (root.type === 'submit' || root.type === 'button')) {
                value = { full: root.value, immediate: [root.value] };
            }
            else {
                for (let child = root.firstChild; child; child = child.nextSibling) {
                    if (child.nodeType === Node.TEXT_NODE) {
                        value.full += child.nodeValue || '';
                        currentImmediate += child.nodeValue || '';
                    }
                    else {
                        if (currentImmediate)
                            value.immediate.push(currentImmediate);
                        currentImmediate = '';
                        if (child.nodeType === Node.ELEMENT_NODE)
                            value.full += elementText(evaluator, child).full;
                    }
                }
                if (currentImmediate)
                    value.immediate.push(currentImmediate);
                if (root.shadowRoot)
                    value.full += elementText(evaluator, root.shadowRoot).full;
            }
        }
        evaluator._cacheText.set(root, value);
    }
    return value;
}
exports.elementText = elementText;
function elementMatchesText(evaluator, element, matcher) {
    if (shouldSkipForTextMatching(element))
        return 'none';
    if (!matcher(elementText(evaluator, element)))
        return 'none';
    for (let child = element.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))
            return 'selfAndChildren';
    }
    if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))
        return 'selfAndChildren';
    return 'self';
}
exports.elementMatchesText = elementMatchesText;
function boxRightOf(box1, box2, maxDistance) {
    const distance = box1.left - box2.right;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);
}
function boxLeftOf(box1, box2, maxDistance) {
    const distance = box2.left - box1.right;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);
}
function boxAbove(box1, box2, maxDistance) {
    const distance = box2.top - box1.bottom;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);
}
function boxBelow(box1, box2, maxDistance) {
    const distance = box1.top - box2.bottom;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);
}
function boxNear(box1, box2, maxDistance) {
    const kThreshold = maxDistance === undefined ? 50 : maxDistance;
    let score = 0;
    if (box1.left - box2.right >= 0)
        score += box1.left - box2.right;
    if (box2.left - box1.right >= 0)
        score += box2.left - box1.right;
    if (box2.top - box1.bottom >= 0)
        score += box2.top - box1.bottom;
    if (box1.top - box2.bottom >= 0)
        score += box1.top - box2.bottom;
    return score > kThreshold ? undefined : score;
}
function createPositionEngine(name, scorer) {
    return {
        matches(element, args, context, evaluator) {
            const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;
            const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);
            if (args.length < 1 + (maxDistance === undefined ? 0 : 1))
                throw new Error(\`"\${name}" engine expects a selector list and optional maximum distance in pixels\`);
            const box = element.getBoundingClientRect();
            let bestScore;
            for (const e of evaluator.query(context, queryArgs)) {
                if (e === element)
                    continue;
                const score = scorer(box, e.getBoundingClientRect(), maxDistance);
                if (score === undefined)
                    continue;
                if (bestScore === undefined || score < bestScore)
                    bestScore = score;
            }
            if (bestScore === undefined)
                return false;
            evaluator._markScore(element, bestScore);
            return true;
        }
    };
}
const nthMatchEngine = {
    query(context, args, evaluator) {
        let index = args[args.length - 1];
        if (args.length < 2)
            throw new Error(\`"nth-match" engine expects non-empty selector list and an index argument\`);
        if (typeof index !== 'number' || index < 1)
            throw new Error(\`"nth-match" engine expects a one-based index as the last argument\`);
        const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);
        index--; // one-based
        return index < elements.length ? [elements[index]] : [];
    },
};
function parentElementOrShadowHost(element) {
    if (element.parentElement)
        return element.parentElement;
    if (!element.parentNode)
        return;
    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)
        return element.parentNode.host;
}
exports.parentElementOrShadowHost = parentElementOrShadowHost;
function parentElementOrShadowHostInContext(element, context) {
    if (element === context.scope)
        return;
    if (!context.pierceShadow)
        return element.parentElement || undefined;
    return parentElementOrShadowHost(element);
}
function previousSiblingInContext(element, context) {
    if (element === context.scope)
        return;
    return element.previousElementSibling || undefined;
}
function isVisible(element) {
    // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.
    if (!element.ownerDocument || !element.ownerDocument.defaultView)
        return true;
    const style = element.ownerDocument.defaultView.getComputedStyle(element);
    if (!style || style.visibility === 'hidden')
        return false;
    const rect = element.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0;
}
exports.isVisible = isVisible;
function sortInDOMOrder(elements) {
    const elementToEntry = new Map();
    const roots = [];
    const result = [];
    function append(element) {
        let entry = elementToEntry.get(element);
        if (entry)
            return entry;
        const parent = parentElementOrShadowHost(element);
        if (parent) {
            const parentEntry = append(parent);
            parentEntry.children.push(element);
        }
        else {
            roots.push(element);
        }
        entry = { children: [], taken: false };
        elementToEntry.set(element, entry);
        return entry;
    }
    elements.forEach(e => append(e).taken = true);
    function visit(element) {
        const entry = elementToEntry.get(element);
        if (entry.taken)
            result.push(element);
        if (entry.children.length > 1) {
            const set = new Set(entry.children);
            entry.children = [];
            let child = element.firstElementChild;
            while (child && entry.children.length < set.size) {
                if (set.has(child))
                    entry.children.push(child);
                child = child.nextElementSibling;
            }
            child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;
            while (child && entry.children.length < set.size) {
                if (set.has(child))
                    entry.children.push(child);
                child = child.nextElementSibling;
            }
        }
        entry.children.forEach(visit);
    }
    roots.forEach(visit);
    return result;
}


/***/ }),

/***/ "./src/server/injected/xpathSelectorEngine.ts":
/*!****************************************************!*\\
  !*** ./src/server/injected/xpathSelectorEngine.ts ***!
  \\****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XPathEngine = void 0;
exports.XPathEngine = {
    query(root, selector) {
        if (selector.startsWith('/'))
            selector = '.' + selector;
        const document = root instanceof Document ? root : root.ownerDocument;
        if (!document)
            return;
        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
        for (let node = it.iterateNext(); node; node = it.iterateNext()) {
            if (node.nodeType === Node.ELEMENT_NODE)
                return node;
        }
    },
    queryAll(root, selector) {
        if (selector.startsWith('/'))
            selector = '.' + selector;
        const result = [];
        const document = root instanceof Document ? root : root.ownerDocument;
        if (!document)
            return result;
        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
        for (let node = it.iterateNext(); node; node = it.iterateNext()) {
            if (node.nodeType === Node.ELEMENT_NODE)
                result.push(node);
        }
        return result;
    }
};


/***/ })

/******/ })["default"];`;
  }
});

// node_modules/playwright/lib/generated/utilityScriptSource.js
var require_utilityScriptSource = __commonJS({
  "node_modules/playwright/lib/generated/utilityScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.source = void 0;
    exports2.source = `var pwExport =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/injected/utilityScript.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\\
  !*** (webpack)/buildin/global.js ***!
  \\***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/server/common/utilityScriptSerializers.ts":
/*!*******************************************************!*\\
  !*** ./src/server/common/utilityScriptSerializers.ts ***!
  \\*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeAsCallArgument = exports.parseEvaluationResultValue = void 0;
function isRegExp(obj) {
    return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
}
function isDate(obj) {
    return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
}
function isError(obj) {
    return obj instanceof Error || (obj && obj.__proto__ && obj.__proto__.name === 'Error');
}
function parseEvaluationResultValue(value, handles = []) {
    if (Object.is(value, undefined))
        return undefined;
    if (typeof value === 'object' && value) {
        if ('v' in value) {
            if (value.v === 'undefined')
                return undefined;
            if (value.v === 'null')
                return null;
            if (value.v === 'NaN')
                return NaN;
            if (value.v === 'Infinity')
                return Infinity;
            if (value.v === '-Infinity')
                return -Infinity;
            if (value.v === '-0')
                return -0;
            return undefined;
        }
        if ('d' in value)
            return new Date(value.d);
        if ('r' in value)
            return new RegExp(value.r.p, value.r.f);
        if ('a' in value)
            return value.a.map((a) => parseEvaluationResultValue(a, handles));
        if ('o' in value) {
            const result = {};
            for (const { k, v } of value.o)
                result[k] = parseEvaluationResultValue(v, handles);
            return result;
        }
        if ('h' in value)
            return handles[value.h];
    }
    return value;
}
exports.parseEvaluationResultValue = parseEvaluationResultValue;
function serializeAsCallArgument(value, handleSerializer) {
    return serialize(value, handleSerializer, new Set());
}
exports.serializeAsCallArgument = serializeAsCallArgument;
function serialize(value, handleSerializer, visited) {
    const result = handleSerializer(value);
    if ('fallThrough' in result)
        value = result.fallThrough;
    else
        return result;
    if (visited.has(value))
        throw new Error('Argument is a circular structure');
    if (typeof value === 'symbol')
        return { v: 'undefined' };
    if (Object.is(value, undefined))
        return { v: 'undefined' };
    if (Object.is(value, null))
        return { v: 'null' };
    if (Object.is(value, NaN))
        return { v: 'NaN' };
    if (Object.is(value, Infinity))
        return { v: 'Infinity' };
    if (Object.is(value, -Infinity))
        return { v: '-Infinity' };
    if (Object.is(value, -0))
        return { v: '-0' };
    if (typeof value === 'boolean')
        return value;
    if (typeof value === 'number')
        return value;
    if (typeof value === 'string')
        return value;
    if (isError(value)) {
        const error = value;
        if ('captureStackTrace' in global.Error) {
            // v8
            return error.stack || '';
        }
        return \`\${error.name}: \${error.message}\\n\${error.stack}\`;
    }
    if (isDate(value))
        return { d: value.toJSON() };
    if (isRegExp(value))
        return { r: { p: value.source, f: value.flags } };
    if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
            a.push(serialize(value[i], handleSerializer, visited));
        visited.delete(value);
        return { a };
    }
    if (typeof value === 'object') {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value)) {
            let item;
            try {
                item = value[name];
            }
            catch (e) {
                continue; // native bindings will throw sometimes
            }
            if (name === 'toJSON' && typeof item === 'function')
                o.push({ k: name, v: { o: [] } });
            else
                o.push({ k: name, v: serialize(item, handleSerializer, visited) });
        }
        visited.delete(value);
        return { o };
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/server/injected/utilityScript.ts":
/*!**********************************************!*\\
  !*** ./src/server/injected/utilityScript.ts ***!
  \\**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utilityScriptSerializers_1 = __webpack_require__(/*! ../common/utilityScriptSerializers */ "./src/server/common/utilityScriptSerializers.ts");
class UtilityScript {
    evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {
        const args = argsAndHandles.slice(0, argCount);
        const handles = argsAndHandles.slice(argCount);
        const parameters = args.map(a => utilityScriptSerializers_1.parseEvaluationResultValue(a, handles));
        let result = global.eval(expression);
        if (isFunction === true) {
            result = result(...parameters);
        }
        else if (isFunction === false) {
            result = result;
        }
        else {
            // auto detect.
            if (typeof result === 'function')
                result = result(...parameters);
        }
        return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;
    }
    jsonValue(returnByValue, value) {
        // Special handling of undefined to work-around multi-step returnByValue handling in WebKit.
        if (Object.is(value, undefined))
            return undefined;
        return utilityScriptSerializers_1.serializeAsCallArgument(value, (value) => ({ fallThrough: value }));
    }
    _promiseAwareJsonValueNoThrow(value) {
        const safeJson = (value) => {
            try {
                return this.jsonValue(true, value);
            }
            catch (e) {
                return undefined;
            }
        };
        if (value && typeof value === 'object' && typeof value.then === 'function') {
            return (async () => {
                // By using async function we ensure that return value is a native Promise,
                // and not some overridden Promise in the page.
                // This makes Firefox and WebKit debugging protocols recognize it as a Promise,
                // properly await and return the value.
                const promiseValue = await value;
                return safeJson(promiseValue);
            })();
        }
        return safeJson(value);
    }
}
exports.default = UtilityScript;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ })

/******/ })["default"];`;
  }
});

// node_modules/playwright/lib/server/common/utilityScriptSerializers.js
var require_utilityScriptSerializers = __commonJS({
  "node_modules/playwright/lib/server/common/utilityScriptSerializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.serializeAsCallArgument = exports2.parseEvaluationResultValue = void 0;
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError2(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    function parseEvaluationResultValue(value, handles = []) {
      if (Object.is(value, void 0))
        return void 0;
      if (typeof value === "object" && value) {
        if ("v" in value) {
          if (value.v === "undefined")
            return void 0;
          if (value.v === "null")
            return null;
          if (value.v === "NaN")
            return NaN;
          if (value.v === "Infinity")
            return Infinity;
          if (value.v === "-Infinity")
            return -Infinity;
          if (value.v === "-0")
            return -0;
          return void 0;
        }
        if ("d" in value)
          return new Date(value.d);
        if ("r" in value)
          return new RegExp(value.r.p, value.r.f);
        if ("a" in value)
          return value.a.map((a) => parseEvaluationResultValue(a, handles));
        if ("o" in value) {
          const result = {};
          for (const {k, v} of value.o)
            result[k] = parseEvaluationResultValue(v, handles);
          return result;
        }
        if ("h" in value)
          return handles[value.h];
      }
      return value;
    }
    exports2.parseEvaluationResultValue = parseEvaluationResultValue;
    function serializeAsCallArgument(value, handleSerializer) {
      return serialize(value, handleSerializer, new Set());
    }
    exports2.serializeAsCallArgument = serializeAsCallArgument;
    function serialize(value, handleSerializer, visited) {
      const result = handleSerializer(value);
      if ("fallThrough" in result)
        value = result.fallThrough;
      else
        return result;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {v: "undefined"};
      if (Object.is(value, void 0))
        return {v: "undefined"};
      if (Object.is(value, null))
        return {v: "null"};
      if (Object.is(value, NaN))
        return {v: "NaN"};
      if (Object.is(value, Infinity))
        return {v: "Infinity"};
      if (Object.is(value, -Infinity))
        return {v: "-Infinity"};
      if (Object.is(value, -0))
        return {v: "-0"};
      if (typeof value === "boolean")
        return value;
      if (typeof value === "number")
        return value;
      if (typeof value === "string")
        return value;
      if (isError2(value)) {
        const error3 = value;
        if ("captureStackTrace" in global.Error) {
          return error3.stack || "";
        }
        return `${error3.name}: ${error3.message}
${error3.stack}`;
      }
      if (isDate(value))
        return {d: value.toJSON()};
      if (isRegExp(value))
        return {r: {p: value.source, f: value.flags}};
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serialize(value[i], handleSerializer, visited));
        visited.delete(value);
        return {a};
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value)) {
          let item;
          try {
            item = value[name];
          } catch (e) {
            continue;
          }
          if (name === "toJSON" && typeof item === "function")
            o.push({k: name, v: {o: []}});
          else
            o.push({k: name, v: serialize(item, handleSerializer, visited)});
        }
        visited.delete(value);
        return {o};
      }
    }
  }
});

// node_modules/playwright/lib/server/javascript.js
var require_javascript = __commonJS({
  "node_modules/playwright/lib/server/javascript.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.normalizeEvaluationExpression = exports2.parseUnserializableValue = exports2.evaluateExpressionAndWaitForSignals = exports2.evaluateExpression = exports2.evaluate = exports2.JSHandle = exports2.ExecutionContext = void 0;
    var utilityScriptSource = __importStar(require_utilityScriptSource());
    var utilityScriptSerializers_1 = require_utilityScriptSerializers();
    var instrumentation_1 = require_instrumentation();
    var ExecutionContext = class extends instrumentation_1.SdkObject {
      constructor(parent, delegate) {
        super(parent, "execution-context");
        this._delegate = delegate;
      }
      async waitForSignalsCreatedBy(action) {
        return action();
      }
      adoptIfNeeded(handle) {
        return null;
      }
      utilityScript() {
        if (!this._utilityScriptPromise) {
          const source = `
      (() => {
        ${utilityScriptSource.source}
        return new pwExport();
      })();`;
          this._utilityScriptPromise = this._delegate.rawEvaluateHandle(source).then((objectId) => new JSHandle(this, "object", objectId));
        }
        return this._utilityScriptPromise;
      }
      createHandle(remoteObject) {
        return this._delegate.createHandle(this, remoteObject);
      }
      async rawEvaluateJSON(expression) {
        return await this._delegate.rawEvaluateJSON(expression);
      }
      async doSlowMo() {
      }
    };
    exports2.ExecutionContext = ExecutionContext;
    var JSHandle = class extends instrumentation_1.SdkObject {
      constructor(context, type, objectId, value) {
        super(context, "handle");
        this._disposed = false;
        this._context = context;
        this._objectId = objectId;
        this._value = value;
        this._objectType = type;
        if (this._objectId)
          this._value = "JSHandle@" + this._objectType;
        this._preview = "JSHandle@" + String(this._objectId ? this._objectType : this._value);
      }
      callFunctionNoReply(func, arg) {
        this._context._delegate.rawCallFunctionNoReply(func, this, arg);
      }
      async evaluate(pageFunction, arg) {
        return evaluate(this._context, true, pageFunction, this, arg);
      }
      async evaluateHandle(pageFunction, arg) {
        return evaluate(this._context, false, pageFunction, this, arg);
      }
      async evaluateExpressionAndWaitForSignals(expression, isFunction, returnByValue, arg) {
        const value = await evaluateExpressionAndWaitForSignals(this._context, returnByValue, expression, isFunction, this, arg);
        await this._context.doSlowMo();
        return value;
      }
      async getProperty(propertyName) {
        const objectHandle = await this.evaluateHandle((object, propertyName2) => {
          const result2 = {__proto__: null};
          result2[propertyName2] = object[propertyName2];
          return result2;
        }, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName);
        objectHandle.dispose();
        return result;
      }
      async getProperties() {
        if (!this._objectId)
          return new Map();
        return this._context._delegate.getProperties(this._context, this._objectId);
      }
      rawValue() {
        return this._value;
      }
      async jsonValue() {
        if (!this._objectId)
          return this._value;
        const utilityScript = await this._context.utilityScript();
        const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
        return this._context._delegate.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);
      }
      asElement() {
        return null;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        if (this._objectId)
          this._context._delegate.releaseHandle(this._objectId).catch((e) => {
          });
      }
      toString() {
        return this._preview;
      }
      _setPreviewCallback(callback) {
        this._previewCallback = callback;
      }
      _setPreview(preview) {
        this._preview = preview;
        if (this._previewCallback)
          this._previewCallback(preview);
      }
    };
    exports2.JSHandle = JSHandle;
    async function evaluate(context, returnByValue, pageFunction, ...args) {
      return evaluateExpression(context, returnByValue, String(pageFunction), typeof pageFunction === "function", ...args);
    }
    exports2.evaluate = evaluate;
    async function evaluateExpression(context, returnByValue, expression, isFunction, ...args) {
      const utilityScript = await context.utilityScript();
      expression = normalizeEvaluationExpression(expression, isFunction);
      const handles = [];
      const toDispose = [];
      const pushHandle = (handle) => {
        handles.push(handle);
        return handles.length - 1;
      };
      args = args.map((arg) => utilityScriptSerializers_1.serializeAsCallArgument(arg, (handle) => {
        if (handle instanceof JSHandle) {
          if (!handle._objectId)
            return {fallThrough: handle._value};
          if (handle._disposed)
            throw new Error("JSHandle is disposed!");
          const adopted = context.adoptIfNeeded(handle);
          if (adopted === null)
            return {h: pushHandle(Promise.resolve(handle))};
          toDispose.push(adopted);
          return {h: pushHandle(adopted)};
        }
        return {fallThrough: handle};
      }));
      const utilityScriptObjectIds = [];
      for (const handle of await Promise.all(handles)) {
        if (handle._context !== context)
          throw new Error("JSHandles can be evaluated only in the context they were created!");
        utilityScriptObjectIds.push(handle._objectId);
      }
      const utilityScriptValues = [isFunction, returnByValue, expression, args.length, ...args];
      const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
      try {
        return await context._delegate.evaluateWithArguments(script, returnByValue, utilityScript, utilityScriptValues, utilityScriptObjectIds);
      } finally {
        toDispose.map((handlePromise) => handlePromise.then((handle) => handle.dispose()));
      }
    }
    exports2.evaluateExpression = evaluateExpression;
    async function evaluateExpressionAndWaitForSignals(context, returnByValue, expression, isFunction, ...args) {
      return await context.waitForSignalsCreatedBy(() => evaluateExpression(context, returnByValue, expression, isFunction, ...args));
    }
    exports2.evaluateExpressionAndWaitForSignals = evaluateExpressionAndWaitForSignals;
    function parseUnserializableValue(unserializableValue) {
      if (unserializableValue === "NaN")
        return NaN;
      if (unserializableValue === "Infinity")
        return Infinity;
      if (unserializableValue === "-Infinity")
        return -Infinity;
      if (unserializableValue === "-0")
        return -0;
    }
    exports2.parseUnserializableValue = parseUnserializableValue;
    function normalizeEvaluationExpression(expression, isFunction) {
      expression = expression.trim();
      if (isFunction) {
        try {
          new Function("(" + expression + ")");
        } catch (e1) {
          if (expression.startsWith("async "))
            expression = "async function " + expression.substring("async ".length);
          else
            expression = "function " + expression;
          try {
            new Function("(" + expression + ")");
          } catch (e2) {
            throw new Error("Passed function is not well-serializable!");
          }
        }
      }
      if (/^(async)?\s*function(\s|\()/.test(expression))
        expression = "(" + expression + ")";
      return expression;
    }
    exports2.normalizeEvaluationExpression = normalizeEvaluationExpression;
  }
});

// node_modules/playwright/lib/server/progress.js
var require_progress = __commonJS({
  "node_modules/playwright/lib/server/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ProgressController = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    var ProgressController = class {
      constructor(metadata, sdkObject) {
        this._forceAbort = () => {
        };
        this._cleanups = [];
        this._logName = "api";
        this._state = "before";
        this._deadline = 0;
        this._timeout = 0;
        this.metadata = metadata;
        this.sdkObject = sdkObject;
        this.instrumentation = sdkObject.instrumentation;
        this._forceAbortPromise = new Promise((resolve2, reject) => this._forceAbort = reject);
        this._forceAbortPromise.catch((e) => null);
      }
      setLogName(logName) {
        this._logName = logName;
      }
      async run(task, timeout) {
        if (timeout) {
          this._timeout = timeout;
          this._deadline = timeout ? utils_1.monotonicTime() + timeout : 0;
        }
        utils_1.assert(this._state === "before");
        this._state = "running";
        const progress = {
          log: (message) => {
            if (this._state === "running")
              this.metadata.log.push(message);
            this.instrumentation.onCallLog(this._logName, message, this.sdkObject, this.metadata);
          },
          timeUntilDeadline: () => this._deadline ? this._deadline - utils_1.monotonicTime() : 2147483647,
          isRunning: () => this._state === "running",
          cleanupWhenAborted: (cleanup) => {
            if (this._state === "running")
              this._cleanups.push(cleanup);
            else
              runCleanup(cleanup);
          },
          throwIfAborted: () => {
            if (this._state === "aborted")
              throw new AbortedError();
          },
          beforeInputAction: async (element) => {
            await this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);
          },
          metadata: this.metadata
        };
        const timeoutError = new errors_1.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
        const timer = setTimeout(() => this._forceAbort(timeoutError), progress.timeUntilDeadline());
        try {
          const promise = task(progress);
          const result = await Promise.race([promise, this._forceAbortPromise]);
          this._state = "finished";
          return result;
        } catch (e) {
          this._state = "aborted";
          await Promise.all(this._cleanups.splice(0).map(runCleanup));
          throw e;
        } finally {
          clearTimeout(timer);
        }
      }
    };
    exports2.ProgressController = ProgressController;
    async function runCleanup(cleanup) {
      try {
        await cleanup();
      } catch (e) {
      }
    }
    var AbortedError = class extends Error {
    };
  }
});

// node_modules/playwright/lib/server/dom.js
var require_dom = __commonJS({
  "node_modules/playwright/lib/server/dom.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.elementStateTask = exports2.getAttributeTask = exports2.innerHTMLTask = exports2.innerTextTask = exports2.textContentTask = exports2.dispatchEventTask = exports2.waitForSelectorTask = exports2.assertDone = exports2.throwRetargetableDOMError = exports2.throwFatalDOMError = exports2.InjectedScriptPollHandler = exports2.ElementHandle = exports2.FrameExecutionContext = void 0;
    var utils_1 = require_utils();
    var injectedScriptSource = __importStar(require_injectedScriptSource());
    var js = __importStar(require_javascript());
    var progress_1 = require_progress();
    var FrameExecutionContext = class extends js.ExecutionContext {
      constructor(delegate, frame, world) {
        super(frame, delegate);
        this.frame = frame;
        this.world = world;
      }
      async waitForSignalsCreatedBy(action) {
        return this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, action);
      }
      adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
          return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
      }
      async evaluate(pageFunction, arg) {
        return js.evaluate(this, true, pageFunction, arg);
      }
      async evaluateHandle(pageFunction, arg) {
        return js.evaluate(this, false, pageFunction, arg);
      }
      async evaluateExpression(expression, isFunction, arg) {
        return js.evaluateExpression(this, true, expression, isFunction, arg);
      }
      async evaluateAndWaitForSignals(pageFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, async () => {
          return this.evaluate(pageFunction, arg);
        });
      }
      async evaluateExpressionAndWaitForSignals(expression, isFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, async () => {
          return this.evaluateExpression(expression, isFunction, arg);
        });
      }
      async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg) {
        return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, async () => {
          return js.evaluateExpression(this, false, expression, isFunction, arg);
        });
      }
      createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
          return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
      }
      injectedScript() {
        if (!this._injectedScriptPromise) {
          const custom = [];
          for (const [name, {source: source2}] of this.frame._page.selectors._engines)
            custom.push(`{ name: '${name}', engine: (${source2}) }`);
          const source = `
        (() => {
        ${injectedScriptSource.source}
        return new pwExport(
          ${this.frame._page._delegate.rafCountForStablePosition()},
          ${!!process.env.PWTEST_USE_TIMEOUT_FOR_RAF},
          [${custom.join(",\n")}]
        );
        })();
      `;
          this._injectedScriptPromise = this._delegate.rawEvaluateHandle(source).then((objectId) => new js.JSHandle(this, "object", objectId));
        }
        return this._injectedScriptPromise;
      }
      async doSlowMo() {
        return this.frame._page._doSlowMo();
      }
    };
    exports2.FrameExecutionContext = FrameExecutionContext;
    var ElementHandle = class extends js.JSHandle {
      constructor(context, objectId) {
        super(context, "node", objectId);
        this._objectId = objectId;
        this._context = context;
        this._page = context.frame._page;
        this._initializePreview().catch((e) => {
        });
      }
      async _initializePreview() {
        const utility = await this._context.injectedScript();
        this._setPreview(await utility.evaluate((injected, e) => "JSHandle@" + injected.previewNode(e), this));
      }
      asElement() {
        return this;
      }
      async _evaluateInMainAndWaitForSignals(pageFunction, arg) {
        const main = await this._context.frame._mainContext();
        return main.evaluateAndWaitForSignals(pageFunction, [await main.injectedScript(), this, arg]);
      }
      async evaluateInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);
      }
      async evaluateHandleInUtility(pageFunction, arg) {
        const utility = await this._context.frame._utilityContext();
        return utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
      }
      async ownerFrame() {
        const frameId = await this._page._delegate.getOwnerFrame(this);
        if (!frameId)
          return null;
        const frame = this._page._frameManager.frame(frameId);
        if (frame)
          return frame;
        for (const page of this._page._browserContext.pages()) {
          const frame2 = page._frameManager.frame(frameId);
          if (frame2)
            return frame2;
        }
        return null;
      }
      async contentFrame() {
        const isFrameElement = await this.evaluateInUtility(([injected, node]) => node && (node.nodeName === "IFRAME" || node.nodeName === "FRAME"), {});
        if (!isFrameElement)
          return null;
        return this._page._delegate.getContentFrame(this);
      }
      async getAttribute(name) {
        return throwFatalDOMError(await this.evaluateInUtility(([injeced, node, name2]) => {
          if (node.nodeType !== Node.ELEMENT_NODE)
            return "error:notelement";
          const element = node;
          return {value: element.getAttribute(name2)};
        }, name)).value;
      }
      async textContent() {
        return this.evaluateInUtility(([injected, node]) => node.textContent, {});
      }
      async innerText() {
        return throwFatalDOMError(await this.evaluateInUtility(([injected, node]) => {
          if (node.nodeType !== Node.ELEMENT_NODE)
            return "error:notelement";
          if (node.namespaceURI !== "http://www.w3.org/1999/xhtml")
            return "error:nothtmlelement";
          const element = node;
          return {value: element.innerText};
        }, {})).value;
      }
      async innerHTML() {
        return throwFatalDOMError(await this.evaluateInUtility(([injected, node]) => {
          if (node.nodeType !== Node.ELEMENT_NODE)
            return "error:notelement";
          const element = node;
          return {value: element.innerHTML};
        }, {})).value;
      }
      async dispatchEvent(type, eventInit = {}) {
        await this._evaluateInMainAndWaitForSignals(([injected, node, {type: type2, eventInit: eventInit2}]) => injected.dispatchEvent(node, type2, eventInit2), {type, eventInit});
        await this._page._doSlowMo();
      }
      async _scrollRectIntoViewIfNeeded(rect) {
        return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
      }
      async _waitAndScrollIntoViewIfNeeded(progress) {
        while (progress.isRunning()) {
          assertDone(throwRetargetableDOMError(await this._waitForDisplayedAtStablePosition(progress, false)));
          progress.throwIfAborted();
          const result = throwRetargetableDOMError(await this._scrollRectIntoViewIfNeeded());
          if (result === "error:notvisible")
            continue;
          assertDone(result);
          return;
        }
      }
      async scrollIntoViewIfNeeded(metadata, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this._waitAndScrollIntoViewIfNeeded(progress), this._page._timeoutSettings.timeout(options2));
      }
      async _clickablePoint() {
        const intersectQuadWithViewport = (quad) => {
          return quad.map((point) => ({
            x: Math.min(Math.max(point.x, 0), metrics.width),
            y: Math.min(Math.max(point.y, 0), metrics.height)
          }));
        };
        const computeQuadArea = (quad) => {
          let area = 0;
          for (let i = 0; i < quad.length; ++i) {
            const p1 = quad[i];
            const p2 = quad[(i + 1) % quad.length];
            area += (p1.x * p2.y - p2.x * p1.y) / 2;
          }
          return Math.abs(area);
        };
        const [quads, metrics] = await Promise.all([
          this._page._delegate.getContentQuads(this),
          this._page.mainFrame()._utilityContext().then((utility) => utility.evaluate(() => ({width: innerWidth, height: innerHeight})))
        ]);
        if (!quads || !quads.length)
          return "error:notvisible";
        const filtered = quads.map((quad) => intersectQuadWithViewport(quad)).filter((quad) => computeQuadArea(quad) > 0.99);
        if (!filtered.length)
          return "error:notinviewport";
        const result = {x: 0, y: 0};
        for (const point of filtered[0]) {
          result.x += point.x / 4;
          result.y += point.y / 4;
        }
        compensateHalfIntegerRoundingError(result);
        return result;
      }
      async _offsetPoint(offset) {
        const [box, border] = await Promise.all([
          this.boundingBox(),
          this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch((e) => {
          })
        ]);
        if (!box || !border)
          return "error:notvisible";
        return {
          x: box.x + border.left + offset.x,
          y: box.y + border.top + offset.y
        };
      }
      async _retryPointerAction(progress, actionName, waitForEnabled, action, options2) {
        let retry = 0;
        const waitTime = [0, 20, 100, 100, 500];
        const scrollOptions = [
          void 0,
          {block: "end", inline: "end"},
          {block: "center", inline: "center"},
          {block: "start", inline: "start"}
        ];
        while (progress.isRunning()) {
          if (retry) {
            progress.log(`retrying ${actionName} action${options2.trial ? " (trial run)" : ""}, attempt #${retry}`);
            const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];
            if (timeout) {
              progress.log(`  waiting ${timeout}ms`);
              await this.evaluateInUtility(([injected, node, timeout2]) => new Promise((f) => setTimeout(f, timeout2)), timeout);
            }
          } else {
            progress.log(`attempting ${actionName} action${options2.trial ? " (trial run)" : ""}`);
          }
          const forceScrollOptions = scrollOptions[retry % scrollOptions.length];
          const result = await this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options2);
          ++retry;
          if (result === "error:notvisible") {
            if (options2.force)
              throw new Error("Element is not visible");
            progress.log("  element is not visible");
            continue;
          }
          if (result === "error:notinviewport") {
            if (options2.force)
              throw new Error("Element is outside of the viewport");
            progress.log("  element is outside of the viewport");
            continue;
          }
          if (typeof result === "object" && "hitTargetDescription" in result) {
            if (options2.force)
              throw new Error(`Element does not receive pointer events, ${result.hitTargetDescription} intercepts them`);
            progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);
            continue;
          }
          return result;
        }
        return "done";
      }
      async _performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options2) {
        const {force = false, position} = options2;
        if (options2.__testHookBeforeStable)
          await options2.__testHookBeforeStable();
        if (!force) {
          const result = await this._waitForDisplayedAtStablePosition(progress, waitForEnabled);
          if (result !== "done")
            return result;
        }
        if (options2.__testHookAfterStable)
          await options2.__testHookAfterStable();
        progress.log("  scrolling into view if needed");
        progress.throwIfAborted();
        if (forceScrollOptions) {
          await this.evaluateInUtility(([injected, node, options3]) => {
            if (node.nodeType === 1)
              node.scrollIntoView(options3);
          }, forceScrollOptions);
        } else {
          const scrolled = await this._scrollRectIntoViewIfNeeded(position ? {x: position.x, y: position.y, width: 0, height: 0} : void 0);
          if (scrolled !== "done")
            return scrolled;
        }
        progress.log("  done scrolling");
        const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();
        if (typeof maybePoint === "string")
          return maybePoint;
        const point = roundPoint(maybePoint);
        if (!force) {
          if (options2.__testHookBeforeHitTarget)
            await options2.__testHookBeforeHitTarget();
          progress.log(`  checking that element receives pointer events at (${point.x},${point.y})`);
          const hitTargetResult = await this._checkHitTargetAt(point);
          if (hitTargetResult !== "done")
            return hitTargetResult;
          progress.log(`  element does receive pointer events`);
        }
        progress.metadata.point = point;
        if (options2.trial) {
          progress.log(`  trial ${actionName} has finished`);
          return "done";
        }
        await progress.beforeInputAction(this);
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          if (options2.__testHookBeforePointerAction)
            await options2.__testHookBeforePointerAction();
          progress.throwIfAborted();
          let restoreModifiers;
          if (options2 && options2.modifiers)
            restoreModifiers = await this._page.keyboard._ensureModifiers(options2.modifiers);
          progress.log(`  performing ${actionName} action`);
          await action(point);
          progress.log(`  ${actionName} action done`);
          progress.log("  waiting for scheduled navigations to finish");
          if (options2.__testHookAfterPointerAction)
            await options2.__testHookAfterPointerAction();
          if (restoreModifiers)
            await this._page.keyboard._ensureModifiers(restoreModifiers);
        }, "input");
        progress.log("  navigations have finished");
        return "done";
      }
      async hover(metadata, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._hover(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _hover(progress, options2) {
        return this._retryPointerAction(progress, "hover", false, (point) => this._page.mouse.move(point.x, point.y), options2);
      }
      async click(metadata, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._click(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _click(progress, options2) {
        return this._retryPointerAction(progress, "click", true, (point) => this._page.mouse.click(point.x, point.y, options2), options2);
      }
      async dblclick(metadata, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._dblclick(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _dblclick(progress, options2) {
        return this._retryPointerAction(progress, "dblclick", true, (point) => this._page.mouse.dblclick(point.x, point.y, options2), options2);
      }
      async tap(metadata, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._tap(progress, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      _tap(progress, options2) {
        return this._retryPointerAction(progress, "tap", true, (point) => this._page.touchscreen.tap(point.x, point.y), options2);
      }
      async selectOption(metadata, elements, values, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._selectOption(progress, elements, values, options2);
          return throwRetargetableDOMError(result);
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _selectOption(progress, elements, values, options2) {
        const optionsToSelect = [...elements, ...values];
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          progress.throwIfAborted();
          progress.log("  selecting specified option(s)");
          const poll = await this.evaluateHandleInUtility(([injected, node, optionsToSelect2]) => {
            return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled"], injected.selectOptions.bind(injected, optionsToSelect2));
          }, optionsToSelect);
          const pollHandler = new InjectedScriptPollHandler(progress, poll);
          const result = throwFatalDOMError(await pollHandler.finish());
          await this._page._doSlowMo();
          return result;
        });
      }
      async fill(metadata, value, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._fill(progress, value, options2);
          assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _fill(progress, value, options2) {
        progress.log(`elementHandle.fill("${value}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          progress.log("  waiting for element to be visible, enabled and editable");
          const poll = await this.evaluateHandleInUtility(([injected, node, value2]) => {
            return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled", "editable"], injected.fill.bind(injected, value2));
          }, value);
          const pollHandler = new InjectedScriptPollHandler(progress, poll);
          const filled = throwFatalDOMError(await pollHandler.finish());
          progress.throwIfAborted();
          if (filled === "error:notconnected")
            return filled;
          progress.log("  element is visible, enabled and editable");
          if (filled === "needsinput") {
            progress.throwIfAborted();
            if (value)
              await this._page.keyboard.insertText(value);
            else
              await this._page.keyboard.press("Delete");
          } else {
            assertDone(filled);
          }
          return "done";
        }, "input");
      }
      async selectText(metadata, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          progress.throwIfAborted();
          const poll = await this.evaluateHandleInUtility(([injected, node]) => {
            return injected.waitForElementStatesAndPerformAction(node, ["visible"], injected.selectText.bind(injected));
          }, {});
          const pollHandler = new InjectedScriptPollHandler(progress, poll);
          const result = throwFatalDOMError(await pollHandler.finish());
          assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async setInputFiles(metadata, files, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._setInputFiles(progress, files, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _setInputFiles(progress, files, options2) {
        const multiple = throwFatalDOMError(await this.evaluateInUtility(([injected, node]) => {
          if (node.nodeType !== Node.ELEMENT_NODE || node.tagName !== "INPUT")
            return "error:notinput";
          const input = node;
          return input.multiple;
        }, {}));
        if (typeof multiple === "string")
          return multiple;
        utils_1.assert(multiple || files.length <= 1, "Non-multiple file input can only accept single file!");
        await progress.beforeInputAction(this);
        await this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          progress.throwIfAborted();
          await this._page._delegate.setInputFiles(this, files);
        });
        await this._page._doSlowMo();
        return "done";
      }
      async focus(metadata) {
        const controller = new progress_1.ProgressController(metadata, this);
        await controller.run(async (progress) => {
          const result = await this._focus(progress);
          await this._page._doSlowMo();
          return assertDone(throwRetargetableDOMError(result));
        }, 0);
      }
      async _focus(progress, resetSelectionIfNotFocused) {
        progress.throwIfAborted();
        const result = await this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused2]) => injected.focusNode(node, resetSelectionIfNotFocused2), resetSelectionIfNotFocused);
        return throwFatalDOMError(result);
      }
      async type(metadata, text, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._type(progress, text, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _type(progress, text, options2) {
        progress.log(`elementHandle.type("${text}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          const result = await this._focus(progress, true);
          if (result !== "done")
            return result;
          progress.throwIfAborted();
          await this._page.keyboard.type(text, options2);
          return "done";
        }, "input");
      }
      async press(metadata, key, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._press(progress, key, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _press(progress, key, options2) {
        progress.log(`elementHandle.press("${key}")`);
        await progress.beforeInputAction(this);
        return this._page._frameManager.waitForSignalsCreatedBy(progress, options2.noWaitAfter, async () => {
          const result = await this._focus(progress, true);
          if (result !== "done")
            return result;
          progress.throwIfAborted();
          await this._page.keyboard.press(key, options2);
          return "done";
        }, "input");
      }
      async check(metadata, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._setChecked(progress, true, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async uncheck(metadata, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          const result = await this._setChecked(progress, false, options2);
          return assertDone(throwRetargetableDOMError(result));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _setChecked(progress, state, options2) {
        const isChecked = async () => {
          const result2 = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, "checked"), {});
          return throwRetargetableDOMError(throwFatalDOMError(result2));
        };
        if (await isChecked() === state)
          return "done";
        const result = await this._click(progress, options2);
        if (result !== "done")
          return result;
        if (options2.trial)
          return "done";
        if (await isChecked() !== state)
          throw new Error("Clicking the checkbox did not change its state");
        return "done";
      }
      async boundingBox() {
        return this._page._delegate.getBoundingBox(this);
      }
      async screenshot(metadata, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this._page._screenshotter.screenshotElement(progress, this, options2), this._page._timeoutSettings.timeout(options2));
      }
      async $(selector) {
        return this._page.selectors._query(this._context.frame, selector, this);
      }
      async $$(selector) {
        return this._page.selectors._queryAll(this._context.frame, selector, this, true);
      }
      async evalOnSelectorAndWaitForSignals(selector, expression, isFunction, arg) {
        const handle = await this._page.selectors._query(this._context.frame, selector, this);
        if (!handle)
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        handle.dispose();
        return result;
      }
      async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        const arrayHandle = await this._page.selectors._queryArray(this._context.frame, selector, this);
        const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        arrayHandle.dispose();
        return result;
      }
      async isVisible() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, "visible"), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
      }
      async isHidden() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, "hidden"), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
      }
      async isEnabled() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, "enabled"), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
      }
      async isDisabled() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, "disabled"), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
      }
      async isEditable() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, "editable"), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
      }
      async isChecked() {
        const result = await this.evaluateInUtility(([injected, node]) => injected.checkElementState(node, "checked"), {});
        return throwRetargetableDOMError(throwFatalDOMError(result));
      }
      async waitForElementState(metadata, state, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          progress.log(`  waiting for element to be ${state}`);
          const poll = await this.evaluateHandleInUtility(([injected, node, state2]) => {
            return injected.waitForElementStatesAndPerformAction(node, [state2], () => "done");
          }, state);
          const pollHandler = new InjectedScriptPollHandler(progress, poll);
          assertDone(throwRetargetableDOMError(throwFatalDOMError(await pollHandler.finish())));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async waitForSelector(metadata, selector, options2 = {}) {
        const {state = "visible"} = options2;
        if (!["attached", "detached", "visible", "hidden"].includes(state))
          throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
        const info = this._page.selectors._parseSelector(selector);
        const task = waitForSelectorTask(info, state, this);
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          progress.log(`waiting for selector "${selector}"${state === "attached" ? "" : " to be " + state}`);
          const context = await this._context.frame._context(info.world);
          const injected = await context.injectedScript();
          const pollHandler = new InjectedScriptPollHandler(progress, await task(injected));
          const result = await pollHandler.finishHandle();
          if (!result.asElement()) {
            result.dispose();
            return null;
          }
          const handle = result.asElement();
          return handle._adoptTo(await this._context.frame._mainContext());
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _adoptTo(context) {
        if (this._context !== context) {
          const adopted = await this._page._delegate.adoptElementHandle(this, context);
          this.dispose();
          return adopted;
        }
        return this;
      }
      async _waitForDisplayedAtStablePosition(progress, waitForEnabled) {
        if (waitForEnabled)
          progress.log(`  waiting for element to be visible, enabled and stable`);
        else
          progress.log(`  waiting for element to be visible and stable`);
        const poll = this.evaluateHandleInUtility(([injected, node, waitForEnabled2]) => {
          return injected.waitForElementStatesAndPerformAction(node, waitForEnabled2 ? ["visible", "stable", "enabled"] : ["visible", "stable"], () => "done");
        }, waitForEnabled);
        const pollHandler = new InjectedScriptPollHandler(progress, await poll);
        const result = await pollHandler.finish();
        if (waitForEnabled)
          progress.log("  element is visible, enabled and stable");
        else
          progress.log("  element is visible and stable");
        return throwFatalDOMError(result);
      }
      async _checkHitTargetAt(point) {
        const frame = await this.ownerFrame();
        if (frame && frame.parentFrame()) {
          const element = await frame.frameElement();
          const box = await element.boundingBox();
          if (!box)
            return "error:notconnected";
          point = {x: point.x - box.x, y: point.y - box.y};
        }
        return this.evaluateInUtility(([injected, node, point2]) => injected.checkHitTargetAt(node, point2), point);
      }
    };
    exports2.ElementHandle = ElementHandle;
    var InjectedScriptPollHandler = class {
      constructor(progress, poll) {
        this._progress = progress;
        this._poll = poll;
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs();
      }
      async _streamLogs() {
        while (this._poll && this._progress.isRunning()) {
          const messages = await this._poll.evaluate((poll) => poll.takeNextLogs()).catch((e) => []);
          if (!this._poll || !this._progress.isRunning())
            return;
          for (const message of messages)
            this._progress.log(message);
        }
      }
      async finishHandle() {
        try {
          const result = await this._poll.evaluateHandle((poll) => poll.run());
          await this._finishInternal();
          return result;
        } finally {
          await this.cancel();
        }
      }
      async finish() {
        try {
          const result = await this._poll.evaluate((poll) => poll.run());
          await this._finishInternal();
          return result;
        } finally {
          await this.cancel();
        }
      }
      async _finishInternal() {
        if (!this._poll)
          return;
        const messages = await this._poll.evaluate((poll) => poll.takeLastLogs()).catch((e) => []);
        for (const message of messages)
          this._progress.log(message);
      }
      async cancel() {
        if (!this._poll)
          return;
        const copy = this._poll;
        this._poll = null;
        await copy.evaluate((p) => p.cancel()).catch((e) => {
        });
        copy.dispose();
      }
    };
    exports2.InjectedScriptPollHandler = InjectedScriptPollHandler;
    function throwFatalDOMError(result) {
      if (result === "error:notelement")
        throw new Error("Node is not an element");
      if (result === "error:nothtmlelement")
        throw new Error("Not an HTMLElement");
      if (result === "error:notfillableelement")
        throw new Error("Element is not an <input>, <textarea> or [contenteditable] element");
      if (result === "error:notfillableinputtype")
        throw new Error("Input of this type cannot be filled");
      if (result === "error:notfillablenumberinput")
        throw new Error("Cannot type text into input[type=number]");
      if (result === "error:notvaliddate")
        throw new Error(`Malformed value`);
      if (result === "error:notinput")
        throw new Error("Node is not an HTMLInputElement");
      if (result === "error:notselect")
        throw new Error("Element is not a <select> element.");
      if (result === "error:notcheckbox")
        throw new Error("Not a checkbox or radio button");
      return result;
    }
    exports2.throwFatalDOMError = throwFatalDOMError;
    function throwRetargetableDOMError(result) {
      if (result === "error:notconnected")
        throw new Error("Element is not attached to the DOM");
      return result;
    }
    exports2.throwRetargetableDOMError = throwRetargetableDOMError;
    function assertDone(result) {
    }
    exports2.assertDone = assertDone;
    function roundPoint(point) {
      return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100
      };
    }
    function compensateHalfIntegerRoundingError(point) {
      const remainderX = point.x - Math.floor(point.x);
      if (remainderX > 0.49 && remainderX < 0.51)
        point.x -= 0.02;
      const remainderY = point.y - Math.floor(point.y);
      if (remainderY > 0.49 && remainderY < 0.51)
        point.y -= 0.02;
    }
    function waitForSelectorTask(selector, state, root) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, {parsed, state: state2, root: root2}) => {
        let lastElement;
        return injected.pollRaf((progress, continuePolling) => {
          const element = injected.querySelector(parsed, root2 || document);
          const visible = element ? injected.isVisible(element) : false;
          if (lastElement !== element) {
            lastElement = element;
            if (!element)
              progress.log(`  selector did not resolve to any element`);
            else
              progress.log(`  selector resolved to ${visible ? "visible" : "hidden"} ${injected.previewNode(element)}`);
          }
          switch (state2) {
            case "attached":
              return element ? element : continuePolling;
            case "detached":
              return !element ? void 0 : continuePolling;
            case "visible":
              return visible ? element : continuePolling;
            case "hidden":
              return !visible ? void 0 : continuePolling;
          }
        });
      }, {parsed: selector.parsed, state, root});
    }
    exports2.waitForSelectorTask = waitForSelectorTask;
    function dispatchEventTask(selector, type, eventInit) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, {parsed, type: type2, eventInit: eventInit2}) => {
        return injected.pollRaf((progress, continuePolling) => {
          const element = injected.querySelector(parsed, document);
          if (!element)
            return continuePolling;
          progress.log(`  selector resolved to ${injected.previewNode(element)}`);
          injected.dispatchEvent(element, type2, eventInit2);
        });
      }, {parsed: selector.parsed, type, eventInit});
    }
    exports2.dispatchEventTask = dispatchEventTask;
    function textContentTask(selector) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
          const element = injected.querySelector(parsed, document);
          if (!element)
            return continuePolling;
          progress.log(`  selector resolved to ${injected.previewNode(element)}`);
          return element.textContent;
        });
      }, selector.parsed);
    }
    exports2.textContentTask = textContentTask;
    function innerTextTask(selector) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
          const element = injected.querySelector(parsed, document);
          if (!element)
            return continuePolling;
          progress.log(`  selector resolved to ${injected.previewNode(element)}`);
          if (element.namespaceURI !== "http://www.w3.org/1999/xhtml")
            return "error:nothtmlelement";
          return {innerText: element.innerText};
        });
      }, selector.parsed);
    }
    exports2.innerTextTask = innerTextTask;
    function innerHTMLTask(selector) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, parsed) => {
        return injected.pollRaf((progress, continuePolling) => {
          const element = injected.querySelector(parsed, document);
          if (!element)
            return continuePolling;
          progress.log(`  selector resolved to ${injected.previewNode(element)}`);
          return element.innerHTML;
        });
      }, selector.parsed);
    }
    exports2.innerHTMLTask = innerHTMLTask;
    function getAttributeTask(selector, name) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, {parsed, name: name2}) => {
        return injected.pollRaf((progress, continuePolling) => {
          const element = injected.querySelector(parsed, document);
          if (!element)
            return continuePolling;
          progress.log(`  selector resolved to ${injected.previewNode(element)}`);
          return element.getAttribute(name2);
        });
      }, {parsed: selector.parsed, name});
    }
    exports2.getAttributeTask = getAttributeTask;
    function elementStateTask(selector, state) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, {parsed, state: state2}) => {
        return injected.pollRaf((progress, continuePolling) => {
          const element = injected.querySelector(parsed, document);
          if (!element)
            return continuePolling;
          progress.log(`  selector resolved to ${injected.previewNode(element)}`);
          return injected.checkElementState(element, state2);
        });
      }, {parsed: selector.parsed, state});
    }
    exports2.elementStateTask = elementStateTask;
  }
});

// node_modules/playwright/lib/server/types.js
var require_types = __commonJS({
  "node_modules/playwright/lib/server/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.colorSchemes = exports2.mediaTypes = exports2.kLifecycleEvents = void 0;
    exports2.kLifecycleEvents = new Set(["load", "domcontentloaded", "networkidle"]);
    exports2.mediaTypes = new Set(["screen", "print"]);
    exports2.colorSchemes = new Set(["dark", "light", "no-preference"]);
  }
});

// node_modules/playwright/lib/server/frames.js
var require_frames = __commonJS({
  "node_modules/playwright/lib/server/frames.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Frame = exports2.FrameManager = void 0;
    var dom = __importStar(require_dom());
    var helper_1 = require_helper();
    var js = __importStar(require_javascript());
    var network = __importStar(require_network());
    var page_1 = require_page();
    var types2 = __importStar(require_types());
    var progress_1 = require_progress();
    var utils_1 = require_utils();
    var debugLogger_1 = require_debugLogger();
    var instrumentation_1 = require_instrumentation();
    var FrameManager = class {
      constructor(page) {
        this._frames = new Map();
        this._consoleMessageTags = new Map();
        this._signalBarriers = new Set();
        this._webSockets = new Map();
        this._responses = [];
        this._page = page;
        this._mainFrame = void 0;
      }
      dispose() {
        for (const frame of this._frames.values())
          frame._stopNetworkIdleTimer();
      }
      mainFrame() {
        return this._mainFrame;
      }
      frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
          frames.push(frame);
          for (const subframe of frame.childFrames())
            collect(subframe);
        }
      }
      frame(frameId) {
        return this._frames.get(frameId) || null;
      }
      frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
          if (this._mainFrame) {
            this._frames.delete(this._mainFrame._id);
            this._mainFrame._id = frameId;
          } else {
            utils_1.assert(!this._frames.has(frameId));
            this._mainFrame = new Frame(this._page, frameId, parentFrame);
          }
          this._frames.set(frameId, this._mainFrame);
          return this._mainFrame;
        } else {
          utils_1.assert(!this._frames.has(frameId));
          const frame = new Frame(this._page, frameId, parentFrame);
          this._frames.set(frameId, frame);
          this._page.emit(page_1.Page.Events.FrameAttached, frame);
          return frame;
        }
      }
      async waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {
        if (noWaitAfter)
          return action();
        const barrier = new SignalBarrier(progress);
        this._signalBarriers.add(barrier);
        if (progress)
          progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
        const result = await action();
        if (source === "input")
          await this._page._delegate.inputActionEpilogue();
        await barrier.waitFor();
        this._signalBarriers.delete(barrier);
        await new Promise(utils_1.makeWaitForNextTask());
        return result;
      }
      frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.retain();
      }
      frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.release();
      }
      frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        for (const barrier of this._signalBarriers)
          barrier.addFrameNavigation(frame);
        if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
          return;
        }
        frame.setPendingDocument({documentId, request: void 0});
      }
      frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        this.clearWebSockets(frame);
        frame._url = url;
        frame._name = name;
        let keepPending;
        const pendingDocument = frame.pendingDocument();
        if (pendingDocument) {
          if (pendingDocument.documentId === void 0) {
            pendingDocument.documentId = documentId;
          }
          if (pendingDocument.documentId === documentId) {
            frame._currentDocument = pendingDocument;
          } else {
            keepPending = pendingDocument;
            frame._currentDocument = {documentId, request: void 0};
          }
          frame.setPendingDocument(void 0);
        } else {
          frame._currentDocument = {documentId, request: void 0};
        }
        frame._onClearLifecycle();
        const navigationEvent = {url, name, newDocument: frame._currentDocument};
        frame.emit(Frame.Events.Navigation, navigationEvent);
        this._responses.length = 0;
        if (!initial) {
          debugLogger_1.debugLogger.log("api", `  navigated to "${url}"`);
          this._page.frameNavigatedToNewDocument(frame);
        }
        frame.setPendingDocument(keepPending);
      }
      frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._url = url;
        const navigationEvent = {url, name: frame._name};
        frame.emit(Frame.Events.Navigation, navigationEvent);
        debugLogger_1.debugLogger.log("api", `  navigated to "${url}"`);
      }
      frameAbortedNavigation(frameId, errorText, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame || !frame.pendingDocument())
          return;
        if (documentId !== void 0 && frame.pendingDocument().documentId !== documentId)
          return;
        const navigationEvent = {
          url: frame._url,
          name: frame._name,
          newDocument: frame.pendingDocument(),
          error: new Error(errorText)
        };
        frame.setPendingDocument(void 0);
        frame.emit(Frame.Events.Navigation, navigationEvent);
      }
      frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
          this._removeFramesRecursively(frame);
      }
      frameStoppedLoading(frameId) {
        this.frameLifecycleEvent(frameId, "domcontentloaded");
        this.frameLifecycleEvent(frameId, "load");
      }
      frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (frame)
          frame._onLifecycleEvent(event);
      }
      requestStarted(request) {
        const frame = request.frame();
        this._inflightRequestStarted(request);
        if (request._documentId)
          frame.setPendingDocument({documentId: request._documentId, request});
        if (request._isFavicon) {
          const route = request._route();
          if (route)
            route.continue();
          return;
        }
        this._page._requestStarted(request);
      }
      requestReceivedResponse(response) {
        if (response.request()._isFavicon)
          return;
        this._responses.push(response);
        this._page.emit(page_1.Page.Events.Response, response);
      }
      requestFinished(request) {
        this._inflightRequestFinished(request);
        if (!request._isFavicon)
          this._page.emit(page_1.Page.Events.RequestFinished, request);
      }
      requestFailed(request, canceled) {
        const frame = request.frame();
        this._inflightRequestFinished(request);
        if (frame.pendingDocument() && frame.pendingDocument().request === request) {
          let errorText = request.failure().errorText;
          if (canceled)
            errorText += "; maybe frame was detached?";
          this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
        }
        if (!request._isFavicon)
          this._page.emit(page_1.Page.Events.RequestFailed, request);
      }
      removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
          this._removeFramesRecursively(child);
      }
      _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        if (!this._page.isClosed())
          this._page.emit(page_1.Page.Events.FrameDetached, frame);
      }
      _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        if (!frame._inflightRequests.has(request))
          return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
          frame._startNetworkIdleTimer();
      }
      _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
          frame._stopNetworkIdleTimer();
      }
      interceptConsoleMessage(message) {
        if (message.type() !== "debug")
          return false;
        const tag = message.text();
        const handler2 = this._consoleMessageTags.get(tag);
        if (!handler2)
          return false;
        this._consoleMessageTags.delete(tag);
        handler2();
        return true;
      }
      clearWebSockets(frame) {
        if (frame.parentFrame())
          return;
        this._webSockets.clear();
      }
      onWebSocketCreated(requestId, url) {
        const ws = new network.WebSocket(this._page, url);
        this._webSockets.set(requestId, ws);
      }
      onWebSocketRequest(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          this._page.emit(page_1.Page.Events.WebSocket, ws);
      }
      onWebSocketResponse(requestId, status, statusText) {
        const ws = this._webSockets.get(requestId);
        if (status < 400)
          return;
        if (ws)
          ws.error(`${statusText}: ${status}`);
      }
      onWebSocketFrameSent(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameSent(opcode, data);
      }
      webSocketFrameReceived(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameReceived(opcode, data);
      }
      webSocketClosed(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.closed();
        this._webSockets.delete(requestId);
      }
      webSocketError(requestId, errorMessage) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.error(errorMessage);
      }
    };
    exports2.FrameManager = FrameManager;
    var Frame = class extends instrumentation_1.SdkObject {
      constructor(page, id, parentFrame) {
        super(page, "frame");
        this._firedLifecycleEvents = new Set();
        this._subtreeLifecycleEvents = new Set();
        this._url = "";
        this._detached = false;
        this._contextData = new Map();
        this._childFrames = new Set();
        this._name = "";
        this._inflightRequests = new Set();
        this._setContentCounter = 0;
        this._detachedCallback = () => {
        };
        this._nonStallingEvaluations = new Set();
        this.attribution.frame = this;
        this._id = id;
        this._page = page;
        this._parentFrame = parentFrame;
        this._currentDocument = {documentId: void 0, request: void 0};
        this._detachedPromise = new Promise((x) => this._detachedCallback = x);
        this._contextData.set("main", {contextPromise: new Promise(() => {
        }), contextResolveCallback: () => {
        }, context: null, rerunnableTasks: new Set()});
        this._contextData.set("utility", {contextPromise: new Promise(() => {
        }), contextResolveCallback: () => {
        }, context: null, rerunnableTasks: new Set()});
        this._setContext("main", null);
        this._setContext("utility", null);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
      }
      _onLifecycleEvent(event) {
        if (this._firedLifecycleEvents.has(event))
          return;
        this._firedLifecycleEvents.add(event);
        this._page.mainFrame()._recalculateLifecycle();
      }
      _onClearLifecycle() {
        this._firedLifecycleEvents.clear();
        this._page.mainFrame()._recalculateLifecycle();
        this._inflightRequests = new Set(Array.from(this._inflightRequests).filter((request) => request === this._currentDocument.request));
        this._stopNetworkIdleTimer();
        if (this._inflightRequests.size === 0)
          this._startNetworkIdleTimer();
      }
      setPendingDocument(documentInfo) {
        this._pendingDocument = documentInfo;
        if (documentInfo)
          this._invalidateNonStallingEvaluations();
      }
      pendingDocument() {
        return this._pendingDocument;
      }
      async _invalidateNonStallingEvaluations() {
        if (!this._nonStallingEvaluations)
          return;
        const error3 = new Error("Navigation interrupted the evaluation");
        for (const callback of this._nonStallingEvaluations)
          callback(error3);
      }
      async nonStallingRawEvaluateInExistingMainContext(expression) {
        if (this._pendingDocument)
          throw new Error("Frame is currently attempting a navigation");
        const context = this._existingMainContext();
        if (!context)
          throw new Error("Frame does not yet have a main execution context");
        let callback = () => {
        };
        const frameInvalidated = new Promise((f, r) => callback = r);
        this._nonStallingEvaluations.add(callback);
        try {
          return await Promise.race([
            context.rawEvaluateJSON(expression),
            frameInvalidated
          ]);
        } finally {
          this._nonStallingEvaluations.delete(callback);
        }
      }
      _recalculateLifecycle() {
        const events = new Set(this._firedLifecycleEvents);
        for (const child of this._childFrames) {
          child._recalculateLifecycle();
          for (const event of events) {
            if (!child._subtreeLifecycleEvents.has(event))
              events.delete(event);
          }
        }
        const mainFrame = this._page.mainFrame();
        for (const event of events) {
          if (!this._subtreeLifecycleEvents.has(event)) {
            this.emit(Frame.Events.AddLifecycle, event);
            if (this === mainFrame && this._url !== "about:blank")
              debugLogger_1.debugLogger.log("api", `  "${event}" event fired`);
            if (this === mainFrame && event === "load")
              this._page.emit(page_1.Page.Events.Load);
            if (this === mainFrame && event === "domcontentloaded")
              this._page.emit(page_1.Page.Events.DOMContentLoaded);
          }
        }
        for (const event of this._subtreeLifecycleEvents) {
          if (!events.has(event))
            this.emit(Frame.Events.RemoveLifecycle, event);
        }
        this._subtreeLifecycleEvents = events;
      }
      async raceNavigationAction(action) {
        return Promise.race([
          this._page._disconnectedPromise.then(() => {
            throw new Error("Navigation failed because page was closed!");
          }),
          this._page._crashedPromise.then(() => {
            throw new Error("Navigation failed because page crashed!");
          }),
          this._detachedPromise.then(() => {
            throw new Error("Navigating frame was detached!");
          }),
          action()
        ]);
      }
      async goto(metadata, url, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this._goto(progress, url, options2), this._page._timeoutSettings.navigationTimeout(options2));
      }
      async _goto(progress, url, options2) {
        return this.raceNavigationAction(async () => {
          const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          progress.log(`navigating to "${url}", waiting until "${waitUntil}"`);
          const headers = this._page._state.extraHTTPHeaders || [];
          const refererHeader = headers.find((h) => h.name.toLowerCase() === "referer");
          let referer = refererHeader ? refererHeader.value : void 0;
          if (options2.referer !== void 0) {
            if (referer !== void 0 && referer !== options2.referer)
              throw new Error('"referer" is already specified as extra HTTP header');
            referer = options2.referer;
          }
          url = helper_1.helper.completeUserURL(url);
          const sameDocument = helper_1.helper.waitForEvent(progress, this, Frame.Events.Navigation, (e) => !e.newDocument);
          const navigateResult = await this._page._delegate.navigateFrame(this, url, referer);
          let event;
          if (navigateResult.newDocumentId) {
            sameDocument.dispose();
            event = await helper_1.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event2) => {
              return event2.newDocument && (event2.newDocument.documentId === navigateResult.newDocumentId || !event2.error);
            }).promise;
            if (event.newDocument.documentId !== navigateResult.newDocumentId) {
              throw new Error("Navigation interrupted by another one");
            }
            if (event.error)
              throw event.error;
          } else {
            event = await sameDocument.promise;
          }
          if (!this._subtreeLifecycleEvents.has(waitUntil))
            await helper_1.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
          const request = event.newDocument ? event.newDocument.request : void 0;
          const response = request ? request._finalRequest().response() : null;
          await this._page._doSlowMo();
          return response;
        });
      }
      async _waitForNavigation(progress, options2) {
        const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
        progress.log(`waiting for navigation until "${waitUntil}"`);
        const navigationEvent = await helper_1.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event) => {
          if (event.error)
            return true;
          progress.log(`  navigated to "${this._url}"`);
          return true;
        }).promise;
        if (navigationEvent.error)
          throw navigationEvent.error;
        if (!this._subtreeLifecycleEvents.has(waitUntil))
          await helper_1.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
        const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : void 0;
        return request ? request._finalRequest().response() : null;
      }
      async _waitForLoadState(progress, state) {
        const waitUntil = verifyLifecycle("state", state);
        if (!this._subtreeLifecycleEvents.has(waitUntil))
          await helper_1.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
      }
      async frameElement() {
        return this._page._delegate.getFrameElement(this);
      }
      _context(world) {
        if (this._detached)
          throw new Error(`Execution Context is not available in detached frame "${this.url()}" (are you trying to evaluate?)`);
        return this._contextData.get(world).contextPromise;
      }
      _mainContext() {
        return this._context("main");
      }
      _existingMainContext() {
        var _a;
        return ((_a = this._contextData.get("main")) === null || _a === void 0 ? void 0 : _a.context) || null;
      }
      _utilityContext() {
        return this._context("utility");
      }
      async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg, world = "main") {
        const context = await this._context(world);
        const handle = await context.evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg);
        if (world === "main")
          await this._page._doSlowMo();
        return handle;
      }
      async evaluateExpression(expression, isFunction, arg, world = "main") {
        const context = await this._context(world);
        const value = await context.evaluateExpression(expression, isFunction, arg);
        if (world === "main")
          await this._page._doSlowMo();
        return value;
      }
      async evaluateExpressionAndWaitForSignals(expression, isFunction, arg, world = "main") {
        const context = await this._context(world);
        const value = await context.evaluateExpressionAndWaitForSignals(expression, isFunction, arg);
        if (world === "main")
          await this._page._doSlowMo();
        return value;
      }
      async $(selector) {
        return this._page.selectors._query(this, selector);
      }
      async waitForSelector(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        if (options2.visibility)
          throw new Error("options.visibility is not supported, did you mean options.state?");
        if (options2.waitFor && options2.waitFor !== "visible")
          throw new Error("options.waitFor is not supported, did you mean options.state?");
        const {state = "visible"} = options2;
        if (!["attached", "detached", "visible", "hidden"].includes(state))
          throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.waitForSelectorTask(info, state);
        return controller.run(async (progress) => {
          progress.log(`waiting for selector "${selector}"${state === "attached" ? "" : " to be " + state}`);
          const result = await this._scheduleRerunnableHandleTask(progress, info.world, task);
          if (!result.asElement()) {
            result.dispose();
            return null;
          }
          const handle = result.asElement();
          return handle._adoptTo(await this._mainContext());
        }, this._page._timeoutSettings.timeout(options2));
      }
      async dispatchEvent(metadata, selector, type, eventInit, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.dispatchEventTask(info, type, eventInit || {});
        await controller.run(async (progress) => {
          progress.log(`Dispatching "${type}" event on selector "${selector}"...`);
          await this._scheduleRerunnableTask(progress, "main", task);
        }, this._page._timeoutSettings.timeout(options2));
        await this._page._doSlowMo();
      }
      async evalOnSelectorAndWaitForSignals(selector, expression, isFunction, arg) {
        const handle = await this.$(selector);
        if (!handle)
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        handle.dispose();
        return result;
      }
      async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        const arrayHandle = await this._page.selectors._queryArray(this, selector);
        const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
        arrayHandle.dispose();
        return result;
      }
      async $$(selector) {
        return this._page.selectors._queryAll(this, selector, void 0, true);
      }
      async content() {
        const context = await this._utilityContext();
        return context.evaluate(() => {
          let retVal = "";
          if (document.doctype)
            retVal = new XMLSerializer().serializeToString(document.doctype);
          if (document.documentElement)
            retVal += document.documentElement.outerHTML;
          return retVal;
        });
      }
      async setContent(metadata, html, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this.raceNavigationAction(async () => {
          const waitUntil = options2.waitUntil === void 0 ? "load" : options2.waitUntil;
          progress.log(`setting frame content, waiting until "${waitUntil}"`);
          const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
          const context = await this._utilityContext();
          const lifecyclePromise = new Promise((resolve2, reject) => {
            this._page._frameManager._consoleMessageTags.set(tag, () => {
              this._onClearLifecycle();
              this._waitForLoadState(progress, waitUntil).then(resolve2).catch(reject);
            });
          });
          const contentPromise = context.evaluate(({html: html2, tag: tag2}) => {
            window.stop();
            document.open();
            console.debug(tag2);
            document.write(html2);
            document.close();
          }, {html, tag});
          await Promise.all([contentPromise, lifecyclePromise]);
          await this._page._doSlowMo();
        }), this._page._timeoutSettings.navigationTimeout(options2));
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      async addScriptTag(params) {
        const {url = null, content = null, type = ""} = params;
        if (!url && !content)
          throw new Error("Provide an object with a `url`, `path` or `content` property");
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
          if (url !== null)
            return (await context.evaluateHandle(addScriptUrl, {url, type})).asElement();
          const result = (await context.evaluateHandle(addScriptContent, {content, type})).asElement();
          if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
            await context.evaluate(() => true);
          return result;
        });
        async function addScriptUrl(params2) {
          const script = document.createElement("script");
          script.src = params2.url;
          if (params2.type)
            script.type = params2.type;
          const promise = new Promise((res, rej) => {
            script.onload = res;
            script.onerror = (e) => rej(typeof e === "string" ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
          });
          document.head.appendChild(script);
          await promise;
          return script;
        }
        function addScriptContent(params2) {
          const script = document.createElement("script");
          script.type = params2.type || "text/javascript";
          script.text = params2.content;
          let error3 = null;
          script.onerror = (e) => error3 = e;
          document.head.appendChild(script);
          if (error3)
            throw error3;
          return script;
        }
      }
      async addStyleTag(params) {
        const {url = null, content = null} = params;
        if (!url && !content)
          throw new Error("Provide an object with a `url`, `path` or `content` property");
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
          if (url !== null)
            return (await context.evaluateHandle(addStyleUrl, url)).asElement();
          return (await context.evaluateHandle(addStyleContent, content)).asElement();
        });
        async function addStyleUrl(url2) {
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = url2;
          const promise = new Promise((res, rej) => {
            link.onload = res;
            link.onerror = rej;
          });
          document.head.appendChild(link);
          await promise;
          return link;
        }
        async function addStyleContent(content2) {
          const style = document.createElement("style");
          style.type = "text/css";
          style.appendChild(document.createTextNode(content2));
          const promise = new Promise((res, rej) => {
            style.onload = res;
            style.onerror = rej;
          });
          document.head.appendChild(style);
          await promise;
          return style;
        }
      }
      async _raceWithCSPError(func) {
        const listeners = [];
        let result;
        let error3;
        let cspMessage;
        const actionPromise = new Promise(async (resolve2) => {
          try {
            result = await func();
          } catch (e) {
            error3 = e;
          }
          resolve2();
        });
        const errorPromise = new Promise((resolve2) => {
          listeners.push(helper_1.helper.addEventListener(this._page, page_1.Page.Events.Console, (message) => {
            if (message.type() === "error" && message.text().includes("Content Security Policy")) {
              cspMessage = message;
              resolve2();
            }
          }));
        });
        await Promise.race([actionPromise, errorPromise]);
        helper_1.helper.removeEventListeners(listeners);
        if (cspMessage)
          throw new Error(cspMessage.text());
        if (error3)
          throw error3;
        return result;
      }
      async _retryWithProgressIfNotConnected(progress, selector, action) {
        const info = this._page.selectors._parseSelector(selector);
        while (progress.isRunning()) {
          progress.log(`waiting for selector "${selector}"`);
          const task = dom.waitForSelectorTask(info, "attached");
          const handle = await this._scheduleRerunnableHandleTask(progress, info.world, task);
          const element = handle.asElement();
          progress.cleanupWhenAborted(() => {
            element.dispose();
          });
          const result = await action(element);
          element.dispose();
          if (result === "error:notconnected") {
            progress.log("element was detached from the DOM, retrying");
            continue;
          }
          return result;
        }
        return void 0;
      }
      async _retryWithSelectorIfNotConnected(controller, selector, options2, action) {
        return controller.run(async (progress) => {
          return this._retryWithProgressIfNotConnected(progress, selector, (handle) => action(progress, handle));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async click(metadata, selector, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._click(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async dblclick(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._dblclick(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async tap(metadata, selector, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._tap(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async fill(metadata, selector, value, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._fill(progress, value, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async focus(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        await this._retryWithSelectorIfNotConnected(controller, selector, options2, (progress, handle) => handle._focus(progress));
        await this._page._doSlowMo();
      }
      async textContent(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.textContentTask(info);
        return controller.run(async (progress) => {
          progress.log(`  retrieving textContent from "${selector}"`);
          return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options2));
      }
      async innerText(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.innerTextTask(info);
        return controller.run(async (progress) => {
          progress.log(`  retrieving innerText from "${selector}"`);
          const result = dom.throwFatalDOMError(await this._scheduleRerunnableTask(progress, info.world, task));
          return result.innerText;
        }, this._page._timeoutSettings.timeout(options2));
      }
      async innerHTML(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.innerHTMLTask(info);
        return controller.run(async (progress) => {
          progress.log(`  retrieving innerHTML from "${selector}"`);
          return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options2));
      }
      async getAttribute(metadata, selector, name, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.getAttributeTask(info, name);
        return controller.run(async (progress) => {
          progress.log(`  retrieving attribute "${name}" from "${selector}"`);
          return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _checkElementState(metadata, selector, state, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        const info = this._page.selectors._parseSelector(selector);
        const task = dom.elementStateTask(info, state);
        const result = await controller.run(async (progress) => {
          progress.log(`  checking "${state}" state of "${selector}"`);
          return this._scheduleRerunnableTask(progress, info.world, task);
        }, this._page._timeoutSettings.timeout(options2));
        return dom.throwFatalDOMError(dom.throwRetargetableDOMError(result));
      }
      async isVisible(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          progress.log(`  checking visibility of "${selector}"`);
          const element = await this.$(selector);
          return element ? await element.isVisible() : false;
        }, this._page._timeoutSettings.timeout(options2));
      }
      async isHidden(metadata, selector, options2 = {}) {
        return !await this.isVisible(metadata, selector, options2);
      }
      async isDisabled(metadata, selector, options2 = {}) {
        return this._checkElementState(metadata, selector, "disabled", options2);
      }
      async isEnabled(metadata, selector, options2 = {}) {
        return this._checkElementState(metadata, selector, "enabled", options2);
      }
      async isEditable(metadata, selector, options2 = {}) {
        return this._checkElementState(metadata, selector, "editable", options2);
      }
      async isChecked(metadata, selector, options2 = {}) {
        return this._checkElementState(metadata, selector, "checked", options2);
      }
      async hover(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._hover(progress, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async selectOption(metadata, selector, elements, values, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._selectOption(progress, elements, values, options2));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async setInputFiles(metadata, selector, files, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._setInputFiles(progress, files, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async type(metadata, selector, text, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._type(progress, text, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async press(metadata, selector, key, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._press(progress, key, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async check(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._setChecked(progress, true, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async uncheck(metadata, selector, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run(async (progress) => {
          return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, (handle) => handle._setChecked(progress, false, options2)));
        }, this._page._timeoutSettings.timeout(options2));
      }
      async _waitForFunctionExpression(metadata, expression, isFunction, arg, options2, world = "main") {
        const controller = new progress_1.ProgressController(metadata, this);
        if (typeof options2.pollingInterval === "number")
          utils_1.assert(options2.pollingInterval > 0, "Cannot poll with non-positive interval: " + options2.pollingInterval);
        expression = js.normalizeEvaluationExpression(expression, isFunction);
        const task = (injectedScript) => injectedScript.evaluateHandle((injectedScript2, {expression: expression2, isFunction: isFunction2, polling, arg: arg2}) => {
          const predicate = (arg3) => {
            let result = self.eval(expression2);
            if (isFunction2 === true) {
              result = result(arg3);
            } else if (isFunction2 === false) {
              result = result;
            } else {
              if (typeof result === "function")
                result = result(arg3);
            }
            return result;
          };
          if (typeof polling !== "number")
            return injectedScript2.pollRaf((progress, continuePolling) => predicate(arg2) || continuePolling);
          return injectedScript2.pollInterval(polling, (progress, continuePolling) => predicate(arg2) || continuePolling);
        }, {expression, isFunction, polling: options2.pollingInterval, arg});
        return controller.run((progress) => this._scheduleRerunnableHandleTask(progress, world, task), this._page._timeoutSettings.timeout(options2));
      }
      async waitForFunctionValueInUtility(progress, pageFunction) {
        const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
        const handle = await this._waitForFunctionExpression(instrumentation_1.internalCallMetadata(), expression, true, void 0, {timeout: progress.timeUntilDeadline()}, "utility");
        return JSON.parse(handle.rawValue());
      }
      async title() {
        const context = await this._utilityContext();
        return context.evaluate(() => document.title);
      }
      _onDetached() {
        this._stopNetworkIdleTimer();
        this._detached = true;
        this._detachedCallback();
        for (const data of this._contextData.values()) {
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.terminate(new Error("waitForFunction failed: frame got detached."));
        }
        if (this._parentFrame)
          this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
      }
      _scheduleRerunnableTask(progress, world, task) {
        const data = this._contextData.get(world);
        const rerunnableTask = new RerunnableTask(data, progress, task, true);
        if (this._detached)
          rerunnableTask.terminate(new Error("waitForFunction failed: frame got detached."));
        if (data.context)
          rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
      }
      _scheduleRerunnableHandleTask(progress, world, task) {
        const data = this._contextData.get(world);
        const rerunnableTask = new RerunnableTask(data, progress, task, false);
        if (this._detached)
          rerunnableTask.terminate(new Error("waitForFunction failed: frame got detached."));
        if (data.context)
          rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
      }
      _setContext(world, context) {
        const data = this._contextData.get(world);
        data.context = context;
        if (context) {
          data.contextResolveCallback.call(null, context);
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.rerun(context);
        } else {
          data.contextPromise = new Promise((fulfill) => {
            data.contextResolveCallback = fulfill;
          });
        }
      }
      _contextCreated(world, context) {
        const data = this._contextData.get(world);
        if (data.context)
          this._setContext(world, null);
        this._setContext(world, context);
      }
      _contextDestroyed(context) {
        for (const [world, data] of this._contextData) {
          if (data.context === context)
            this._setContext(world, null);
        }
      }
      _startNetworkIdleTimer() {
        utils_1.assert(!this._networkIdleTimer);
        if (this._firedLifecycleEvents.has("networkidle") || this._detached)
          return;
        this._networkIdleTimer = setTimeout(() => this._onLifecycleEvent("networkidle"), 500);
      }
      _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
          clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = void 0;
      }
      async extendInjectedScript(source, arg) {
        const mainContext = await this._mainContext();
        const injectedScriptHandle = await mainContext.injectedScript();
        return injectedScriptHandle.evaluateHandle((injectedScript, {source: source2, arg: arg2}) => {
          return injectedScript.extend(source2, arg2);
        }, {source, arg});
      }
    };
    exports2.Frame = Frame;
    Frame.Events = {
      Navigation: "navigation",
      AddLifecycle: "addlifecycle",
      RemoveLifecycle: "removelifecycle"
    };
    var RerunnableTask = class {
      constructor(data, progress, task, returnByValue) {
        this._resolve = () => {
        };
        this._reject = () => {
        };
        this._task = task;
        this._progress = progress;
        this._returnByValue = returnByValue;
        this._contextData = data;
        this._contextData.rerunnableTasks.add(this);
        this.promise = new Promise((resolve2, reject) => {
          this._resolve = resolve2;
          this._reject = reject;
        });
      }
      terminate(error3) {
        this._reject(error3);
      }
      async rerun(context) {
        try {
          const injectedScript = await context.injectedScript();
          const pollHandler = new dom.InjectedScriptPollHandler(this._progress, await this._task(injectedScript));
          const result = this._returnByValue ? await pollHandler.finish() : await pollHandler.finishHandle();
          this._contextData.rerunnableTasks.delete(this);
          this._resolve(result);
        } catch (e) {
          if (e.message.includes("Execution context was destroyed"))
            return;
          if (e.message.includes("Cannot find context with specified id"))
            return;
          this._contextData.rerunnableTasks.delete(this);
          this._reject(e);
        }
      }
    };
    var SignalBarrier = class {
      constructor(progress) {
        this._protectCount = 0;
        this._promiseCallback = () => {
        };
        this._progress = progress;
        this._promise = new Promise((f) => this._promiseCallback = f);
        this.retain();
      }
      waitFor() {
        this.release();
        return this._promise;
      }
      async addFrameNavigation(frame) {
        if (frame.parentFrame())
          return;
        this.retain();
        const waiter = helper_1.helper.waitForEvent(null, frame, Frame.Events.Navigation, (e) => {
          if (!e.error && this._progress)
            this._progress.log(`  navigated to "${frame._url}"`);
          return true;
        });
        await Promise.race([
          frame._page._disconnectedPromise,
          frame._page._crashedPromise,
          frame._detachedPromise,
          waiter.promise
        ]).catch((e) => {
        });
        waiter.dispose();
        this.release();
      }
      retain() {
        ++this._protectCount;
      }
      release() {
        --this._protectCount;
        if (!this._protectCount)
          this._promiseCallback();
      }
    };
    function verifyLifecycle(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!types2.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright/lib/server/usKeyboardLayout.js
var require_usKeyboardLayout = __commonJS({
  "node_modules/playwright/lib/server/usKeyboardLayout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.USKeyboardLayout = exports2.keypadLocation = void 0;
    exports2.keypadLocation = 3;
    exports2.USKeyboardLayout = {
      "Escape": {"keyCode": 27, "key": "Escape"},
      "F1": {"keyCode": 112, "key": "F1"},
      "F2": {"keyCode": 113, "key": "F2"},
      "F3": {"keyCode": 114, "key": "F3"},
      "F4": {"keyCode": 115, "key": "F4"},
      "F5": {"keyCode": 116, "key": "F5"},
      "F6": {"keyCode": 117, "key": "F6"},
      "F7": {"keyCode": 118, "key": "F7"},
      "F8": {"keyCode": 119, "key": "F8"},
      "F9": {"keyCode": 120, "key": "F9"},
      "F10": {"keyCode": 121, "key": "F10"},
      "F11": {"keyCode": 122, "key": "F11"},
      "F12": {"keyCode": 123, "key": "F12"},
      "Backquote": {"keyCode": 192, "shiftKey": "~", "key": "`"},
      "Digit1": {"keyCode": 49, "shiftKey": "!", "key": "1"},
      "Digit2": {"keyCode": 50, "shiftKey": "@", "key": "2"},
      "Digit3": {"keyCode": 51, "shiftKey": "#", "key": "3"},
      "Digit4": {"keyCode": 52, "shiftKey": "$", "key": "4"},
      "Digit5": {"keyCode": 53, "shiftKey": "%", "key": "5"},
      "Digit6": {"keyCode": 54, "shiftKey": "^", "key": "6"},
      "Digit7": {"keyCode": 55, "shiftKey": "&", "key": "7"},
      "Digit8": {"keyCode": 56, "shiftKey": "*", "key": "8"},
      "Digit9": {"keyCode": 57, "shiftKey": "(", "key": "9"},
      "Digit0": {"keyCode": 48, "shiftKey": ")", "key": "0"},
      "Minus": {"keyCode": 189, "shiftKey": "_", "key": "-"},
      "Equal": {"keyCode": 187, "shiftKey": "+", "key": "="},
      "Backslash": {"keyCode": 220, "shiftKey": "|", "key": "\\"},
      "Backspace": {"keyCode": 8, "key": "Backspace"},
      "Tab": {"keyCode": 9, "key": "Tab"},
      "KeyQ": {"keyCode": 81, "shiftKey": "Q", "key": "q"},
      "KeyW": {"keyCode": 87, "shiftKey": "W", "key": "w"},
      "KeyE": {"keyCode": 69, "shiftKey": "E", "key": "e"},
      "KeyR": {"keyCode": 82, "shiftKey": "R", "key": "r"},
      "KeyT": {"keyCode": 84, "shiftKey": "T", "key": "t"},
      "KeyY": {"keyCode": 89, "shiftKey": "Y", "key": "y"},
      "KeyU": {"keyCode": 85, "shiftKey": "U", "key": "u"},
      "KeyI": {"keyCode": 73, "shiftKey": "I", "key": "i"},
      "KeyO": {"keyCode": 79, "shiftKey": "O", "key": "o"},
      "KeyP": {"keyCode": 80, "shiftKey": "P", "key": "p"},
      "BracketLeft": {"keyCode": 219, "shiftKey": "{", "key": "["},
      "BracketRight": {"keyCode": 221, "shiftKey": "}", "key": "]"},
      "CapsLock": {"keyCode": 20, "key": "CapsLock"},
      "KeyA": {"keyCode": 65, "shiftKey": "A", "key": "a"},
      "KeyS": {"keyCode": 83, "shiftKey": "S", "key": "s"},
      "KeyD": {"keyCode": 68, "shiftKey": "D", "key": "d"},
      "KeyF": {"keyCode": 70, "shiftKey": "F", "key": "f"},
      "KeyG": {"keyCode": 71, "shiftKey": "G", "key": "g"},
      "KeyH": {"keyCode": 72, "shiftKey": "H", "key": "h"},
      "KeyJ": {"keyCode": 74, "shiftKey": "J", "key": "j"},
      "KeyK": {"keyCode": 75, "shiftKey": "K", "key": "k"},
      "KeyL": {"keyCode": 76, "shiftKey": "L", "key": "l"},
      "Semicolon": {"keyCode": 186, "shiftKey": ":", "key": ";"},
      "Quote": {"keyCode": 222, "shiftKey": '"', "key": "'"},
      "Enter": {"keyCode": 13, "key": "Enter", "text": "\r"},
      "ShiftLeft": {"keyCode": 160, "keyCodeWithoutLocation": 16, "key": "Shift", "location": 1},
      "KeyZ": {"keyCode": 90, "shiftKey": "Z", "key": "z"},
      "KeyX": {"keyCode": 88, "shiftKey": "X", "key": "x"},
      "KeyC": {"keyCode": 67, "shiftKey": "C", "key": "c"},
      "KeyV": {"keyCode": 86, "shiftKey": "V", "key": "v"},
      "KeyB": {"keyCode": 66, "shiftKey": "B", "key": "b"},
      "KeyN": {"keyCode": 78, "shiftKey": "N", "key": "n"},
      "KeyM": {"keyCode": 77, "shiftKey": "M", "key": "m"},
      "Comma": {"keyCode": 188, "shiftKey": "<", "key": ","},
      "Period": {"keyCode": 190, "shiftKey": ">", "key": "."},
      "Slash": {"keyCode": 191, "shiftKey": "?", "key": "/"},
      "ShiftRight": {"keyCode": 161, "keyCodeWithoutLocation": 16, "key": "Shift", "location": 2},
      "ControlLeft": {"keyCode": 162, "keyCodeWithoutLocation": 17, "key": "Control", "location": 1},
      "MetaLeft": {"keyCode": 91, "key": "Meta", "location": 1},
      "AltLeft": {"keyCode": 164, "keyCodeWithoutLocation": 18, "key": "Alt", "location": 1},
      "Space": {"keyCode": 32, "key": " "},
      "AltRight": {"keyCode": 165, "keyCodeWithoutLocation": 18, "key": "Alt", "location": 2},
      "AltGraph": {"keyCode": 225, "key": "AltGraph"},
      "MetaRight": {"keyCode": 92, "key": "Meta", "location": 2},
      "ContextMenu": {"keyCode": 93, "key": "ContextMenu"},
      "ControlRight": {"keyCode": 163, "keyCodeWithoutLocation": 17, "key": "Control", "location": 2},
      "PrintScreen": {"keyCode": 44, "key": "PrintScreen"},
      "ScrollLock": {"keyCode": 145, "key": "ScrollLock"},
      "Pause": {"keyCode": 19, "key": "Pause"},
      "PageUp": {"keyCode": 33, "key": "PageUp"},
      "PageDown": {"keyCode": 34, "key": "PageDown"},
      "Insert": {"keyCode": 45, "key": "Insert"},
      "Delete": {"keyCode": 46, "key": "Delete"},
      "Home": {"keyCode": 36, "key": "Home"},
      "End": {"keyCode": 35, "key": "End"},
      "ArrowLeft": {"keyCode": 37, "key": "ArrowLeft"},
      "ArrowUp": {"keyCode": 38, "key": "ArrowUp"},
      "ArrowRight": {"keyCode": 39, "key": "ArrowRight"},
      "ArrowDown": {"keyCode": 40, "key": "ArrowDown"},
      "NumLock": {"keyCode": 144, "key": "NumLock"},
      "NumpadDivide": {"keyCode": 111, "key": "/", "location": 3},
      "NumpadMultiply": {"keyCode": 106, "key": "*", "location": 3},
      "NumpadSubtract": {"keyCode": 109, "key": "-", "location": 3},
      "Numpad7": {"keyCode": 36, "shiftKeyCode": 103, "key": "Home", "shiftKey": "7", "location": 3},
      "Numpad8": {"keyCode": 38, "shiftKeyCode": 104, "key": "ArrowUp", "shiftKey": "8", "location": 3},
      "Numpad9": {"keyCode": 33, "shiftKeyCode": 105, "key": "PageUp", "shiftKey": "9", "location": 3},
      "Numpad4": {"keyCode": 37, "shiftKeyCode": 100, "key": "ArrowLeft", "shiftKey": "4", "location": 3},
      "Numpad5": {"keyCode": 12, "shiftKeyCode": 101, "key": "Clear", "shiftKey": "5", "location": 3},
      "Numpad6": {"keyCode": 39, "shiftKeyCode": 102, "key": "ArrowRight", "shiftKey": "6", "location": 3},
      "NumpadAdd": {"keyCode": 107, "key": "+", "location": 3},
      "Numpad1": {"keyCode": 35, "shiftKeyCode": 97, "key": "End", "shiftKey": "1", "location": 3},
      "Numpad2": {"keyCode": 40, "shiftKeyCode": 98, "key": "ArrowDown", "shiftKey": "2", "location": 3},
      "Numpad3": {"keyCode": 34, "shiftKeyCode": 99, "key": "PageDown", "shiftKey": "3", "location": 3},
      "Numpad0": {"keyCode": 45, "shiftKeyCode": 96, "key": "Insert", "shiftKey": "0", "location": 3},
      "NumpadDecimal": {"keyCode": 46, "shiftKeyCode": 110, "key": "\0", "shiftKey": ".", "location": 3},
      "NumpadEnter": {"keyCode": 13, "key": "Enter", "text": "\r", "location": 3}
    };
  }
});

// node_modules/playwright/lib/server/input.js
var require_input = __commonJS({
  "node_modules/playwright/lib/server/input.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = exports2.keypadLocation = void 0;
    var utils_1 = require_utils();
    var keyboardLayout = __importStar(require_usKeyboardLayout());
    exports2.keypadLocation = keyboardLayout.keypadLocation;
    var kModifiers = ["Alt", "Control", "Meta", "Shift"];
    var Keyboard = class {
      constructor(raw, page) {
        this._pressedModifiers = new Set();
        this._pressedKeys = new Set();
        this._raw = raw;
        this._page = page;
      }
      async down(key) {
        const description = this._keyDescriptionForString(key);
        const autoRepeat = this._pressedKeys.has(description.code);
        this._pressedKeys.add(description.code);
        if (kModifiers.includes(description.key))
          this._pressedModifiers.add(description.key);
        const text = description.text;
        await this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
        await this._page._doSlowMo();
      }
      _keyDescriptionForString(keyString) {
        let description = usKeyboardLayout.get(keyString);
        utils_1.assert(description, `Unknown key: "${keyString}"`);
        const shift = this._pressedModifiers.has("Shift");
        description = shift && description.shifted ? description.shifted : description;
        if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has("Shift") && this._pressedModifiers.size === 1)
          return {...description, text: ""};
        return description;
      }
      async up(key) {
        const description = this._keyDescriptionForString(key);
        if (kModifiers.includes(description.key))
          this._pressedModifiers.delete(description.key);
        this._pressedKeys.delete(description.code);
        await this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
        await this._page._doSlowMo();
      }
      async insertText(text) {
        await this._raw.sendText(text);
        await this._page._doSlowMo();
      }
      async type(text, options2) {
        const delay = options2 && options2.delay || void 0;
        for (const char of text) {
          if (usKeyboardLayout.has(char)) {
            await this.press(char, {delay});
          } else {
            if (delay)
              await new Promise((f) => setTimeout(f, delay));
            await this.insertText(char);
          }
        }
      }
      async press(key, options2 = {}) {
        function split(keyString) {
          const keys = [];
          let building = "";
          for (const char of keyString) {
            if (char === "+" && building) {
              keys.push(building);
              building = "";
            } else {
              building += char;
            }
          }
          keys.push(building);
          return keys;
        }
        const tokens = split(key);
        const promises = [];
        key = tokens[tokens.length - 1];
        for (let i = 0; i < tokens.length - 1; ++i)
          promises.push(this.down(tokens[i]));
        promises.push(this.down(key));
        if (options2.delay) {
          await Promise.all(promises);
          await new Promise((f) => setTimeout(f, options2.delay));
        }
        promises.push(this.up(key));
        for (let i = tokens.length - 2; i >= 0; --i)
          promises.push(this.up(tokens[i]));
        await Promise.all(promises);
      }
      async _ensureModifiers(modifiers) {
        for (const modifier of modifiers) {
          if (!kModifiers.includes(modifier))
            throw new Error("Unknown modifier " + modifier);
        }
        const restore = Array.from(this._pressedModifiers);
        const promises = [];
        for (const key of kModifiers) {
          const needDown = modifiers.includes(key);
          const isDown = this._pressedModifiers.has(key);
          if (needDown && !isDown)
            promises.push(this.down(key));
          else if (!needDown && isDown)
            promises.push(this.up(key));
        }
        await Promise.all(promises);
        return restore;
      }
      _modifiers() {
        return this._pressedModifiers;
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(raw, page) {
        this._x = 0;
        this._y = 0;
        this._lastButton = "none";
        this._buttons = new Set();
        this._raw = raw;
        this._page = page;
        this._keyboard = this._page.keyboard;
      }
      async move(x, y, options2 = {}) {
        const {steps = 1} = options2;
        const fromX = this._x;
        const fromY = this._y;
        this._x = x;
        this._y = y;
        for (let i = 1; i <= steps; i++) {
          const middleX = fromX + (x - fromX) * (i / steps);
          const middleY = fromY + (y - fromY) * (i / steps);
          await this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers());
          await this._page._doSlowMo();
        }
      }
      async down(options2 = {}) {
        const {button = "left", clickCount = 1} = options2;
        this._lastButton = button;
        this._buttons.add(button);
        await this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
        await this._page._doSlowMo();
      }
      async up(options2 = {}) {
        const {button = "left", clickCount = 1} = options2;
        this._lastButton = "none";
        this._buttons.delete(button);
        await this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
        await this._page._doSlowMo();
      }
      async click(x, y, options2 = {}) {
        const {delay = null, clickCount = 1} = options2;
        if (delay) {
          this.move(x, y);
          for (let cc = 1; cc <= clickCount; ++cc) {
            await this.down({...options2, clickCount: cc});
            await new Promise((f) => setTimeout(f, delay));
            await this.up({...options2, clickCount: cc});
            if (cc < clickCount)
              await new Promise((f) => setTimeout(f, delay));
          }
        } else {
          const promises = [];
          promises.push(this.move(x, y));
          for (let cc = 1; cc <= clickCount; ++cc) {
            promises.push(this.down({...options2, clickCount: cc}));
            promises.push(this.up({...options2, clickCount: cc}));
          }
          await Promise.all(promises);
        }
      }
      async dblclick(x, y, options2 = {}) {
        await this.click(x, y, {...options2, clickCount: 2});
      }
    };
    exports2.Mouse = Mouse;
    var aliases = new Map([
      ["ShiftLeft", ["Shift"]],
      ["ControlLeft", ["Control"]],
      ["AltLeft", ["Alt"]],
      ["MetaLeft", ["Meta"]],
      ["Enter", ["\n", "\r"]]
    ]);
    var usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);
    function buildLayoutClosure(layout2) {
      const result = new Map();
      for (const code in layout2) {
        const definition = layout2[code];
        const description = {
          key: definition.key || "",
          keyCode: definition.keyCode || 0,
          keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
          code,
          text: definition.text || "",
          location: definition.location || 0
        };
        if (definition.key.length === 1)
          description.text = description.key;
        let shiftedDescription;
        if (definition.shiftKey) {
          utils_1.assert(definition.shiftKey.length === 1);
          shiftedDescription = {...description};
          shiftedDescription.key = definition.shiftKey;
          shiftedDescription.text = definition.shiftKey;
          if (definition.shiftKeyCode)
            shiftedDescription.keyCode = definition.shiftKeyCode;
        }
        result.set(code, {...description, shifted: shiftedDescription});
        if (aliases.has(code)) {
          for (const alias of aliases.get(code))
            result.set(alias, description);
        }
        if (definition.location)
          continue;
        if (description.key.length === 1)
          result.set(description.key, description);
        if (shiftedDescription)
          result.set(shiftedDescription.key, {...shiftedDescription, shifted: void 0});
      }
      return result;
    }
    var Touchscreen = class {
      constructor(raw, page) {
        this._raw = raw;
        this._page = page;
      }
      async tap(x, y) {
        if (!this._page._browserContext._options.hasTouch)
          throw new Error("hasTouch must be enabled on the browser context before using the touchscreen.");
        await this._raw.tap(x, y, this._page.keyboard._modifiers());
        await this._page._doSlowMo();
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright/lib/server/screenshotter.js
var require_screenshotter = __commonJS({
  "node_modules/playwright/lib/server/screenshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Screenshotter = void 0;
    var helper_1 = require_helper();
    var utils_1 = require_utils();
    var Screenshotter = class {
      constructor(page) {
        this._queue = new TaskQueue();
        this._page = page;
        this._queue = new TaskQueue();
      }
      async _originalViewportSize(progress) {
        const originalViewportSize = this._page.viewportSize();
        let viewportSize = originalViewportSize;
        if (!viewportSize)
          viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({width: window.innerWidth, height: window.innerHeight}));
        return {viewportSize, originalViewportSize};
      }
      async _fullPageSize(progress) {
        const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {
          if (!document.body || !document.documentElement)
            return null;
          return {
            width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
            height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
          };
        });
        return fullPageSize;
      }
      async screenshotPage(progress, options2) {
        const format2 = validateScreenshotOptions(options2);
        return this._queue.postTask(async () => {
          const {viewportSize, originalViewportSize} = await this._originalViewportSize(progress);
          if (options2.fullPage) {
            const fullPageSize = await this._fullPageSize(progress);
            let documentRect = {x: 0, y: 0, width: fullPageSize.width, height: fullPageSize.height};
            let overriddenViewportSize = null;
            const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
            if (!this._page._delegate.canScreenshotOutsideViewport() && !fitsViewport) {
              overriddenViewportSize = fullPageSize;
              progress.throwIfAborted();
              await this._page.setViewportSize(overriddenViewportSize);
              progress.cleanupWhenAborted(() => this._restoreViewport(originalViewportSize));
            }
            if (options2.clip)
              documentRect = trimClipToSize(options2.clip, documentRect);
            const buffer = await this._screenshot(progress, format2, documentRect, void 0, options2);
            progress.throwIfAborted();
            if (overriddenViewportSize)
              await this._restoreViewport(originalViewportSize);
            return buffer;
          }
          const viewportRect = options2.clip ? trimClipToSize(options2.clip, viewportSize) : {x: 0, y: 0, ...viewportSize};
          return await this._screenshot(progress, format2, void 0, viewportRect, options2);
        });
      }
      async screenshotElement(progress, handle, options2 = {}) {
        const format2 = validateScreenshotOptions(options2);
        return this._queue.postTask(async () => {
          const {viewportSize, originalViewportSize} = await this._originalViewportSize(progress);
          await handle._waitAndScrollIntoViewIfNeeded(progress);
          progress.throwIfAborted();
          let boundingBox = await handle.boundingBox();
          utils_1.assert(boundingBox, "Node is either not visible or not an HTMLElement");
          utils_1.assert(boundingBox.width !== 0, "Node has 0 width.");
          utils_1.assert(boundingBox.height !== 0, "Node has 0 height.");
          let overriddenViewportSize = null;
          const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
          if (!this._page._delegate.canScreenshotOutsideViewport() && !fitsViewport) {
            overriddenViewportSize = helper_1.helper.enclosingIntSize({
              width: Math.max(viewportSize.width, boundingBox.width),
              height: Math.max(viewportSize.height, boundingBox.height)
            });
            progress.throwIfAborted();
            await this._page.setViewportSize(overriddenViewportSize);
            progress.cleanupWhenAborted(() => this._restoreViewport(originalViewportSize));
            progress.throwIfAborted();
            await handle._waitAndScrollIntoViewIfNeeded(progress);
            boundingBox = await handle.boundingBox();
            utils_1.assert(boundingBox, "Node is either not visible or not an HTMLElement");
            utils_1.assert(boundingBox.width !== 0, "Node has 0 width.");
            utils_1.assert(boundingBox.height !== 0, "Node has 0 height.");
          }
          progress.throwIfAborted();
          const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({x: window.scrollX, y: window.scrollY}));
          const documentRect = {...boundingBox};
          documentRect.x += scrollOffset.x;
          documentRect.y += scrollOffset.y;
          const buffer = await this._screenshot(progress, format2, helper_1.helper.enclosingIntRect(documentRect), void 0, options2);
          progress.throwIfAborted();
          if (overriddenViewportSize)
            await this._restoreViewport(originalViewportSize);
          return buffer;
        });
      }
      async _screenshot(progress, format2, documentRect, viewportRect, options2) {
        if (options2.__testHookBeforeScreenshot)
          await options2.__testHookBeforeScreenshot();
        progress.throwIfAborted();
        const shouldSetDefaultBackground = options2.omitBackground && format2 === "png";
        if (shouldSetDefaultBackground) {
          await this._page._delegate.setBackgroundColor({r: 0, g: 0, b: 0, a: 0});
          progress.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
        }
        progress.throwIfAborted();
        const buffer = await this._page._delegate.takeScreenshot(progress, format2, documentRect, viewportRect, options2.quality);
        progress.throwIfAborted();
        if (shouldSetDefaultBackground)
          await this._page._delegate.setBackgroundColor();
        progress.throwIfAborted();
        if (options2.__testHookAfterScreenshot)
          await options2.__testHookAfterScreenshot();
        return buffer;
      }
      async _restoreViewport(originalViewportSize) {
        utils_1.assert(!this._page._delegate.canScreenshotOutsideViewport());
        if (originalViewportSize)
          await this._page.setViewportSize(originalViewportSize);
        else
          await this._page._delegate.resetViewport();
      }
    };
    exports2.Screenshotter = Screenshotter;
    var TaskQueue = class {
      constructor() {
        this._chain = Promise.resolve();
      }
      postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => {
        });
        return result;
      }
    };
    function trimClipToSize(clip, size) {
      const p1 = {
        x: Math.max(0, Math.min(clip.x, size.width)),
        y: Math.max(0, Math.min(clip.y, size.height))
      };
      const p2 = {
        x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
        y: Math.max(0, Math.min(clip.y + clip.height, size.height))
      };
      const result = {x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y};
      utils_1.assert(result.width && result.height, "Clipped area is either empty or outside the resulting image");
      return result;
    }
    function validateScreenshotOptions(options2) {
      let format2 = null;
      if (options2.type) {
        utils_1.assert(options2.type === "png" || options2.type === "jpeg", "Unknown options.type value: " + options2.type);
        format2 = options2.type;
      }
      if (!format2)
        format2 = "png";
      if (options2.quality !== void 0) {
        utils_1.assert(format2 === "jpeg", "options.quality is unsupported for the " + format2 + " screenshots");
        utils_1.assert(typeof options2.quality === "number", "Expected options.quality to be a number but found " + typeof options2.quality);
        utils_1.assert(Number.isInteger(options2.quality), "Expected options.quality to be an integer");
        utils_1.assert(options2.quality >= 0 && options2.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options2.quality);
      }
      if (options2.clip) {
        utils_1.assert(typeof options2.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options2.clip.x);
        utils_1.assert(typeof options2.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options2.clip.y);
        utils_1.assert(typeof options2.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options2.clip.width);
        utils_1.assert(typeof options2.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options2.clip.height);
        utils_1.assert(options2.clip.width !== 0, "Expected options.clip.width not to be 0.");
        utils_1.assert(options2.clip.height !== 0, "Expected options.clip.height not to be 0.");
      }
      return format2;
    }
  }
});

// node_modules/playwright/lib/server/console.js
var require_console = __commonJS({
  "node_modules/playwright/lib/server/console.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ConsoleMessage = void 0;
    var instrumentation_1 = require_instrumentation();
    var ConsoleMessage = class extends instrumentation_1.SdkObject {
      constructor(parent, type, text, args, location2) {
        super(parent, "console-message");
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location2 || {url: "", lineNumber: 0, columnNumber: 0};
      }
      type() {
        return this._type;
      }
      text() {
        if (this._text === void 0)
          this._text = this._args.map((arg) => arg._value).join(" ");
        return this._text;
      }
      args() {
        return this._args;
      }
      location() {
        return this._location;
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright/lib/server/accessibility.js
var require_accessibility = __commonJS({
  "node_modules/playwright/lib/server/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Accessibility = void 0;
    var Accessibility = class {
      constructor(getAXTree) {
        this._getAXTree = getAXTree;
      }
      async snapshot(options2 = {}) {
        const {interestingOnly = true, root = null} = options2;
        const {tree, needle} = await this._getAXTree(root || void 0);
        if (!interestingOnly) {
          if (root)
            return needle && serializeTree(needle)[0];
          return serializeTree(tree)[0];
        }
        const interestingNodes = new Set();
        collectInterestingNodes(interestingNodes, tree, false);
        if (root && (!needle || !interestingNodes.has(needle)))
          return null;
        return serializeTree(needle || tree, interestingNodes)[0];
      }
    };
    exports2.Accessibility = Accessibility;
    function collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl))
        collection.add(node);
      if (node.isLeafNode())
        return;
      insideControl = insideControl || node.isControl();
      for (const child of node.children())
        collectInterestingNodes(collection, child, insideControl);
    }
    function serializeTree(node, whitelistedNodes) {
      const children = [];
      for (const child of node.children())
        children.push(...serializeTree(child, whitelistedNodes));
      if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
      const serializedNode = node.serialize();
      if (children.length)
        serializedNode.children = children;
      return [serializedNode];
    }
  }
});

// node_modules/playwright/lib/server/fileChooser.js
var require_fileChooser = __commonJS({
  "node_modules/playwright/lib/server/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/playwright/lib/server/page.js
var require_page = __commonJS({
  "node_modules/playwright/lib/server/page.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.PageBinding = exports2.Worker = exports2.Page = void 0;
    var frames = __importStar(require_frames());
    var input = __importStar(require_input());
    var js = __importStar(require_javascript());
    var network = __importStar(require_network());
    var screenshotter_1 = require_screenshotter();
    var timeoutSettings_1 = require_timeoutSettings();
    var types2 = __importStar(require_types());
    var browserContext_1 = require_browserContext();
    var console_1 = require_console();
    var accessibility = __importStar(require_accessibility());
    var fileChooser_1 = require_fileChooser();
    var progress_1 = require_progress();
    var utils_1 = require_utils();
    var debugLogger_1 = require_debugLogger();
    var instrumentation_1 = require_instrumentation();
    var Page = class extends instrumentation_1.SdkObject {
      constructor(delegate, browserContext) {
        super(browserContext, "page");
        this._closedState = "open";
        this._disconnected = false;
        this._pageBindings = new Map();
        this._evaluateOnNewDocumentSources = [];
        this._workers = new Map();
        this._video = null;
        this.attribution.page = this;
        this._delegate = delegate;
        this._closedCallback = () => {
        };
        this._closedPromise = new Promise((f) => this._closedCallback = f);
        this._disconnectedCallback = () => {
        };
        this._disconnectedPromise = new Promise((f) => this._disconnectedCallback = f);
        this._crashedCallback = () => {
        };
        this._crashedPromise = new Promise((f) => this._crashedCallback = f);
        this._browserContext = browserContext;
        this._state = {
          emulatedSize: browserContext._options.viewport ? {viewport: browserContext._options.viewport, screen: browserContext._options.screen || browserContext._options.viewport} : null,
          mediaType: null,
          colorScheme: null,
          extraHTTPHeaders: null
        };
        this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
        this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);
        this.mouse = new input.Mouse(delegate.rawMouse, this);
        this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(browserContext._timeoutSettings);
        this._screenshotter = new screenshotter_1.Screenshotter(this);
        this._frameManager = new frames.FrameManager(this);
        if (delegate.pdf)
          this.pdf = delegate.pdf.bind(delegate);
        this.coverage = delegate.coverage ? delegate.coverage() : null;
        this.selectors = browserContext.selectors();
      }
      async initOpener(opener) {
        if (!opener)
          return;
        const openerPage = await opener.pageOrError();
        if (openerPage instanceof Page && !openerPage.isClosed())
          this._opener = openerPage;
      }
      reportAsNew(error3) {
        if (error3) {
          if (this._browserContext.isClosingOrClosed())
            return;
          this._setIsError(error3);
        }
        this._browserContext.emit(browserContext_1.BrowserContext.Events.Page, this);
        if (this.isClosed())
          this.emit(Page.Events.Close);
      }
      async _doSlowMo() {
        const slowMo = this._browserContext._browser.options.slowMo;
        if (!slowMo)
          return;
        await new Promise((x) => setTimeout(x, slowMo));
      }
      _didClose() {
        this._frameManager.dispose();
        utils_1.assert(this._closedState !== "closed", "Page closed twice");
        this._closedState = "closed";
        this.emit(Page.Events.Close);
        this._closedCallback();
      }
      _didCrash() {
        this._frameManager.dispose();
        this.emit(Page.Events.Crash);
        this._crashedCallback(new Error("Page crashed"));
      }
      _didDisconnect() {
        this._frameManager.dispose();
        utils_1.assert(!this._disconnected, "Page disconnected twice");
        this._disconnected = true;
        this._disconnectedCallback(new Error("Page closed"));
      }
      async _onFileChooserOpened(handle) {
        let multiple;
        try {
          multiple = await handle.evaluate((element) => !!element.multiple);
        } catch (e) {
          return;
        }
        if (!this.listenerCount(Page.Events.FileChooser)) {
          handle.dispose();
          return;
        }
        const fileChooser = new fileChooser_1.FileChooser(this, handle, multiple);
        this.emit(Page.Events.FileChooser, fileChooser);
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return this._opener;
      }
      mainFrame() {
        return this._frameManager.mainFrame();
      }
      frames() {
        return this._frameManager.frames();
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async exposeBinding(name, needsHandle, playwrightBinding, world = "main") {
        const identifier = PageBinding.identifier(name, world);
        if (this._pageBindings.has(identifier))
          throw new Error(`Function "${name}" has been already registered`);
        if (this._browserContext._pageBindings.has(identifier))
          throw new Error(`Function "${name}" has been already registered in the browser context`);
        const binding = new PageBinding(name, playwrightBinding, needsHandle, world);
        this._pageBindings.set(identifier, binding);
        await this._delegate.exposeBinding(binding);
      }
      setExtraHTTPHeaders(headers) {
        this._state.extraHTTPHeaders = headers;
        return this._delegate.updateExtraHTTPHeaders();
      }
      async _onBindingCalled(payload, context) {
        if (this._disconnected || this._closedState === "closed")
          return;
        await PageBinding.dispatch(this, payload, context);
      }
      _addConsoleMessage(type, args, location2, text) {
        const message = new console_1.ConsoleMessage(this, type, text, args, location2);
        const intercepted = this._frameManager.interceptConsoleMessage(message);
        if (intercepted || !this.listenerCount(Page.Events.Console))
          args.forEach((arg) => arg.dispose());
        else
          this.emit(Page.Events.Console, message);
      }
      async reload(metadata, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this.mainFrame().raceNavigationAction(async () => {
          const [response] = await Promise.all([
            this.mainFrame()._waitForNavigation(progress, options2),
            this._delegate.reload()
          ]);
          await this._doSlowMo();
          return response;
        }), this._timeoutSettings.navigationTimeout(options2));
      }
      async goBack(metadata, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this.mainFrame().raceNavigationAction(async () => {
          let error3;
          const waitPromise = this.mainFrame()._waitForNavigation(progress, options2).catch((e) => {
            error3 = e;
            return null;
          });
          const result = await this._delegate.goBack();
          if (!result)
            return null;
          const response = await waitPromise;
          if (error3)
            throw error3;
          await this._doSlowMo();
          return response;
        }), this._timeoutSettings.navigationTimeout(options2));
      }
      async goForward(metadata, options2) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this.mainFrame().raceNavigationAction(async () => {
          let error3;
          const waitPromise = this.mainFrame()._waitForNavigation(progress, options2).catch((e) => {
            error3 = e;
            return null;
          });
          const result = await this._delegate.goForward();
          if (!result)
            return null;
          const response = await waitPromise;
          if (error3)
            throw error3;
          await this._doSlowMo();
          return response;
        }), this._timeoutSettings.navigationTimeout(options2));
      }
      async emulateMedia(options2) {
        if (options2.media !== void 0)
          utils_1.assert(options2.media === null || types2.mediaTypes.has(options2.media), "media: expected one of (screen|print|null)");
        if (options2.colorScheme !== void 0)
          utils_1.assert(options2.colorScheme === null || types2.colorSchemes.has(options2.colorScheme), "colorScheme: expected one of (dark|light|no-preference|null)");
        if (options2.media !== void 0)
          this._state.mediaType = options2.media;
        if (options2.colorScheme !== void 0)
          this._state.colorScheme = options2.colorScheme;
        await this._delegate.updateEmulateMedia();
        await this._doSlowMo();
      }
      async setViewportSize(viewportSize) {
        this._state.emulatedSize = {viewport: {...viewportSize}, screen: {...viewportSize}};
        await this._delegate.setEmulatedSize(this._state.emulatedSize);
        await this._doSlowMo();
      }
      viewportSize() {
        var _a;
        return ((_a = this._state.emulatedSize) === null || _a === void 0 ? void 0 : _a.viewport) || null;
      }
      async bringToFront() {
        await this._delegate.bringToFront();
      }
      async _addInitScriptExpression(source) {
        this._evaluateOnNewDocumentSources.push(source);
        await this._delegate.evaluateOnNewDocument(source);
      }
      _needsRequestInterception() {
        return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
      }
      async _setClientRequestInterceptor(handler2) {
        this._clientRequestInterceptor = handler2;
        await this._delegate.updateRequestInterception();
      }
      async _setServerRequestInterceptor(handler2) {
        this._serverRequestInterceptor = handler2;
        await this._delegate.updateRequestInterception();
      }
      _requestStarted(request) {
        this.emit(Page.Events.Request, request);
        const route = request._route();
        if (!route)
          return;
        if (this._serverRequestInterceptor) {
          this._serverRequestInterceptor(route, request);
          return;
        }
        if (this._clientRequestInterceptor) {
          this._clientRequestInterceptor(route, request);
          return;
        }
        if (this._browserContext._requestInterceptor) {
          this._browserContext._requestInterceptor(route, request);
          return;
        }
        route.continue();
      }
      async screenshot(metadata, options2 = {}) {
        const controller = new progress_1.ProgressController(metadata, this);
        return controller.run((progress) => this._screenshotter.screenshotPage(progress, options2), this._timeoutSettings.timeout(options2));
      }
      async close(metadata, options2) {
        if (this._closedState === "closed")
          return;
        const runBeforeUnload = !!options2 && !!options2.runBeforeUnload;
        if (this._closedState !== "closing") {
          this._closedState = "closing";
          utils_1.assert(!this._disconnected, "Protocol error: Connection closed. Most likely the page has been closed.");
          await this._delegate.closePage(runBeforeUnload).catch((e) => debugLogger_1.debugLogger.log("error", e));
        }
        if (!runBeforeUnload)
          await this._closedPromise;
        if (this._ownedContext)
          await this._ownedContext.close(metadata);
      }
      _setIsError(error3) {
        this._pageIsError = error3;
        if (!this._frameManager.mainFrame())
          this._frameManager.frameAttached("<dummy>", null);
      }
      isClosed() {
        return this._closedState === "closed";
      }
      _addWorker(workerId, worker) {
        this._workers.set(workerId, worker);
        this.emit(Page.Events.Worker, worker);
      }
      _removeWorker(workerId) {
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.emit(Worker.Events.Close, worker);
        this._workers.delete(workerId);
      }
      _clearWorkers() {
        for (const [workerId, worker] of this._workers) {
          worker.emit(Worker.Events.Close, worker);
          this._workers.delete(workerId);
        }
      }
      async _setFileChooserIntercepted(enabled) {
        await this._delegate.setFileChooserIntercepted(enabled);
      }
      frameNavigatedToNewDocument(frame) {
        this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);
        const url = frame.url();
        if (!url.startsWith("http"))
          return;
        const purl = network.parsedURL(url);
        if (purl)
          this._browserContext.addVisitedOrigin(purl.origin);
      }
      allBindings() {
        return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
      }
      getBinding(name, world) {
        const identifier = PageBinding.identifier(name, world);
        return this._pageBindings.get(identifier) || this._browserContext._pageBindings.get(identifier);
      }
      setScreencastEnabled(enabled) {
        this._delegate.setScreencastEnabled(enabled).catch(() => {
        });
      }
    };
    exports2.Page = Page;
    Page.Events = {
      Close: "close",
      Crash: "crash",
      Console: "console",
      Dialog: "dialog",
      InternalDialogClosed: "internaldialogclosed",
      Download: "download",
      FileChooser: "filechooser",
      DOMContentLoaded: "domcontentloaded",
      PageError: "pageerror",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      FrameAttached: "frameattached",
      FrameDetached: "framedetached",
      InternalFrameNavigatedToNewDocument: "internalframenavigatedtonewdocument",
      Load: "load",
      ScreencastFrame: "screencastframe",
      Video: "video",
      WebSocket: "websocket",
      Worker: "worker"
    };
    var Worker = class extends instrumentation_1.SdkObject {
      constructor(parent, url) {
        super(parent, "worker");
        this._existingExecutionContext = null;
        this._url = url;
        this._executionContextCallback = () => {
        };
        this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
      }
      _createExecutionContext(delegate) {
        this._existingExecutionContext = new js.ExecutionContext(this, delegate);
        this._executionContextCallback(this._existingExecutionContext);
      }
      url() {
        return this._url;
      }
      async evaluateExpression(expression, isFunction, arg) {
        return js.evaluateExpression(await this._executionContextPromise, true, expression, isFunction, arg);
      }
      async evaluateExpressionHandle(expression, isFunction, arg) {
        return js.evaluateExpression(await this._executionContextPromise, false, expression, isFunction, arg);
      }
    };
    exports2.Worker = Worker;
    Worker.Events = {
      Close: "close"
    };
    var PageBinding = class {
      constructor(name, playwrightFunction, needsHandle, world) {
        this.name = name;
        this.playwrightFunction = playwrightFunction;
        this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle})`;
        this.needsHandle = needsHandle;
        this.world = world;
      }
      static identifier(name, world) {
        return world + ":" + name;
      }
      static async dispatch(page, payload, context) {
        const {name, seq, args} = JSON.parse(payload);
        try {
          utils_1.assert(context.world);
          const binding = page.getBinding(name, context.world);
          let result;
          if (binding.needsHandle) {
            const handle = await context.evaluateHandle(takeHandle, {name, seq}).catch((e) => null);
            result = await binding.playwrightFunction({frame: context.frame, page, context: page._browserContext}, handle);
          } else {
            result = await binding.playwrightFunction({frame: context.frame, page, context: page._browserContext}, ...args);
          }
          context.evaluate(deliverResult, {name, seq, result}).catch((e) => debugLogger_1.debugLogger.log("error", e));
        } catch (error3) {
          if (utils_1.isError(error3))
            context.evaluate(deliverError, {name, seq, message: error3.message, stack: error3.stack}).catch((e) => debugLogger_1.debugLogger.log("error", e));
          else
            context.evaluate(deliverErrorValue, {name, seq, error: error3}).catch((e) => debugLogger_1.debugLogger.log("error", e));
        }
        function takeHandle(arg) {
          const handle = window[arg.name]["handles"].get(arg.seq);
          window[arg.name]["handles"].delete(arg.seq);
          return handle;
        }
        function deliverResult(arg) {
          window[arg.name]["callbacks"].get(arg.seq).resolve(arg.result);
          window[arg.name]["callbacks"].delete(arg.seq);
        }
        function deliverError(arg) {
          const error3 = new Error(arg.message);
          error3.stack = arg.stack;
          window[arg.name]["callbacks"].get(arg.seq).reject(error3);
          window[arg.name]["callbacks"].delete(arg.seq);
        }
        function deliverErrorValue(arg) {
          window[arg.name]["callbacks"].get(arg.seq).reject(arg.error);
          window[arg.name]["callbacks"].delete(arg.seq);
        }
      }
    };
    exports2.PageBinding = PageBinding;
    function addPageBinding(bindingName, needsHandle) {
      const binding = window[bindingName];
      if (binding.__installed)
        return;
      window[bindingName] = (...args) => {
        const me = window[bindingName];
        if (needsHandle && args.slice(1).some((arg) => arg !== void 0))
          throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
        let callbacks = me["callbacks"];
        if (!callbacks) {
          callbacks = new Map();
          me["callbacks"] = callbacks;
        }
        const seq = (me["lastSeq"] || 0) + 1;
        me["lastSeq"] = seq;
        let handles = me["handles"];
        if (!handles) {
          handles = new Map();
          me["handles"] = handles;
        }
        const promise = new Promise((resolve2, reject) => callbacks.set(seq, {resolve: resolve2, reject}));
        if (needsHandle) {
          handles.set(seq, args[0]);
          binding(JSON.stringify({name: bindingName, seq}));
        } else {
          binding(JSON.stringify({name: bindingName, seq, args}));
        }
        return promise;
      };
      window[bindingName].__installed = true;
    }
  }
});

// node_modules/playwright/lib/server/common/cssTokenizer.js
var require_cssTokenizer = __commonJS({
  "node_modules/playwright/lib/server/common/cssTokenizer.js"(exports2) {
    "use strict";
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports2 !== "undefined") {
        factory(exports2);
      } else {
        factory(root);
      }
    })(exports2, function(exports3) {
      var between = function(num, first, last) {
        return num >= first && num <= last;
      };
      function digit(code) {
        return between(code, 48, 57);
      }
      function hexdigit(code) {
        return digit(code) || between(code, 65, 70) || between(code, 97, 102);
      }
      function uppercaseletter(code) {
        return between(code, 65, 90);
      }
      function lowercaseletter(code) {
        return between(code, 97, 122);
      }
      function letter(code) {
        return uppercaseletter(code) || lowercaseletter(code);
      }
      function nonascii(code) {
        return code >= 128;
      }
      function namestartchar(code) {
        return letter(code) || nonascii(code) || code == 95;
      }
      function namechar(code) {
        return namestartchar(code) || digit(code) || code == 45;
      }
      function nonprintable(code) {
        return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;
      }
      function newline(code) {
        return code == 10;
      }
      function whitespace(code) {
        return newline(code) || code == 9 || code == 32;
      }
      function badescape(code) {
        return newline(code) || isNaN(code);
      }
      var maximumallowedcodepoint = 1114111;
      var InvalidCharacterError = function(message) {
        this.message = message;
      };
      InvalidCharacterError.prototype = new Error();
      InvalidCharacterError.prototype.name = "InvalidCharacterError";
      function preprocess(str) {
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (code == 13 && str.charCodeAt(i + 1) == 10) {
            code = 10;
            i++;
          }
          if (code == 13 || code == 12)
            code = 10;
          if (code == 0)
            code = 65533;
          if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
            var lead = code - 55296;
            var trail = str.charCodeAt(i + 1) - 56320;
            code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
            i++;
          }
          codepoints.push(code);
        }
        return codepoints;
      }
      function stringFromCode(code) {
        if (code <= 65535)
          return String.fromCharCode(code);
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 55296;
        var trail = code % Math.pow(2, 10) + 56320;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
      }
      function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        var line = 0;
        var column = 0;
        var lastLineLength = 0;
        var incrLineno = function() {
          line += 1;
          lastLineLength = column;
          column = 0;
        };
        var locStart = {line, column};
        var codepoint = function(i2) {
          if (i2 >= str.length) {
            return -1;
          }
          return str[i2];
        };
        var next = function(num) {
          if (num === void 0)
            num = 1;
          if (num > 3)
            throw "Spec Error: no more than three codepoints of lookahead.";
          return codepoint(i + num);
        };
        var consume = function(num) {
          if (num === void 0)
            num = 1;
          i += num;
          code = codepoint(i);
          if (newline(code))
            incrLineno();
          else
            column += num;
          return true;
        };
        var reconsume = function() {
          i -= 1;
          if (newline(code)) {
            line -= 1;
            column = lastLineLength;
          } else {
            column -= 1;
          }
          locStart.line = line;
          locStart.column = column;
          return true;
        };
        var eof = function(codepoint2) {
          if (codepoint2 === void 0)
            codepoint2 = code;
          return codepoint2 == -1;
        };
        var donothing = function() {
        };
        var parseerror = function() {
          console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");
          return true;
        };
        var consumeAToken = function() {
          consumeComments();
          consume();
          if (whitespace(code)) {
            while (whitespace(next()))
              consume();
            return new WhitespaceToken();
          } else if (code == 34)
            return consumeAStringToken();
          else if (code == 35) {
            if (namechar(next()) || areAValidEscape(next(1), next(2))) {
              var token = new HashToken();
              if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                token.type = "id";
              token.value = consumeAName();
              return token;
            } else {
              return new DelimToken(code);
            }
          } else if (code == 36) {
            if (next() == 61) {
              consume();
              return new SuffixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 39)
            return consumeAStringToken();
          else if (code == 40)
            return new OpenParenToken();
          else if (code == 41)
            return new CloseParenToken();
          else if (code == 42) {
            if (next() == 61) {
              consume();
              return new SubstringMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 43) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 44)
            return new CommaToken();
          else if (code == 45) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else if (next(1) == 45 && next(2) == 62) {
              consume(2);
              return new CDCToken();
            } else if (startsWithAnIdentifier()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 46) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 58)
            return new ColonToken();
          else if (code == 59)
            return new SemicolonToken();
          else if (code == 60) {
            if (next(1) == 33 && next(2) == 45 && next(3) == 45) {
              consume(3);
              return new CDOToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 64) {
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
              return new AtKeywordToken(consumeAName());
            } else {
              return new DelimToken(code);
            }
          } else if (code == 91)
            return new OpenSquareToken();
          else if (code == 92) {
            if (startsWithAValidEscape()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              parseerror();
              return new DelimToken(code);
            }
          } else if (code == 93)
            return new CloseSquareToken();
          else if (code == 94) {
            if (next() == 61) {
              consume();
              return new PrefixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 123)
            return new OpenCurlyToken();
          else if (code == 124) {
            if (next() == 61) {
              consume();
              return new DashMatchToken();
            } else if (next() == 124) {
              consume();
              return new ColumnToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 125)
            return new CloseCurlyToken();
          else if (code == 126) {
            if (next() == 61) {
              consume();
              return new IncludeMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (digit(code)) {
            reconsume();
            return consumeANumericToken();
          } else if (namestartchar(code)) {
            reconsume();
            return consumeAnIdentlikeToken();
          } else if (eof())
            return new EOFToken();
          else
            return new DelimToken(code);
        };
        var consumeComments = function() {
          while (next(1) == 47 && next(2) == 42) {
            consume(2);
            while (true) {
              consume();
              if (code == 42 && next() == 47) {
                consume();
                break;
              } else if (eof()) {
                parseerror();
                return;
              }
            }
          }
        };
        var consumeANumericToken = function() {
          var num = consumeANumber();
          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
            var token = new DimensionToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            token.unit = consumeAName();
            return token;
          } else if (next() == 37) {
            consume();
            var token = new PercentageToken();
            token.value = num.value;
            token.repr = num.repr;
            return token;
          } else {
            var token = new NumberToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            return token;
          }
        };
        var consumeAnIdentlikeToken = function() {
          var str2 = consumeAName();
          if (str2.toLowerCase() == "url" && next() == 40) {
            consume();
            while (whitespace(next(1)) && whitespace(next(2)))
              consume();
            if (next() == 34 || next() == 39) {
              return new FunctionToken(str2);
            } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {
              return new FunctionToken(str2);
            } else {
              return consumeAURLToken();
            }
          } else if (next() == 40) {
            consume();
            return new FunctionToken(str2);
          } else {
            return new IdentToken(str2);
          }
        };
        var consumeAStringToken = function(endingCodePoint) {
          if (endingCodePoint === void 0)
            endingCodePoint = code;
          var string = "";
          while (consume()) {
            if (code == endingCodePoint || eof()) {
              return new StringToken(string);
            } else if (newline(code)) {
              parseerror();
              reconsume();
              return new BadStringToken();
            } else if (code == 92) {
              if (eof(next())) {
                donothing();
              } else if (newline(next())) {
                consume();
              } else {
                string += stringFromCode(consumeEscape());
              }
            } else {
              string += stringFromCode(code);
            }
          }
        };
        var consumeAURLToken = function() {
          var token = new URLToken("");
          while (whitespace(next()))
            consume();
          if (eof(next()))
            return token;
          while (consume()) {
            if (code == 41 || eof()) {
              return token;
            } else if (whitespace(code)) {
              while (whitespace(next()))
                consume();
              if (next() == 41 || eof(next())) {
                consume();
                return token;
              } else {
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {
              parseerror();
              consumeTheRemnantsOfABadURL();
              return new BadURLToken();
            } else if (code == 92) {
              if (startsWithAValidEscape()) {
                token.value += stringFromCode(consumeEscape());
              } else {
                parseerror();
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else {
              token.value += stringFromCode(code);
            }
          }
        };
        var consumeEscape = function() {
          consume();
          if (hexdigit(code)) {
            var digits = [code];
            for (var total = 0; total < 5; total++) {
              if (hexdigit(next())) {
                consume();
                digits.push(code);
              } else {
                break;
              }
            }
            if (whitespace(next()))
              consume();
            var value = parseInt(digits.map(function(x) {
              return String.fromCharCode(x);
            }).join(""), 16);
            if (value > maximumallowedcodepoint)
              value = 65533;
            return value;
          } else if (eof()) {
            return 65533;
          } else {
            return code;
          }
        };
        var areAValidEscape = function(c1, c2) {
          if (c1 != 92)
            return false;
          if (newline(c2))
            return false;
          return true;
        };
        var startsWithAValidEscape = function() {
          return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function(c1, c2, c3) {
          if (c1 == 45) {
            return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);
          } else if (namestartchar(c1)) {
            return true;
          } else if (c1 == 92) {
            return areAValidEscape(c1, c2);
          } else {
            return false;
          }
        };
        var startsWithAnIdentifier = function() {
          return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function(c1, c2, c3) {
          if (c1 == 43 || c1 == 45) {
            if (digit(c2))
              return true;
            if (c2 == 46 && digit(c3))
              return true;
            return false;
          } else if (c1 == 46) {
            if (digit(c2))
              return true;
            return false;
          } else if (digit(c1)) {
            return true;
          } else {
            return false;
          }
        };
        var startsWithANumber = function() {
          return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function() {
          var result = "";
          while (consume()) {
            if (namechar(code)) {
              result += stringFromCode(code);
            } else if (startsWithAValidEscape()) {
              result += stringFromCode(consumeEscape());
            } else {
              reconsume();
              return result;
            }
          }
        };
        var consumeANumber = function() {
          var repr = [];
          var type = "integer";
          if (next() == 43 || next() == 45) {
            consume();
            repr += stringFromCode(code);
          }
          while (digit(next())) {
            consume();
            repr += stringFromCode(code);
          }
          if (next(1) == 46 && digit(next(2))) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var c1 = next(1), c2 = next(2), c3 = next(3);
          if ((c1 == 69 || c1 == 101) && digit(c2)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var value = convertAStringToANumber(repr);
          return {type, value, repr};
        };
        var convertAStringToANumber = function(string) {
          return +string;
        };
        var consumeTheRemnantsOfABadURL = function() {
          while (consume()) {
            if (code == 41 || eof()) {
              return;
            } else if (startsWithAValidEscape()) {
              consumeEscape();
              donothing();
            } else {
              donothing();
            }
          }
        };
        var iterationCount = 0;
        while (!eof(next())) {
          tokens.push(consumeAToken());
          iterationCount++;
          if (iterationCount > str.length * 2)
            return "I'm infinite-looping!";
        }
        return tokens;
      }
      function CSSParserToken() {
        throw "Abstract Base Class";
      }
      CSSParserToken.prototype.toJSON = function() {
        return {token: this.tokenType};
      };
      CSSParserToken.prototype.toString = function() {
        return this.tokenType;
      };
      CSSParserToken.prototype.toSource = function() {
        return "" + this;
      };
      function BadStringToken() {
        return this;
      }
      BadStringToken.prototype = Object.create(CSSParserToken.prototype);
      BadStringToken.prototype.tokenType = "BADSTRING";
      function BadURLToken() {
        return this;
      }
      BadURLToken.prototype = Object.create(CSSParserToken.prototype);
      BadURLToken.prototype.tokenType = "BADURL";
      function WhitespaceToken() {
        return this;
      }
      WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
      WhitespaceToken.prototype.tokenType = "WHITESPACE";
      WhitespaceToken.prototype.toString = function() {
        return "WS";
      };
      WhitespaceToken.prototype.toSource = function() {
        return " ";
      };
      function CDOToken() {
        return this;
      }
      CDOToken.prototype = Object.create(CSSParserToken.prototype);
      CDOToken.prototype.tokenType = "CDO";
      CDOToken.prototype.toSource = function() {
        return "<!--";
      };
      function CDCToken() {
        return this;
      }
      CDCToken.prototype = Object.create(CSSParserToken.prototype);
      CDCToken.prototype.tokenType = "CDC";
      CDCToken.prototype.toSource = function() {
        return "-->";
      };
      function ColonToken() {
        return this;
      }
      ColonToken.prototype = Object.create(CSSParserToken.prototype);
      ColonToken.prototype.tokenType = ":";
      function SemicolonToken() {
        return this;
      }
      SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
      SemicolonToken.prototype.tokenType = ";";
      function CommaToken() {
        return this;
      }
      CommaToken.prototype = Object.create(CSSParserToken.prototype);
      CommaToken.prototype.tokenType = ",";
      function GroupingToken() {
        throw "Abstract Base Class";
      }
      GroupingToken.prototype = Object.create(CSSParserToken.prototype);
      function OpenCurlyToken() {
        this.value = "{";
        this.mirror = "}";
        return this;
      }
      OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
      OpenCurlyToken.prototype.tokenType = "{";
      function CloseCurlyToken() {
        this.value = "}";
        this.mirror = "{";
        return this;
      }
      CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
      CloseCurlyToken.prototype.tokenType = "}";
      function OpenSquareToken() {
        this.value = "[";
        this.mirror = "]";
        return this;
      }
      OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
      OpenSquareToken.prototype.tokenType = "[";
      function CloseSquareToken() {
        this.value = "]";
        this.mirror = "[";
        return this;
      }
      CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
      CloseSquareToken.prototype.tokenType = "]";
      function OpenParenToken() {
        this.value = "(";
        this.mirror = ")";
        return this;
      }
      OpenParenToken.prototype = Object.create(GroupingToken.prototype);
      OpenParenToken.prototype.tokenType = "(";
      function CloseParenToken() {
        this.value = ")";
        this.mirror = "(";
        return this;
      }
      CloseParenToken.prototype = Object.create(GroupingToken.prototype);
      CloseParenToken.prototype.tokenType = ")";
      function IncludeMatchToken() {
        return this;
      }
      IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
      IncludeMatchToken.prototype.tokenType = "~=";
      function DashMatchToken() {
        return this;
      }
      DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
      DashMatchToken.prototype.tokenType = "|=";
      function PrefixMatchToken() {
        return this;
      }
      PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      PrefixMatchToken.prototype.tokenType = "^=";
      function SuffixMatchToken() {
        return this;
      }
      SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SuffixMatchToken.prototype.tokenType = "$=";
      function SubstringMatchToken() {
        return this;
      }
      SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SubstringMatchToken.prototype.tokenType = "*=";
      function ColumnToken() {
        return this;
      }
      ColumnToken.prototype = Object.create(CSSParserToken.prototype);
      ColumnToken.prototype.tokenType = "||";
      function EOFToken() {
        return this;
      }
      EOFToken.prototype = Object.create(CSSParserToken.prototype);
      EOFToken.prototype.tokenType = "EOF";
      EOFToken.prototype.toSource = function() {
        return "";
      };
      function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
      }
      DelimToken.prototype = Object.create(CSSParserToken.prototype);
      DelimToken.prototype.tokenType = "DELIM";
      DelimToken.prototype.toString = function() {
        return "DELIM(" + this.value + ")";
      };
      DelimToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      DelimToken.prototype.toSource = function() {
        if (this.value == "\\")
          return "\\\n";
        else
          return this.value;
      };
      function StringValuedToken() {
        throw "Abstract Base Class";
      }
      StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
      StringValuedToken.prototype.ASCIIMatch = function(str) {
        return this.value.toLowerCase() == str.toLowerCase();
      };
      StringValuedToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      function IdentToken(val) {
        this.value = val;
      }
      IdentToken.prototype = Object.create(StringValuedToken.prototype);
      IdentToken.prototype.tokenType = "IDENT";
      IdentToken.prototype.toString = function() {
        return "IDENT(" + this.value + ")";
      };
      IdentToken.prototype.toSource = function() {
        return escapeIdent(this.value);
      };
      function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
      }
      FunctionToken.prototype = Object.create(StringValuedToken.prototype);
      FunctionToken.prototype.tokenType = "FUNCTION";
      FunctionToken.prototype.toString = function() {
        return "FUNCTION(" + this.value + ")";
      };
      FunctionToken.prototype.toSource = function() {
        return escapeIdent(this.value) + "(";
      };
      function AtKeywordToken(val) {
        this.value = val;
      }
      AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
      AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
      AtKeywordToken.prototype.toString = function() {
        return "AT(" + this.value + ")";
      };
      AtKeywordToken.prototype.toSource = function() {
        return "@" + escapeIdent(this.value);
      };
      function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
      }
      HashToken.prototype = Object.create(StringValuedToken.prototype);
      HashToken.prototype.tokenType = "HASH";
      HashToken.prototype.toString = function() {
        return "HASH(" + this.value + ")";
      };
      HashToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
      };
      HashToken.prototype.toSource = function() {
        if (this.type == "id") {
          return "#" + escapeIdent(this.value);
        } else {
          return "#" + escapeHash(this.value);
        }
      };
      function StringToken(val) {
        this.value = val;
      }
      StringToken.prototype = Object.create(StringValuedToken.prototype);
      StringToken.prototype.tokenType = "STRING";
      StringToken.prototype.toString = function() {
        return '"' + escapeString(this.value) + '"';
      };
      function URLToken(val) {
        this.value = val;
      }
      URLToken.prototype = Object.create(StringValuedToken.prototype);
      URLToken.prototype.tokenType = "URL";
      URLToken.prototype.toString = function() {
        return "URL(" + this.value + ")";
      };
      URLToken.prototype.toSource = function() {
        return 'url("' + escapeString(this.value) + '")';
      };
      function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
      }
      NumberToken.prototype = Object.create(CSSParserToken.prototype);
      NumberToken.prototype.tokenType = "NUMBER";
      NumberToken.prototype.toString = function() {
        if (this.type == "integer")
          return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
      };
      NumberToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
      };
      NumberToken.prototype.toSource = function() {
        return this.repr;
      };
      function PercentageToken() {
        this.value = null;
        this.repr = "";
      }
      PercentageToken.prototype = Object.create(CSSParserToken.prototype);
      PercentageToken.prototype.tokenType = "PERCENTAGE";
      PercentageToken.prototype.toString = function() {
        return "PERCENTAGE(" + this.value + ")";
      };
      PercentageToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
      };
      PercentageToken.prototype.toSource = function() {
        return this.repr + "%";
      };
      function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
      }
      DimensionToken.prototype = Object.create(CSSParserToken.prototype);
      DimensionToken.prototype.tokenType = "DIMENSION";
      DimensionToken.prototype.toString = function() {
        return "DIM(" + this.value + "," + this.unit + ")";
      };
      DimensionToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
      };
      DimensionToken.prototype.toSource = function() {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 48, 57))) {
          unit = "\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
      };
      function escapeIdent(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {
            result += "\\" + code.toString(16) + " ";
          } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + string[i];
          }
        }
        return result;
      }
      function escapeHash(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + code.toString(16) + " ";
          }
        }
        return result;
      }
      function escapeString(string) {
        string = "" + string;
        var result = "";
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127) {
            result += "\\" + code.toString(16) + " ";
          } else if (code == 34 || code == 92) {
            result += "\\" + string[i];
          } else {
            result += string[i];
          }
        }
        return result;
      }
      exports3.tokenize = tokenize;
      exports3.IdentToken = IdentToken;
      exports3.FunctionToken = FunctionToken;
      exports3.AtKeywordToken = AtKeywordToken;
      exports3.HashToken = HashToken;
      exports3.StringToken = StringToken;
      exports3.BadStringToken = BadStringToken;
      exports3.URLToken = URLToken;
      exports3.BadURLToken = BadURLToken;
      exports3.DelimToken = DelimToken;
      exports3.NumberToken = NumberToken;
      exports3.PercentageToken = PercentageToken;
      exports3.DimensionToken = DimensionToken;
      exports3.IncludeMatchToken = IncludeMatchToken;
      exports3.DashMatchToken = DashMatchToken;
      exports3.PrefixMatchToken = PrefixMatchToken;
      exports3.SuffixMatchToken = SuffixMatchToken;
      exports3.SubstringMatchToken = SubstringMatchToken;
      exports3.ColumnToken = ColumnToken;
      exports3.WhitespaceToken = WhitespaceToken;
      exports3.CDOToken = CDOToken;
      exports3.CDCToken = CDCToken;
      exports3.ColonToken = ColonToken;
      exports3.SemicolonToken = SemicolonToken;
      exports3.CommaToken = CommaToken;
      exports3.OpenParenToken = OpenParenToken;
      exports3.CloseParenToken = CloseParenToken;
      exports3.OpenSquareToken = OpenSquareToken;
      exports3.CloseSquareToken = CloseSquareToken;
      exports3.OpenCurlyToken = OpenCurlyToken;
      exports3.CloseCurlyToken = CloseCurlyToken;
      exports3.EOFToken = EOFToken;
      exports3.CSSParserToken = CSSParserToken;
      exports3.GroupingToken = GroupingToken;
    });
  }
});

// node_modules/playwright/lib/server/common/cssParser.js
var require_cssParser = __commonJS({
  "node_modules/playwright/lib/server/common/cssParser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.serializeSelector = exports2.parseCSS = void 0;
    var css2 = __importStar(require_cssTokenizer());
    function parseCSS(selector, customNames) {
      let tokens;
      try {
        tokens = css2.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css2.EOFToken))
          tokens.push(new css2.EOFToken());
      } catch (e) {
        const newMessage = e.message + ` while parsing selector "${selector}"`;
        const index2 = (e.stack || "").indexOf(e.message);
        if (index2 !== -1)
          e.stack = e.stack.substring(0, index2) + newMessage + e.stack.substring(index2 + e.message.length);
        e.message = newMessage;
        throw e;
      }
      const unsupportedToken = tokens.find((token) => {
        return token instanceof css2.AtKeywordToken || token instanceof css2.BadStringToken || token instanceof css2.BadURLToken || token instanceof css2.ColumnToken || token instanceof css2.CDOToken || token instanceof css2.CDCToken || token instanceof css2.SemicolonToken || token instanceof css2.OpenCurlyToken || token instanceof css2.CloseCurlyToken || token instanceof css2.URLToken || token instanceof css2.PercentageToken;
      });
      if (unsupportedToken)
        throw new Error(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);
      let pos = 0;
      const names = new Set();
      function unexpected() {
        return new Error(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);
      }
      function skipWhitespace() {
        while (tokens[pos] instanceof css2.WhitespaceToken)
          pos++;
      }
      function isIdent(p = pos) {
        return tokens[p] instanceof css2.IdentToken;
      }
      function isString(p = pos) {
        return tokens[p] instanceof css2.StringToken;
      }
      function isNumber(p = pos) {
        return tokens[p] instanceof css2.NumberToken;
      }
      function isComma(p = pos) {
        return tokens[p] instanceof css2.CommaToken;
      }
      function isCloseParen(p = pos) {
        return tokens[p] instanceof css2.CloseParenToken;
      }
      function isStar(p = pos) {
        return tokens[p] instanceof css2.DelimToken && tokens[p].value === "*";
      }
      function isEOF(p = pos) {
        return tokens[p] instanceof css2.EOFToken;
      }
      function isClauseCombinator(p = pos) {
        return tokens[p] instanceof css2.DelimToken && [">", "+", "~"].includes(tokens[p].value);
      }
      function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css2.WhitespaceToken;
      }
      function consumeFunctionArguments() {
        const result2 = [consumeArgument()];
        while (true) {
          skipWhitespace();
          if (!isComma())
            break;
          pos++;
          result2.push(consumeArgument());
        }
        return result2;
      }
      function consumeArgument() {
        skipWhitespace();
        if (isNumber())
          return tokens[pos++].value;
        if (isString())
          return tokens[pos++].value;
        return consumeComplexSelector();
      }
      function consumeComplexSelector() {
        skipWhitespace();
        const result2 = {simples: [{selector: consumeSimpleSelector(), combinator: ""}]};
        while (true) {
          skipWhitespace();
          if (isClauseCombinator()) {
            result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;
            skipWhitespace();
          } else if (isSelectorClauseEnd()) {
            break;
          }
          result2.simples.push({combinator: "", selector: consumeSimpleSelector()});
        }
        return result2;
      }
      function consumeSimpleSelector() {
        let rawCSSString = "";
        const functions = [];
        while (!isSelectorClauseEnd()) {
          if (isIdent() || isStar()) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css2.HashToken) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css2.DelimToken && tokens[pos].value === ".") {
            pos++;
            if (isIdent())
              rawCSSString += "." + tokens[pos++].toSource();
            else
              throw unexpected();
          } else if (tokens[pos] instanceof css2.ColonToken) {
            pos++;
            if (isIdent()) {
              if (!customNames.has(tokens[pos].value.toLowerCase())) {
                rawCSSString += ":" + tokens[pos++].toSource();
              } else {
                const name = tokens[pos++].value.toLowerCase();
                functions.push({name, args: []});
                names.add(name);
              }
            } else if (tokens[pos] instanceof css2.FunctionToken) {
              const name = tokens[pos++].value.toLowerCase();
              if (!customNames.has(name)) {
                rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
              } else {
                functions.push({name, args: consumeFunctionArguments()});
                names.add(name);
              }
              skipWhitespace();
              if (!isCloseParen())
                throw unexpected();
              pos++;
            } else {
              throw unexpected();
            }
          } else if (tokens[pos] instanceof css2.OpenSquareToken) {
            rawCSSString += "[";
            pos++;
            while (!(tokens[pos] instanceof css2.CloseSquareToken) && !isEOF())
              rawCSSString += tokens[pos++].toSource();
            if (!(tokens[pos] instanceof css2.CloseSquareToken))
              throw unexpected();
            rawCSSString += "]";
            pos++;
          } else {
            throw unexpected();
          }
        }
        if (!rawCSSString && !functions.length)
          throw unexpected();
        return {css: rawCSSString || void 0, functions};
      }
      function consumeBuiltinFunctionArguments() {
        let s2 = "";
        while (!isCloseParen() && !isEOF())
          s2 += tokens[pos++].toSource();
        return s2;
      }
      const result = consumeFunctionArguments();
      if (!isEOF())
        throw new Error(`Error while parsing selector "${selector}"`);
      if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))
        throw new Error(`Error while parsing selector "${selector}"`);
      return {selector: result, names: Array.from(names)};
    }
    exports2.parseCSS = parseCSS;
    function serializeSelector(args) {
      return args.map((arg) => {
        if (typeof arg === "string")
          return `"${arg}"`;
        if (typeof arg === "number")
          return String(arg);
        return arg.simples.map(({selector, combinator}) => {
          let s2 = selector.css || "";
          s2 = s2 + selector.functions.map((func) => `:${func.name}(${serializeSelector(func.args)})`).join("");
          if (combinator)
            s2 += " " + combinator;
          return s2;
        }).join(" ");
      }).join(", ");
    }
    exports2.serializeSelector = serializeSelector;
  }
});

// node_modules/playwright/lib/server/common/selectorParser.js
var require_selectorParser = __commonJS({
  "node_modules/playwright/lib/server/common/selectorParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.parseSelector = exports2.customCSSNames = void 0;
    var cssParser_1 = require_cssParser();
    exports2.customCSSNames = new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);
    function parseSelector(selector) {
      const result = parseSelectorV1(selector);
      result.parts = result.parts.map((part) => {
        if (Array.isArray(part))
          return part;
        if (part.name === "css" || part.name === "css:light") {
          if (part.name === "css:light")
            part.body = ":light(" + part.body + ")";
          const parsedCSS = cssParser_1.parseCSS(part.body, exports2.customCSSNames);
          return parsedCSS.selector;
        }
        return part;
      });
      return {
        parts: result.parts,
        capture: result.capture
      };
    }
    exports2.parseSelector = parseSelector;
    function parseSelectorV1(selector) {
      let index2 = 0;
      let quote;
      let start = 0;
      const result = {parts: []};
      const append = () => {
        const part = selector.substring(start, index2).trim();
        const eqIndex = part.indexOf("=");
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
          name = part.substring(0, eqIndex).trim();
          body = part.substring(eqIndex + 1);
        } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
          name = "text";
          body = part;
        } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
          name = "text";
          body = part;
        } else if (/^\(*\/\//.test(part) || part.startsWith("..")) {
          name = "xpath";
          body = part;
        } else {
          name = "css";
          body = part;
        }
        let capture = false;
        if (name[0] === "*") {
          capture = true;
          name = name.substring(1);
        }
        result.parts.push({name, body});
        if (capture) {
          if (result.capture !== void 0)
            throw new Error(`Only one of the selectors can capture using * modifier`);
          result.capture = result.parts.length - 1;
        }
      };
      if (!selector.includes(">>")) {
        index2 = selector.length;
        append();
        return result;
      }
      while (index2 < selector.length) {
        const c = selector[index2];
        if (c === "\\" && index2 + 1 < selector.length) {
          index2 += 2;
        } else if (c === quote) {
          quote = void 0;
          index2++;
        } else if (!quote && (c === '"' || c === "'" || c === "`")) {
          quote = c;
          index2++;
        } else if (!quote && c === ">" && selector[index2 + 1] === ">") {
          append();
          index2 += 2;
          start = index2;
        } else {
          index2++;
        }
      }
      append();
      return result;
    }
  }
});

// node_modules/playwright/lib/server/selectors.js
var require_selectors = __commonJS({
  "node_modules/playwright/lib/server/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.serverSelectors = exports2.Selectors = void 0;
    var selectorParser_1 = require_selectorParser();
    var utils_1 = require_utils();
    var Selectors = class {
      constructor() {
        this.guid = `selectors@${utils_1.createGuid()}`;
        this._builtinEngines = new Set([
          "css",
          "css:light",
          "xpath",
          "xpath:light",
          "text",
          "text:light",
          "id",
          "id:light",
          "data-testid",
          "data-testid:light",
          "data-test-id",
          "data-test-id:light",
          "data-test",
          "data-test:light"
        ]);
        this._engines = new Map();
      }
      async register(name, source, contentScript = false) {
        if (!name.match(/^[a-zA-Z_0-9-]+$/))
          throw new Error("Selector engine name may only contain [a-zA-Z0-9_] characters");
        if (this._builtinEngines.has(name) || name === "zs" || name === "zs:light")
          throw new Error(`"${name}" is a predefined selector engine`);
        if (this._engines.has(name))
          throw new Error(`"${name}" selector engine has been already registered`);
        this._engines.set(name, {source, contentScript});
      }
      unregisterAll() {
        this._engines.clear();
      }
      async _query(frame, selector, scope) {
        const info = this._parseSelector(selector);
        const context = await frame._context(info.world);
        const injectedScript = await context.injectedScript();
        const handle = await injectedScript.evaluateHandle((injected, {parsed, scope: scope2}) => {
          return injected.querySelector(parsed, scope2 || document);
        }, {parsed: info.parsed, scope});
        const elementHandle = handle.asElement();
        if (!elementHandle) {
          handle.dispose();
          return null;
        }
        const mainContext = await frame._mainContext();
        return this._adoptIfNeeded(elementHandle, mainContext);
      }
      async _queryArray(frame, selector, scope) {
        const info = this._parseSelector(selector);
        const context = await frame._mainContext();
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, {parsed, scope: scope2}) => {
          return injected.querySelectorAll(parsed, scope2 || document);
        }, {parsed: info.parsed, scope});
        return arrayHandle;
      }
      async _queryAll(frame, selector, scope, adoptToMain) {
        const info = this._parseSelector(selector);
        const context = await frame._context(info.world);
        const injectedScript = await context.injectedScript();
        const arrayHandle = await injectedScript.evaluateHandle((injected, {parsed, scope: scope2}) => {
          return injected.querySelectorAll(parsed, scope2 || document);
        }, {parsed: info.parsed, scope});
        const properties = await arrayHandle.getProperties();
        arrayHandle.dispose();
        const targetContext = adoptToMain ? await frame._mainContext() : context;
        const result = [];
        for (const property of properties.values()) {
          const elementHandle = property.asElement();
          if (elementHandle)
            result.push(this._adoptIfNeeded(elementHandle, targetContext));
          else
            property.dispose();
        }
        return Promise.all(result);
      }
      async _adoptIfNeeded(handle, context) {
        if (handle._context === context)
          return handle;
        const adopted = handle._page._delegate.adoptElementHandle(handle, context);
        handle.dispose();
        return adopted;
      }
      _parseSelector(selector) {
        const parsed = selectorParser_1.parseSelector(selector);
        let needsMainWorld = false;
        for (const part of parsed.parts) {
          if (!Array.isArray(part)) {
            const custom = this._engines.get(part.name);
            if (!custom && !this._builtinEngines.has(part.name))
              throw new Error(`Unknown engine "${part.name}" while parsing selector ${selector}`);
            if (custom && !custom.contentScript)
              needsMainWorld = true;
          }
        }
        return {
          parsed,
          selector,
          world: needsMainWorld ? "main" : "utility"
        };
      }
    };
    exports2.Selectors = Selectors;
    exports2.serverSelectors = new Selectors();
  }
});

// node_modules/playwright/lib/server/supplements/debugger.js
var require_debugger = __commonJS({
  "node_modules/playwright/lib/server/supplements/debugger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Debugger = void 0;
    var events_1 = require("events");
    var utils_1 = require_utils();
    var debugLogger_1 = require_debugLogger();
    var symbol = Symbol("Debugger");
    var Debugger = class extends events_1.EventEmitter {
      constructor(context) {
        super();
        this._pauseOnNextStatement = false;
        this._pausedCallsMetadata = new Map();
        this._context = context;
        this._context[symbol] = this;
        this._enabled = utils_1.debugMode() === "inspector";
        if (this._enabled)
          this.pauseOnNextStatement();
      }
      static lookup(context) {
        if (!context)
          return;
        return context[symbol];
      }
      async onBeforeCall(sdkObject, metadata) {
        if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseOnStep(sdkObject, metadata))
          await this.pause(sdkObject, metadata);
      }
      async onBeforeInputAction(sdkObject, metadata) {
        if (this._enabled && this._pauseOnNextStatement)
          await this.pause(sdkObject, metadata);
      }
      async onCallLog(logName, message, sdkObject, metadata) {
        debugLogger_1.debugLogger.log(logName, message);
      }
      async pause(sdkObject, metadata) {
        this._enabled = true;
        metadata.pauseStartTime = utils_1.monotonicTime();
        const result = new Promise((resolve2) => {
          this._pausedCallsMetadata.set(metadata, {resolve: resolve2, sdkObject});
        });
        this.emit(Debugger.Events.PausedStateChanged);
        return result;
      }
      resume(step) {
        this._pauseOnNextStatement = step;
        const endTime = utils_1.monotonicTime();
        for (const [metadata, {resolve: resolve2}] of this._pausedCallsMetadata) {
          metadata.pauseEndTime = endTime;
          resolve2();
        }
        this._pausedCallsMetadata.clear();
        this.emit(Debugger.Events.PausedStateChanged);
      }
      pauseOnNextStatement() {
        this._pauseOnNextStatement = true;
      }
      isPaused(metadata) {
        if (metadata)
          return this._pausedCallsMetadata.has(metadata);
        return !!this._pausedCallsMetadata.size;
      }
      pausedDetails() {
        const result = [];
        for (const [metadata, {sdkObject}] of this._pausedCallsMetadata)
          result.push({metadata, sdkObject});
        return result;
      }
    };
    exports2.Debugger = Debugger;
    Debugger.Events = {
      PausedStateChanged: "pausedstatechanged"
    };
    function shouldPauseOnCall(sdkObject, metadata) {
      var _a;
      if (!((_a = sdkObject.attribution.browser) === null || _a === void 0 ? void 0 : _a.options.headful) && !utils_1.isUnderTest())
        return false;
      return metadata.method === "pause";
    }
    function shouldPauseOnStep(sdkObject, metadata) {
      return metadata.method === "goto" || metadata.method === "close";
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yazl/index.js
var require_yazl = __commonJS({
  "node_modules/yazl/index.js"(exports2) {
    var fs = require("fs");
    var Transform = require("stream").Transform;
    var PassThrough2 = require("stream").PassThrough;
    var zlib2 = require("zlib");
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var crc32 = require_buffer_crc32();
    exports2.ZipFile = ZipFile;
    exports2.dateToDosDateTime = dateToDosDateTime;
    util.inherits(ZipFile, EventEmitter);
    function ZipFile() {
      this.outputStream = new PassThrough2();
      this.entries = [];
      this.outputStreamCursor = 0;
      this.ended = false;
      this.allDone = false;
      this.forceZip64Eocd = false;
    }
    ZipFile.prototype.addFile = function(realPath, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options2 == null)
        options2 = {};
      var entry = new Entry(metadataPath, false, options2);
      self2.entries.push(entry);
      fs.stat(realPath, function(err, stats) {
        if (err)
          return self2.emit("error", err);
        if (!stats.isFile())
          return self2.emit("error", new Error("not a file: " + realPath));
        entry.uncompressedSize = stats.size;
        if (options2.mtime == null)
          entry.setLastModDate(stats.mtime);
        if (options2.mode == null)
          entry.setFileAttributesMode(stats.mode);
        entry.setFileDataPumpFunction(function() {
          var readStream = fs.createReadStream(realPath);
          entry.state = Entry.FILE_DATA_IN_PROGRESS;
          readStream.on("error", function(err2) {
            self2.emit("error", err2);
          });
          pumpFileDataReadStream(self2, entry, readStream);
        });
        pumpEntries(self2);
      });
    };
    ZipFile.prototype.addReadStream = function(readStream, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options2 == null)
        options2 = {};
      var entry = new Entry(metadataPath, false, options2);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        pumpFileDataReadStream(self2, entry, readStream);
      });
      pumpEntries(self2);
    };
    ZipFile.prototype.addBuffer = function(buffer, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (buffer.length > 1073741823)
        throw new Error("buffer too large: " + buffer.length + " > " + 1073741823);
      if (options2 == null)
        options2 = {};
      if (options2.size != null)
        throw new Error("options.size not allowed");
      var entry = new Entry(metadataPath, false, options2);
      entry.uncompressedSize = buffer.length;
      entry.crc32 = crc32.unsigned(buffer);
      entry.crcAndFileSizeKnown = true;
      self2.entries.push(entry);
      if (!entry.compress) {
        setCompressedBuffer(buffer);
      } else {
        zlib2.deflateRaw(buffer, function(err, compressedBuffer) {
          setCompressedBuffer(compressedBuffer);
        });
      }
      function setCompressedBuffer(compressedBuffer) {
        entry.compressedSize = compressedBuffer.length;
        entry.setFileDataPumpFunction(function() {
          writeToOutputStream(self2, compressedBuffer);
          writeToOutputStream(self2, entry.getDataDescriptor());
          entry.state = Entry.FILE_DATA_DONE;
          setImmediate(function() {
            pumpEntries(self2);
          });
        });
        pumpEntries(self2);
      }
    };
    ZipFile.prototype.addEmptyDirectory = function(metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, true);
      if (options2 == null)
        options2 = {};
      if (options2.size != null)
        throw new Error("options.size not allowed");
      if (options2.compress != null)
        throw new Error("options.compress not allowed");
      var entry = new Entry(metadataPath, true, options2);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
      pumpEntries(self2);
    };
    var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
    ZipFile.prototype.end = function(options2, finalSizeCallback) {
      if (typeof options2 === "function") {
        finalSizeCallback = options2;
        options2 = null;
      }
      if (options2 == null)
        options2 = {};
      if (this.ended)
        return;
      this.ended = true;
      this.finalSizeCallback = finalSizeCallback;
      this.forceZip64Eocd = !!options2.forceZip64Format;
      if (options2.comment) {
        if (typeof options2.comment === "string") {
          this.comment = encodeCp437(options2.comment);
        } else {
          this.comment = options2.comment;
        }
        if (this.comment.length > 65535)
          throw new Error("comment is too large");
        if (bufferIncludes(this.comment, eocdrSignatureBuffer))
          throw new Error("comment contains end of central directory record signature");
      } else {
        this.comment = EMPTY_BUFFER;
      }
      pumpEntries(this);
    };
    function writeToOutputStream(self2, buffer) {
      self2.outputStream.write(buffer);
      self2.outputStreamCursor += buffer.length;
    }
    function pumpFileDataReadStream(self2, entry, readStream) {
      var crc32Watcher = new Crc32Watcher();
      var uncompressedSizeCounter = new ByteCounter();
      var compressor = entry.compress ? new zlib2.DeflateRaw() : new PassThrough2();
      var compressedSizeCounter = new ByteCounter();
      readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, {end: false});
      compressedSizeCounter.on("end", function() {
        entry.crc32 = crc32Watcher.crc32;
        if (entry.uncompressedSize == null) {
          entry.uncompressedSize = uncompressedSizeCounter.byteCount;
        } else {
          if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount)
            return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
        }
        entry.compressedSize = compressedSizeCounter.byteCount;
        self2.outputStreamCursor += entry.compressedSize;
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
    }
    function pumpEntries(self2) {
      if (self2.allDone)
        return;
      if (self2.ended && self2.finalSizeCallback != null) {
        var finalSize = calculateFinalSize(self2);
        if (finalSize != null) {
          self2.finalSizeCallback(finalSize);
          self2.finalSizeCallback = null;
        }
      }
      var entry = getFirstNotDoneEntry();
      function getFirstNotDoneEntry() {
        for (var i = 0; i < self2.entries.length; i++) {
          var entry2 = self2.entries[i];
          if (entry2.state < Entry.FILE_DATA_DONE)
            return entry2;
        }
        return null;
      }
      if (entry != null) {
        if (entry.state < Entry.READY_TO_PUMP_FILE_DATA)
          return;
        if (entry.state === Entry.FILE_DATA_IN_PROGRESS)
          return;
        entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
        var localFileHeader = entry.getLocalFileHeader();
        writeToOutputStream(self2, localFileHeader);
        entry.doFileDataPump();
      } else {
        if (self2.ended) {
          self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
          self2.entries.forEach(function(entry2) {
            var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
            writeToOutputStream(self2, centralDirectoryRecord);
          });
          writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
          self2.outputStream.end();
          self2.allDone = true;
        }
      }
    }
    function calculateFinalSize(self2) {
      var pretendOutputCursor = 0;
      var centralDirectorySize = 0;
      for (var i = 0; i < self2.entries.length; i++) {
        var entry = self2.entries[i];
        if (entry.compress)
          return -1;
        if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
          if (entry.uncompressedSize == null)
            return -1;
        } else {
          if (entry.uncompressedSize == null)
            return null;
        }
        entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
        var useZip64Format = entry.useZip64Format();
        pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
        pretendOutputCursor += entry.uncompressedSize;
        if (!entry.crcAndFileSizeKnown) {
          if (useZip64Format) {
            pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
          } else {
            pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
          }
        }
        centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
        if (useZip64Format) {
          centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
        }
      }
      var endOfCentralDirectorySize = 0;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
        endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
      }
      endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
      return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
    }
    var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
    var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
    var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
    function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
      var needZip64Format = false;
      var normalEntriesLength = self2.entries.length;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
        normalEntriesLength = 65535;
        needZip64Format = true;
      }
      var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
      var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
      if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
        normalSizeOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
      if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
        normalOffsetOfStartOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      if (actuallyJustTellMeHowLongItWouldBe) {
        if (needZip64Format) {
          return ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE + END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        } else {
          return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        }
      }
      var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
      eocdrBuffer.writeUInt32LE(101010256, 0);
      eocdrBuffer.writeUInt16LE(0, 4);
      eocdrBuffer.writeUInt16LE(0, 6);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
      eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
      eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
      eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
      self2.comment.copy(eocdrBuffer, 22);
      if (!needZip64Format)
        return eocdrBuffer;
      var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
      zip64EocdrBuffer.writeUInt32LE(101075792, 0);
      writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
      zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
      zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
      zip64EocdrBuffer.writeUInt32LE(0, 16);
      zip64EocdrBuffer.writeUInt32LE(0, 20);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
      writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
      writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
      var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
      zip64EocdlBuffer.writeUInt32LE(117853008, 0);
      zip64EocdlBuffer.writeUInt32LE(0, 4);
      writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
      zip64EocdlBuffer.writeUInt32LE(1, 16);
      return Buffer.concat([
        zip64EocdrBuffer,
        zip64EocdlBuffer,
        eocdrBuffer
      ]);
    }
    function validateMetadataPath(metadataPath, isDirectory) {
      if (metadataPath === "")
        throw new Error("empty metadataPath");
      metadataPath = metadataPath.replace(/\\/g, "/");
      if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath))
        throw new Error("absolute path: " + metadataPath);
      if (metadataPath.split("/").indexOf("..") !== -1)
        throw new Error("invalid relative path: " + metadataPath);
      var looksLikeDirectory = /\/$/.test(metadataPath);
      if (isDirectory) {
        if (!looksLikeDirectory)
          metadataPath += "/";
      } else {
        if (looksLikeDirectory)
          throw new Error("file path cannot end with '/': " + metadataPath);
      }
      return metadataPath;
    }
    var EMPTY_BUFFER = bufferAlloc(0);
    function Entry(metadataPath, isDirectory, options2) {
      this.utf8FileName = bufferFrom(metadataPath);
      if (this.utf8FileName.length > 65535)
        throw new Error("utf8 file name too long. " + utf8FileName.length + " > " + 65535);
      this.isDirectory = isDirectory;
      this.state = Entry.WAITING_FOR_METADATA;
      this.setLastModDate(options2.mtime != null ? options2.mtime : new Date());
      if (options2.mode != null) {
        this.setFileAttributesMode(options2.mode);
      } else {
        this.setFileAttributesMode(isDirectory ? 16893 : 33204);
      }
      if (isDirectory) {
        this.crcAndFileSizeKnown = true;
        this.crc32 = 0;
        this.uncompressedSize = 0;
        this.compressedSize = 0;
      } else {
        this.crcAndFileSizeKnown = false;
        this.crc32 = null;
        this.uncompressedSize = null;
        this.compressedSize = null;
        if (options2.size != null)
          this.uncompressedSize = options2.size;
      }
      if (isDirectory) {
        this.compress = false;
      } else {
        this.compress = true;
        if (options2.compress != null)
          this.compress = !!options2.compress;
      }
      this.forceZip64Format = !!options2.forceZip64Format;
      if (options2.fileComment) {
        if (typeof options2.fileComment === "string") {
          this.fileComment = bufferFrom(options2.fileComment, "utf-8");
        } else {
          this.fileComment = options2.fileComment;
        }
        if (this.fileComment.length > 65535)
          throw new Error("fileComment is too large");
      } else {
        this.fileComment = EMPTY_BUFFER;
      }
    }
    Entry.WAITING_FOR_METADATA = 0;
    Entry.READY_TO_PUMP_FILE_DATA = 1;
    Entry.FILE_DATA_IN_PROGRESS = 2;
    Entry.FILE_DATA_DONE = 3;
    Entry.prototype.setLastModDate = function(date) {
      var dosDateTime = dateToDosDateTime(date);
      this.lastModFileTime = dosDateTime.time;
      this.lastModFileDate = dosDateTime.date;
    };
    Entry.prototype.setFileAttributesMode = function(mode) {
      if ((mode & 65535) !== mode)
        throw new Error("invalid mode. expected: 0 <= " + mode + " <= " + 65535);
      this.externalFileAttributes = mode << 16 >>> 0;
    };
    Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
      this.doFileDataPump = doFileDataPump;
      this.state = Entry.READY_TO_PUMP_FILE_DATA;
    };
    Entry.prototype.useZip64Format = function() {
      return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
    };
    var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
    var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
    var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
    var VERSION_MADE_BY = 3 << 8 | 63;
    var FILE_NAME_IS_UTF8 = 1 << 11;
    var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
    Entry.prototype.getLocalFileHeader = function() {
      var crc322 = 0;
      var compressedSize = 0;
      var uncompressedSize = 0;
      if (this.crcAndFileSizeKnown) {
        crc322 = this.crc32;
        compressedSize = this.compressedSize;
        uncompressedSize = this.uncompressedSize;
      }
      var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      fixedSizeStuff.writeUInt32LE(67324752, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
      fixedSizeStuff.writeUInt32LE(crc322, 14);
      fixedSizeStuff.writeUInt32LE(compressedSize, 18);
      fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
      fixedSizeStuff.writeUInt16LE(0, 28);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName
      ]);
    };
    var DATA_DESCRIPTOR_SIZE = 16;
    var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
    Entry.prototype.getDataDescriptor = function() {
      if (this.crcAndFileSizeKnown) {
        return EMPTY_BUFFER;
      }
      if (!this.useZip64Format()) {
        var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        buffer.writeUInt32LE(this.compressedSize, 8);
        buffer.writeUInt32LE(this.uncompressedSize, 12);
        return buffer;
      } else {
        var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        writeUInt64LE(buffer, this.compressedSize, 8);
        writeUInt64LE(buffer, this.uncompressedSize, 16);
        return buffer;
      }
    };
    var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
    var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
    Entry.prototype.getCentralDirectoryRecord = function() {
      var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      var normalCompressedSize = this.compressedSize;
      var normalUncompressedSize = this.uncompressedSize;
      var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
      var versionNeededToExtract;
      var zeiefBuffer;
      if (this.useZip64Format()) {
        normalCompressedSize = 4294967295;
        normalUncompressedSize = 4294967295;
        normalRelativeOffsetOfLocalHeader = 4294967295;
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
        zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
        zeiefBuffer.writeUInt16LE(1, 0);
        zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
        writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
        writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
        writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
      } else {
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
        zeiefBuffer = EMPTY_BUFFER;
      }
      fixedSizeStuff.writeUInt32LE(33639248, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
      fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
      fixedSizeStuff.writeUInt32LE(this.crc32, 16);
      fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
      fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
      fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
      fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
      fixedSizeStuff.writeUInt16LE(0, 34);
      fixedSizeStuff.writeUInt16LE(0, 36);
      fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
      fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName,
        zeiefBuffer,
        this.fileComment
      ]);
    };
    Entry.prototype.getCompressionMethod = function() {
      var NO_COMPRESSION = 0;
      var DEFLATE_COMPRESSION = 8;
      return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
    };
    function dateToDosDateTime(jsDate) {
      var date = 0;
      date |= jsDate.getDate() & 31;
      date |= (jsDate.getMonth() + 1 & 15) << 5;
      date |= (jsDate.getFullYear() - 1980 & 127) << 9;
      var time = 0;
      time |= Math.floor(jsDate.getSeconds() / 2);
      time |= (jsDate.getMinutes() & 63) << 5;
      time |= (jsDate.getHours() & 31) << 11;
      return {date, time};
    }
    function writeUInt64LE(buffer, n, offset) {
      var high = Math.floor(n / 4294967296);
      var low = n % 4294967296;
      buffer.writeUInt32LE(low, offset);
      buffer.writeUInt32LE(high, offset + 4);
    }
    util.inherits(ByteCounter, Transform);
    function ByteCounter(options2) {
      Transform.call(this, options2);
      this.byteCount = 0;
    }
    ByteCounter.prototype._transform = function(chunk, encoding, cb) {
      this.byteCount += chunk.length;
      cb(null, chunk);
    };
    util.inherits(Crc32Watcher, Transform);
    function Crc32Watcher(options2) {
      Transform.call(this, options2);
      this.crc32 = 0;
    }
    Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
      this.crc32 = crc32.unsigned(chunk, this.crc32);
      cb(null, chunk);
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    if (cp437.length !== 256)
      throw new Error("assertion failure");
    var reverseCp437 = null;
    function encodeCp437(string) {
      if (/^[\x20-\x7e]*$/.test(string)) {
        return bufferFrom(string, "utf-8");
      }
      if (reverseCp437 == null) {
        reverseCp437 = {};
        for (var i = 0; i < cp437.length; i++) {
          reverseCp437[cp437[i]] = i;
        }
      }
      var result = bufferAlloc(string.length);
      for (var i = 0; i < string.length; i++) {
        var b = reverseCp437[string[i]];
        if (b == null)
          throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
        result[i] = b;
      }
      return result;
    }
    function bufferAlloc(size) {
      bufferAlloc = modern;
      try {
        return bufferAlloc(size);
      } catch (e) {
        bufferAlloc = legacy;
        return bufferAlloc(size);
      }
      function modern(size2) {
        return Buffer.allocUnsafe(size2);
      }
      function legacy(size2) {
        return new Buffer(size2);
      }
    }
    function bufferFrom(something, encoding) {
      bufferFrom = modern;
      try {
        return bufferFrom(something, encoding);
      } catch (e) {
        bufferFrom = legacy;
        return bufferFrom(something, encoding);
      }
      function modern(something2, encoding2) {
        return Buffer.from(something2, encoding2);
      }
      function legacy(something2, encoding2) {
        return new Buffer(something2, encoding2);
      }
    }
    function bufferIncludes(buffer, content) {
      bufferIncludes = modern;
      try {
        return bufferIncludes(buffer, content);
      } catch (e) {
        bufferIncludes = legacy;
        return bufferIncludes(buffer, content);
      }
      function modern(buffer2, content2) {
        return buffer2.includes(content2);
      }
      function legacy(buffer2, content2) {
        for (var i = 0; i <= buffer2.length - content2.length; i++) {
          for (var j = 0; ; j++) {
            if (j === content2.length)
              return true;
            if (buffer2[i + j] !== content2[j])
              break;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/playwright/lib/server/artifact.js
var require_artifact = __commonJS({
  "node_modules/playwright/lib/server/artifact.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Artifact = void 0;
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var instrumentation_1 = require_instrumentation();
    var Artifact = class extends instrumentation_1.SdkObject {
      constructor(parent, localPath, unaccessibleErrorMessage) {
        super(parent, "artifact");
        this._saveCallbacks = [];
        this._finished = false;
        this._deleted = false;
        this._failureError = null;
        this._localPath = localPath;
        this._unaccessibleErrorMessage = unaccessibleErrorMessage;
        this._finishedCallback = () => {
        };
        this._finishedPromise = new Promise((f) => this._finishedCallback = f);
      }
      finishedPromise() {
        return this._finishedPromise;
      }
      localPath() {
        return this._localPath;
      }
      async localPathAfterFinished() {
        if (this._unaccessibleErrorMessage)
          throw new Error(this._unaccessibleErrorMessage);
        await this._finishedPromise;
        if (this._failureError)
          return null;
        return this._localPath;
      }
      saveAs(saveCallback) {
        if (this._unaccessibleErrorMessage)
          throw new Error(this._unaccessibleErrorMessage);
        if (this._deleted)
          throw new Error(`File already deleted. Save before deleting.`);
        if (this._failureError)
          throw new Error(`File not found on disk. Check download.failure() for details.`);
        if (this._finished) {
          saveCallback(this._localPath).catch((e) => {
          });
          return;
        }
        this._saveCallbacks.push(saveCallback);
      }
      async failureError() {
        if (this._unaccessibleErrorMessage)
          return this._unaccessibleErrorMessage;
        await this._finishedPromise;
        return this._failureError;
      }
      async delete() {
        if (this._unaccessibleErrorMessage)
          return;
        const fileName = await this.localPathAfterFinished();
        if (this._deleted)
          return;
        this._deleted = true;
        if (fileName)
          await util.promisify(fs_1.default.unlink)(fileName).catch((e) => {
          });
      }
      async deleteOnContextClose() {
        if (this._deleted)
          return;
        this._deleted = true;
        if (!this._unaccessibleErrorMessage)
          await util.promisify(fs_1.default.unlink)(this._localPath).catch((e) => {
          });
        await this.reportFinished("File deleted upon browser context closure.");
      }
      async reportFinished(error3) {
        if (this._finished)
          return;
        this._finished = true;
        this._failureError = error3 || null;
        if (error3) {
          for (const callback of this._saveCallbacks)
            await callback("", error3);
        } else {
          for (const callback of this._saveCallbacks)
            await callback(this._localPath);
        }
        this._saveCallbacks = [];
        this._finishedCallback();
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright/lib/server/snapshot/snapshotterInjected.js
var require_snapshotterInjected = __commonJS({
  "node_modules/playwright/lib/server/snapshot/snapshotterInjected.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.frameSnapshotStreamer = void 0;
    function frameSnapshotStreamer(snapshotStreamer) {
      if (window[snapshotStreamer])
        return;
      const kShadowAttribute = "__playwright_shadow_root_";
      const kScrollTopAttribute = "__playwright_scroll_top_";
      const kScrollLeftAttribute = "__playwright_scroll_left_";
      const kSnapshotFrameId = Symbol("__playwright_snapshot_frameid_");
      const kCachedData = Symbol("__playwright_snapshot_cache_");
      function resetCachedData(obj) {
        delete obj[kCachedData];
      }
      function ensureCachedData(obj) {
        if (!obj[kCachedData])
          obj[kCachedData] = {};
        return obj[kCachedData];
      }
      function removeHash(url) {
        try {
          const u = new URL(url);
          u.hash = "";
          return u.toString();
        } catch (e) {
          return url;
        }
      }
      class Streamer {
        constructor() {
          this._removeNoScript = true;
          this._lastSnapshotNumber = 0;
          this._staleStyleSheets = new Set();
          this._readingStyleSheet = false;
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "insertRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "deleteRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "addRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "removeRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "rules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "cssRules", (sheet) => this._invalidateStyleSheet(sheet));
          this._fakeBase = document.createElement("base");
          this._observer = new MutationObserver((list) => this._handleMutations(list));
          const observerConfig = {attributes: true, subtree: true};
          this._observer.observe(document, observerConfig);
        }
        _interceptNativeMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            const result = native.call(this, ...args);
            cb(this, result);
            return result;
          };
        }
        _interceptNativeGetter(obj, prop, cb) {
          const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          Object.defineProperty(obj, prop, {
            ...descriptor,
            get: function() {
              const result = descriptor.get.call(this);
              cb(this, result);
              return result;
            }
          });
        }
        _handleMutations(list) {
          for (const mutation of list)
            ensureCachedData(mutation.target).attributesCached = void 0;
        }
        _invalidateStyleSheet(sheet) {
          if (this._readingStyleSheet)
            return;
          this._staleStyleSheets.add(sheet);
        }
        _updateStyleElementStyleSheetTextIfNeeded(sheet) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet)) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
            } catch (e) {
            }
          }
          return data.cssText;
        }
        _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet)) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
              data.cssRef = snapshotNumber;
              return data.cssText;
            } catch (e) {
            }
          }
          return data.cssRef === void 0 ? void 0 : snapshotNumber - data.cssRef;
        }
        markIframe(iframeElement, frameId) {
          iframeElement[kSnapshotFrameId] = frameId;
        }
        reset() {
          this._staleStyleSheets.clear();
          const visitNode = (node) => {
            resetCachedData(node);
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (element.shadowRoot)
                visitNode(element.shadowRoot);
            }
            for (let child = node.firstChild; child; child = child.nextSibling)
              visitNode(child);
          };
          visitNode(document.documentElement);
        }
        _sanitizeUrl(url) {
          if (url.startsWith("javascript:"))
            return "";
          return url;
        }
        _sanitizeSrcSet(srcset) {
          return srcset.split(",").map((src2) => {
            src2 = src2.trim();
            const spaceIndex = src2.lastIndexOf(" ");
            if (spaceIndex === -1)
              return this._sanitizeUrl(src2);
            return this._sanitizeUrl(src2.substring(0, spaceIndex).trim()) + src2.substring(spaceIndex);
          }).join(",");
        }
        _resolveUrl(base, url) {
          if (url === "")
            return "";
          try {
            return new URL(url, base).href;
          } catch (e) {
            return url;
          }
        }
        _getSheetBase(sheet) {
          let rootSheet = sheet;
          while (rootSheet.parentStyleSheet)
            rootSheet = rootSheet.parentStyleSheet;
          if (rootSheet.ownerNode)
            return rootSheet.ownerNode.baseURI;
          return document.baseURI;
        }
        _getSheetText(sheet) {
          this._readingStyleSheet = true;
          try {
            const rules = [];
            for (const rule of sheet.cssRules)
              rules.push(rule.cssText);
            return rules.join("\n");
          } finally {
            this._readingStyleSheet = false;
          }
        }
        captureSnapshot() {
          const timestamp = performance.now();
          const snapshotNumber = ++this._lastSnapshotNumber;
          let nodeCounter = 0;
          let shadowDomNesting = 0;
          this._handleMutations(this._observer.takeRecords());
          const visitNode = (node) => {
            const nodeType = node.nodeType;
            const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? "template" : node.nodeName;
            if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE)
              return;
            if (nodeName === "SCRIPT")
              return;
            if (this._removeNoScript && nodeName === "NOSCRIPT")
              return;
            const data = ensureCachedData(node);
            const values = [];
            let equals = !!data.cached;
            let extraNodes = 0;
            const expectValue = (value) => {
              equals = equals && data.cached[values.length] === value;
              values.push(value);
            };
            const checkAndReturn = (n) => {
              data.attributesCached = true;
              if (equals)
                return {equals: true, n: [[snapshotNumber - data.ref[0], data.ref[1]]]};
              nodeCounter += extraNodes;
              data.ref = [snapshotNumber, nodeCounter++];
              data.cached = values;
              return {equals: false, n};
            };
            if (nodeType === Node.TEXT_NODE) {
              const value = node.nodeValue || "";
              expectValue(value);
              return checkAndReturn(value);
            }
            if (nodeName === "STYLE") {
              const sheet = node.sheet;
              let cssText;
              if (sheet)
                cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
              cssText = cssText || node.textContent || "";
              expectValue(cssText);
              extraNodes++;
              return checkAndReturn(["style", {}, cssText]);
            }
            const attrs = {};
            const result2 = [nodeName, attrs];
            const visitChild = (child) => {
              const snapshot = visitNode(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
              attrs[kShadowAttribute] = "open";
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (nodeName === "INPUT") {
                const value = element.value;
                expectValue("value");
                expectValue(value);
                attrs["value"] = value;
                if (element.checked) {
                  expectValue("checked");
                  attrs["checked"] = "";
                }
              }
              if (element === document.scrollingElement) {
                if (element.scrollTop) {
                  expectValue(kScrollTopAttribute);
                  expectValue(element.scrollTop);
                  attrs[kScrollTopAttribute] = "" + element.scrollTop;
                }
                if (element.scrollLeft) {
                  expectValue(kScrollLeftAttribute);
                  expectValue(element.scrollLeft);
                  attrs[kScrollLeftAttribute] = "" + element.scrollLeft;
                }
              }
              if (element.shadowRoot) {
                ++shadowDomNesting;
                visitChild(element.shadowRoot);
                --shadowDomNesting;
              }
            }
            if (nodeName === "TEXTAREA") {
              const value = node.value;
              expectValue(value);
              extraNodes++;
              result2.push(value);
            } else {
              if (nodeName === "HEAD") {
                this._fakeBase.setAttribute("href", document.baseURI);
                visitChild(this._fakeBase);
              }
              for (let child = node.firstChild; child; child = child.nextSibling)
                visitChild(child);
            }
            if (nodeName === "IFRAME" || nodeName === "FRAME") {
              const element = node;
              for (let i = 0; i < element.attributes.length; i++) {
                const frameId = element[kSnapshotFrameId];
                const name = "src";
                const value = frameId ? `/snapshot/${frameId}` : "";
                expectValue(name);
                expectValue(value);
                attrs[name] = value;
              }
            }
            if (equals && data.attributesCached && !shadowDomNesting)
              return checkAndReturn(result2);
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              for (let i = 0; i < element.attributes.length; i++) {
                const name = element.attributes[i].name;
                if (name === "value" && (nodeName === "INPUT" || nodeName === "TEXTAREA"))
                  continue;
                if (nodeName === "LINK" && name === "integrity")
                  continue;
                if (nodeName === "IFRAME" && name === "src")
                  continue;
                let value = element.attributes[i].value;
                if (name === "src" && nodeName === "IMG")
                  value = this._sanitizeUrl(value);
                else if (name === "srcset" && nodeName === "IMG")
                  value = this._sanitizeSrcSet(value);
                else if (name === "srcset" && nodeName === "SOURCE")
                  value = this._sanitizeSrcSet(value);
                else if (name === "href" && nodeName === "LINK")
                  value = this._sanitizeUrl(value);
                else if (name.startsWith("on"))
                  value = "";
                expectValue(name);
                expectValue(value);
                attrs[name] = value;
              }
            }
            if (result2.length === 2 && !Object.keys(attrs).length)
              result2.pop();
            return checkAndReturn(result2);
          };
          let html;
          if (document.documentElement) {
            const {n} = visitNode(document.documentElement);
            html = n;
          } else {
            html = ["html"];
          }
          const result = {
            html,
            doctype: document.doctype ? document.doctype.name : void 0,
            resourceOverrides: [],
            viewport: {
              width: Math.max(document.body ? document.body.offsetWidth : 0, document.documentElement ? document.documentElement.offsetWidth : 0),
              height: Math.max(document.body ? document.body.offsetHeight : 0, document.documentElement ? document.documentElement.offsetHeight : 0)
            },
            url: location.href,
            timestamp,
            collectionTime: 0
          };
          for (const sheet of this._staleStyleSheets) {
            if (sheet.href === null)
              continue;
            const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
            if (content === void 0) {
              continue;
            }
            const base = this._getSheetBase(sheet);
            const url = removeHash(this._resolveUrl(base, sheet.href));
            result.resourceOverrides.push({url, content});
          }
          result.collectionTime = performance.now() - result.timestamp;
          return result;
        }
      }
      window[snapshotStreamer] = new Streamer();
    }
    exports2.frameSnapshotStreamer = frameSnapshotStreamer;
  }
});

// node_modules/playwright/lib/server/snapshot/snapshotter.js
var require_snapshotter = __commonJS({
  "node_modules/playwright/lib/server/snapshot/snapshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Snapshotter = void 0;
    var browserContext_1 = require_browserContext();
    var page_1 = require_page();
    var helper_1 = require_helper();
    var debugLogger_1 = require_debugLogger();
    var snapshotterInjected_1 = require_snapshotterInjected();
    var utils_1 = require_utils();
    var Snapshotter = class {
      constructor(context, delegate) {
        this._eventListeners = [];
        this._initialized = false;
        this._started = false;
        this._fetchedResponses = new Map();
        this._context = context;
        this._delegate = delegate;
        const guid = utils_1.createGuid();
        this._snapshotStreamer = "__playwright_snapshot_streamer_" + guid;
      }
      started() {
        return this._started;
      }
      async start() {
        this._started = true;
        if (!this._initialized) {
          this._initialized = true;
          await this._initialize();
        }
        await this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
        for (const page of this._context.pages()) {
          for (const response of page._frameManager._responses)
            this._saveResource(page, response).catch((e) => debugLogger_1.debugLogger.log("error", e));
        }
      }
      async stop() {
        this._started = false;
      }
      async _initialize() {
        for (const page of this._context.pages())
          this._onPage(page);
        this._eventListeners = [
          helper_1.helper.addEventListener(this._context, browserContext_1.BrowserContext.Events.Page, this._onPage.bind(this))
        ];
        const initScript = `(${snapshotterInjected_1.frameSnapshotStreamer})("${this._snapshotStreamer}")`;
        await this._context._doAddInitScript(initScript);
        await this._runInAllFrames(initScript);
      }
      async _runInAllFrames(expression) {
        const frames = [];
        for (const page of this._context.pages())
          frames.push(...page.frames());
        await Promise.all(frames.map((frame) => {
          return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(debugExceptionHandler);
        }));
      }
      dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
      }
      async captureSnapshot(page, snapshotName, element) {
        const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
        element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element2, snapshotName2) => {
          element2.setAttribute("__playwright_target__", snapshotName2);
        }, snapshotName);
        const snapshots = page.frames().map(async (frame) => {
          const data = await frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(debugExceptionHandler);
          if (!data)
            return;
          const snapshot = {
            snapshotName,
            pageId: page.guid,
            frameId: frame.guid,
            frameUrl: data.url,
            doctype: data.doctype,
            html: data.html,
            viewport: data.viewport,
            timestamp: utils_1.monotonicTime(),
            pageTimestamp: data.timestamp,
            collectionTime: data.collectionTime,
            resourceOverrides: [],
            isMainFrame: page.mainFrame() === frame
          };
          for (const {url, content} of data.resourceOverrides) {
            if (typeof content === "string") {
              const buffer = Buffer.from(content);
              const sha1 = utils_1.calculateSha1(buffer);
              this._delegate.onBlob({sha1, buffer});
              snapshot.resourceOverrides.push({url, sha1});
            } else {
              snapshot.resourceOverrides.push({url, ref: content});
            }
          }
          this._delegate.onFrameSnapshot(snapshot);
        });
        await Promise.all(snapshots);
      }
      _onPage(page) {
        for (const frame of page.frames())
          this._annotateFrameHierarchy(frame);
        this._eventListeners.push(helper_1.helper.addEventListener(page, page_1.Page.Events.FrameAttached, (frame) => this._annotateFrameHierarchy(frame)));
        this._eventListeners.push(helper_1.helper.addEventListener(page, page_1.Page.Events.Response, (response) => {
          this._saveResource(page, response).catch((e) => debugLogger_1.debugLogger.log("error", e));
        }));
      }
      async _saveResource(page, response) {
        if (!this._started)
          return;
        const isRedirect2 = response.status() >= 300 && response.status() <= 399;
        if (isRedirect2)
          return;
        let original = response.request();
        while (original.redirectedFrom())
          original = original.redirectedFrom();
        const url = original.url();
        let contentType = "";
        for (const {name, value} of response.headers()) {
          if (name.toLowerCase() === "content-type")
            contentType = value;
        }
        const method = original.method();
        const status = response.status();
        const requestBody = original.postDataBuffer();
        const requestSha1 = requestBody ? utils_1.calculateSha1(requestBody) : "";
        if (requestBody)
          this._delegate.onBlob({sha1: requestSha1, buffer: requestBody});
        const requestHeaders = original.headers();
        let responseSha1 = this._fetchedResponses.get(response);
        {
          if (responseSha1 === void 0) {
            const body = await response.body().catch((e) => debugLogger_1.debugLogger.log("error", e));
            if (!this._started)
              return;
            responseSha1 = body ? utils_1.calculateSha1(body) : "";
            if (body)
              this._delegate.onBlob({sha1: responseSha1, buffer: body});
            this._fetchedResponses.set(response, responseSha1);
          }
        }
        const resource = {
          pageId: page.guid,
          frameId: response.frame().guid,
          resourceId: "resource@" + utils_1.createGuid(),
          url,
          contentType,
          responseHeaders: response.headers(),
          requestHeaders,
          method,
          status,
          requestSha1,
          responseSha1,
          timestamp: utils_1.monotonicTime()
        };
        this._delegate.onResourceSnapshot(resource);
      }
      async _annotateFrameHierarchy(frame) {
        try {
          const frameElement = await frame.frameElement();
          const parent = frame.parentFrame();
          if (!parent)
            return;
          const context = await parent._mainContext();
          await (context === null || context === void 0 ? void 0 : context.evaluate(({snapshotStreamer, frameElement: frameElement2, frameId}) => {
            window[snapshotStreamer].markIframe(frameElement2, frameId);
          }, {snapshotStreamer: this._snapshotStreamer, frameElement, frameId: frame.guid}));
          frameElement.dispose();
        } catch (e) {
        }
      }
    };
    exports2.Snapshotter = Snapshotter;
    function debugExceptionHandler(e) {
    }
  }
});

// node_modules/playwright/lib/server/trace/recorder/traceSnapshotter.js
var require_traceSnapshotter = __commonJS({
  "node_modules/playwright/lib/server/trace/recorder/traceSnapshotter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.TraceSnapshotter = void 0;
    var events_1 = require("events");
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var util_1 = __importDefault(require("util"));
    var snapshotter_1 = require_snapshotter();
    var utils_1 = require_utils();
    var fsWriteFileAsync = util_1.default.promisify(fs_1.default.writeFile.bind(fs_1.default));
    var TraceSnapshotter = class extends events_1.EventEmitter {
      constructor(context, resourcesDir, appendTraceEvent) {
        super();
        this._writeArtifactChain = Promise.resolve();
        this._resourcesDir = resourcesDir;
        this._snapshotter = new snapshotter_1.Snapshotter(context, this);
        this._appendTraceEvent = appendTraceEvent;
        this._writeArtifactChain = Promise.resolve();
      }
      started() {
        return this._snapshotter.started();
      }
      async start() {
        await this._snapshotter.start();
      }
      async dispose() {
        this._snapshotter.dispose();
        await this._writeArtifactChain;
      }
      async captureSnapshot(page, snapshotName, element) {
        await this._snapshotter.captureSnapshot(page, snapshotName, element).catch(() => {
        });
      }
      onBlob(blob) {
        this._writeArtifactChain = this._writeArtifactChain.then(async () => {
          await fsWriteFileAsync(path_1.default.join(this._resourcesDir, blob.sha1), blob.buffer).catch(() => {
          });
        });
      }
      onResourceSnapshot(snapshot) {
        this._appendTraceEvent({
          timestamp: utils_1.monotonicTime(),
          type: "resource-snapshot",
          snapshot
        });
      }
      onFrameSnapshot(snapshot) {
        this._appendTraceEvent({
          timestamp: utils_1.monotonicTime(),
          type: "frame-snapshot",
          snapshot
        });
      }
    };
    exports2.TraceSnapshotter = TraceSnapshotter;
  }
});

// node_modules/playwright/lib/server/trace/recorder/tracing.js
var require_tracing = __commonJS({
  "node_modules/playwright/lib/server/trace/recorder/tracing.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Tracing = void 0;
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var util_1 = __importDefault(require("util"));
    var yazl_1 = __importDefault(require_yazl());
    var utils_1 = require_utils();
    var artifact_1 = require_artifact();
    var browserContext_1 = require_browserContext();
    var frames_1 = require_frames();
    var helper_1 = require_helper();
    var page_1 = require_page();
    var traceSnapshotter_1 = require_traceSnapshotter();
    var fsAppendFileAsync = util_1.default.promisify(fs_1.default.appendFile.bind(fs_1.default));
    var fsWriteFileAsync = util_1.default.promisify(fs_1.default.writeFile.bind(fs_1.default));
    var fsMkdirAsync = util_1.default.promisify(fs_1.default.mkdir.bind(fs_1.default));
    var Tracing = class {
      constructor(context) {
        this._appendEventChain = Promise.resolve();
        this._eventListeners = [];
        this._pendingCalls = new Map();
        this._sha1s = [];
        this._started = false;
        this._context = context;
        this._traceDir = context._browser.options.traceDir;
        this._resourcesDir = path_1.default.join(this._traceDir || "", "resources");
        this._snapshotter = new traceSnapshotter_1.TraceSnapshotter(this._context, this._resourcesDir, (traceEvent) => this._appendTraceEvent(traceEvent));
      }
      async start(options2) {
        if (!this._traceDir)
          throw new Error("Tracing directory is not specified when launching the browser");
        if (this._started)
          throw new Error("Tracing has already been started");
        this._started = true;
        this._traceFile = path_1.default.join(this._traceDir, (options2.name || utils_1.createGuid()) + ".trace");
        this._appendEventChain = utils_1.mkdirIfNeeded(this._traceFile);
        const event = {
          timestamp: utils_1.monotonicTime(),
          type: "context-metadata",
          browserName: this._context._browser.options.name,
          isMobile: !!this._context._options.isMobile,
          deviceScaleFactor: this._context._options.deviceScaleFactor || 1,
          viewportSize: this._context._options.viewport || void 0,
          debugName: this._context._options._debugName
        };
        this._appendTraceEvent(event);
        for (const page of this._context.pages())
          this._onPage(options2.screenshots, page);
        this._eventListeners.push(helper_1.helper.addEventListener(this._context, browserContext_1.BrowserContext.Events.Page, this._onPage.bind(this, options2.screenshots)));
        await fsMkdirAsync(this._resourcesDir, {recursive: true});
        this._context.instrumentation.addListener(this);
        if (options2.snapshots)
          await this._snapshotter.start();
      }
      async stop() {
        if (!this._started)
          return;
        this._started = false;
        this._context.instrumentation.removeListener(this);
        helper_1.helper.removeEventListeners(this._eventListeners);
        for (const {sdkObject, metadata} of this._pendingCalls.values())
          await this.onAfterCall(sdkObject, metadata);
        for (const page of this._context.pages())
          page.setScreencastEnabled(false);
        await this._appendEventChain;
      }
      async dispose() {
        await this._snapshotter.dispose();
      }
      async export() {
        if (!this._traceFile)
          throw new Error("Tracing directory is not specified when launching the browser");
        const zipFile = new yazl_1.default.ZipFile();
        zipFile.addFile(this._traceFile, "trace.trace");
        const zipFileName = this._traceFile + ".zip";
        this._traceFile = void 0;
        for (const sha1 of this._sha1s)
          zipFile.addFile(path_1.default.join(this._resourcesDir, sha1), path_1.default.join("resources", sha1));
        zipFile.end();
        await new Promise((f) => {
          zipFile.outputStream.pipe(fs_1.default.createWriteStream(zipFileName)).on("close", f);
        });
        const artifact = new artifact_1.Artifact(this._context, zipFileName);
        artifact.reportFinished();
        return artifact;
      }
      async _captureSnapshot(name, sdkObject, metadata, element) {
        if (!sdkObject.attribution.page)
          return;
        if (!this._snapshotter.started())
          return;
        const snapshotName = `${name}@${metadata.id}`;
        metadata.snapshots.push({title: name, snapshotName});
        await this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element);
      }
      async onBeforeCall(sdkObject, metadata) {
        await this._captureSnapshot("before", sdkObject, metadata);
        this._pendingCalls.set(metadata.id, {sdkObject, metadata});
      }
      async onBeforeInputAction(sdkObject, metadata, element) {
        await this._captureSnapshot("action", sdkObject, metadata, element);
      }
      async onAfterCall(sdkObject, metadata) {
        if (!this._pendingCalls.has(metadata.id))
          return;
        this._pendingCalls.delete(metadata.id);
        if (!sdkObject.attribution.page)
          return;
        await this._captureSnapshot("after", sdkObject, metadata);
        const event = {
          timestamp: metadata.startTime,
          type: "action",
          metadata
        };
        this._appendTraceEvent(event);
      }
      onEvent(sdkObject, metadata) {
        if (!sdkObject.attribution.page)
          return;
        const event = {
          timestamp: metadata.startTime,
          type: "event",
          metadata
        };
        this._appendTraceEvent(event);
      }
      _onPage(screenshots, page) {
        const pageId = page.guid;
        const event = {
          timestamp: utils_1.monotonicTime(),
          type: "page-created",
          pageId
        };
        this._appendTraceEvent(event);
        if (screenshots)
          page.setScreencastEnabled(true);
        this._eventListeners.push(helper_1.helper.addEventListener(page, page_1.Page.Events.Dialog, (dialog) => {
          const event2 = {
            timestamp: utils_1.monotonicTime(),
            type: "dialog-opened",
            pageId,
            dialogType: dialog.type(),
            message: dialog.message()
          };
          this._appendTraceEvent(event2);
        }), helper_1.helper.addEventListener(page, page_1.Page.Events.InternalDialogClosed, (dialog) => {
          const event2 = {
            timestamp: utils_1.monotonicTime(),
            type: "dialog-closed",
            pageId,
            dialogType: dialog.type()
          };
          this._appendTraceEvent(event2);
        }), helper_1.helper.addEventListener(page.mainFrame(), frames_1.Frame.Events.Navigation, (navigationEvent) => {
          if (page.mainFrame().url() === "about:blank")
            return;
          const event2 = {
            timestamp: utils_1.monotonicTime(),
            type: "navigation",
            pageId,
            url: navigationEvent.url,
            sameDocument: !navigationEvent.newDocument
          };
          this._appendTraceEvent(event2);
        }), helper_1.helper.addEventListener(page, page_1.Page.Events.Load, () => {
          if (page.mainFrame().url() === "about:blank")
            return;
          const event2 = {
            timestamp: utils_1.monotonicTime(),
            type: "load",
            pageId
          };
          this._appendTraceEvent(event2);
        }), helper_1.helper.addEventListener(page, page_1.Page.Events.ScreencastFrame, (params) => {
          const sha1 = utils_1.calculateSha1(utils_1.createGuid());
          const event2 = {
            type: "screencast-frame",
            pageId: page.guid,
            sha1,
            pageTimestamp: params.timestamp,
            width: params.width,
            height: params.height,
            timestamp: utils_1.monotonicTime()
          };
          this._appendTraceEvent(event2);
          this._appendEventChain = this._appendEventChain.then(async () => {
            await fsWriteFileAsync(path_1.default.join(this._resourcesDir, sha1), params.buffer).catch(() => {
            });
          });
        }), helper_1.helper.addEventListener(page, page_1.Page.Events.Close, () => {
          const event2 = {
            timestamp: utils_1.monotonicTime(),
            type: "page-destroyed",
            pageId
          };
          this._appendTraceEvent(event2);
        }));
      }
      _appendTraceEvent(event) {
        const visit = (object) => {
          if (Array.isArray(object)) {
            object.forEach(visit);
            return;
          }
          if (typeof object === "object") {
            for (const key in object) {
              if (key === "sha1" || key.endsWith("Sha1")) {
                const sha1 = object[key];
                if (sha1)
                  this._sha1s.push(sha1);
              }
              visit(object[key]);
            }
            return;
          }
        };
        visit(event);
        this._appendEventChain = this._appendEventChain.then(async () => {
          await fsAppendFileAsync(this._traceFile, JSON.stringify(event) + "\n");
        });
      }
    };
    exports2.Tracing = Tracing;
  }
});

// node_modules/playwright/package.json
var require_package = __commonJS({
  "node_modules/playwright/package.json"(exports2, module2) {
    module2.exports = {
      _from: "playwright",
      _id: "playwright@1.11.1",
      _inBundle: false,
      _integrity: "sha512-UuMrYuvzttbJXUD7sTVcQBsGRojelGepvuQPD+QtVm/n5zyKvkiUErU/DGRXfX8VDZRdQ5D6qVqZndrydC2b4w==",
      _location: "/playwright",
      _phantomChildren: {},
      _requested: {
        type: "tag",
        registry: true,
        raw: "playwright",
        name: "playwright",
        escapedName: "playwright",
        rawSpec: "",
        saveSpec: null,
        fetchSpec: "latest"
      },
      _requiredBy: [
        "#USER",
        "/"
      ],
      _resolved: "https://registry.npmjs.org/playwright/-/playwright-1.11.1.tgz",
      _shasum: "c5f2946db5195bd099a57ce4e188c01057876cff",
      _spec: "playwright",
      _where: "/home/thomas/projects/perso/ritournelle-dico",
      author: {
        name: "Microsoft Corporation"
      },
      bin: {
        playwright: "lib/cli/cli.js"
      },
      bugs: {
        url: "https://github.com/Microsoft/playwright/issues"
      },
      bundleDependencies: false,
      dependencies: {
        commander: "^6.1.0",
        debug: "^4.1.1",
        "extract-zip": "^2.0.1",
        "https-proxy-agent": "^5.0.0",
        "jpeg-js": "^0.4.2",
        mime: "^2.4.6",
        pngjs: "^5.0.0",
        progress: "^2.0.3",
        "proper-lockfile": "^4.1.1",
        "proxy-from-env": "^1.1.0",
        rimraf: "^3.0.2",
        "stack-utils": "^2.0.3",
        ws: "^7.3.1",
        yazl: "^2.5.1"
      },
      deprecated: false,
      description: "A high-level API to automate web browsers",
      engines: {
        node: ">=12"
      },
      exports: {
        ".": {
          import: "./index.mjs",
          require: "./index.js"
        },
        "./": "./"
      },
      homepage: "https://playwright.dev",
      license: "Apache-2.0",
      main: "index.js",
      name: "playwright",
      repository: {
        type: "git",
        url: "git+https://github.com/Microsoft/playwright.git"
      },
      scripts: {
        install: "node install.js"
      },
      version: "1.11.1"
    };
  }
});

// node_modules/playwright/lib/server/supplements/har/harTracer.js
var require_harTracer = __commonJS({
  "node_modules/playwright/lib/server/supplements/har/harTracer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.HarTracer = void 0;
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var browserContext_1 = require_browserContext();
    var helper_1 = require_helper();
    var network = __importStar(require_network());
    var page_1 = require_page();
    var fsWriteFileAsync = util.promisify(fs_1.default.writeFile.bind(fs_1.default));
    var HarTracer = class {
      constructor(context, options2) {
        this._pageEntries = new Map();
        this._entries = new Map();
        this._lastPage = 0;
        this._barrierPromises = new Set();
        this._options = options2;
        this._log = {
          version: "1.2",
          creator: {
            name: "Playwright",
            version: require_package()["version"]
          },
          browser: {
            name: context._browser.options.name,
            version: context._browser.version()
          },
          pages: [],
          entries: []
        };
        context.on(browserContext_1.BrowserContext.Events.Page, (page) => this._onPage(page));
      }
      _onPage(page) {
        const pageEntry = {
          startedDateTime: new Date(),
          id: `page_${this._lastPage++}`,
          title: "",
          pageTimings: {
            onContentLoad: -1,
            onLoad: -1
          }
        };
        this._pageEntries.set(page, pageEntry);
        this._log.pages.push(pageEntry);
        page.on(page_1.Page.Events.Request, (request) => this._onRequest(page, request));
        page.on(page_1.Page.Events.Response, (response) => this._onResponse(page, response));
        page.on(page_1.Page.Events.DOMContentLoaded, () => {
          const promise = page.mainFrame().evaluateExpression(String(() => {
            return {
              title: document.title,
              domContentLoaded: performance.timing.domContentLoadedEventStart
            };
          }), true, void 0, "utility").then((result) => {
            pageEntry.title = result.title;
            pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
          }).catch(() => {
          });
          this._addBarrier(page, promise);
        });
        page.on(page_1.Page.Events.Load, () => {
          const promise = page.mainFrame().evaluateExpression(String(() => {
            return {
              title: document.title,
              loaded: performance.timing.loadEventStart
            };
          }), true, void 0, "utility").then((result) => {
            pageEntry.title = result.title;
            pageEntry.pageTimings.onLoad = result.loaded;
          }).catch(() => {
          });
          this._addBarrier(page, promise);
        });
      }
      _addBarrier(page, promise) {
        const race = Promise.race([
          new Promise((f) => page.on("close", () => {
            this._barrierPromises.delete(race);
            f();
          })),
          promise
        ]);
        this._barrierPromises.add(race);
      }
      _onRequest(page, request) {
        const pageEntry = this._pageEntries.get(page);
        const url = network.parsedURL(request.url());
        if (!url)
          return;
        const harEntry = {
          pageref: pageEntry.id,
          startedDateTime: new Date(),
          time: -1,
          request: {
            method: request.method(),
            url: request.url(),
            httpVersion: "HTTP/1.1",
            cookies: [],
            headers: [],
            queryString: [...url.searchParams].map((e) => ({name: e[0], value: e[1]})),
            postData: void 0,
            headersSize: -1,
            bodySize: -1
          },
          response: {
            status: -1,
            statusText: "",
            httpVersion: "HTTP/1.1",
            cookies: [],
            headers: [],
            content: {
              size: -1,
              mimeType: request.headerValue("content-type") || "application/octet-stream"
            },
            headersSize: -1,
            bodySize: -1,
            redirectURL: ""
          },
          cache: {
            beforeRequest: null,
            afterRequest: null
          },
          timings: {
            send: -1,
            wait: -1,
            receive: -1
          }
        };
        if (request.redirectedFrom()) {
          const fromEntry = this._entries.get(request.redirectedFrom());
          fromEntry.response.redirectURL = request.url();
        }
        this._log.entries.push(harEntry);
        this._entries.set(request, harEntry);
      }
      _onResponse(page, response) {
        const pageEntry = this._pageEntries.get(page);
        const harEntry = this._entries.get(response.request());
        const request = response.request();
        harEntry.request.headers = request.headers().map((header) => ({name: header.name, value: header.value}));
        harEntry.request.cookies = cookiesForHar(request.headerValue("cookie"), ";");
        harEntry.request.postData = postDataForHar(request) || void 0;
        harEntry.response = {
          status: response.status(),
          statusText: response.statusText(),
          httpVersion: "HTTP/1.1",
          cookies: cookiesForHar(response.headerValue("set-cookie"), "\n"),
          headers: response.headers().map((header) => ({name: header.name, value: header.value})),
          content: {
            size: -1,
            mimeType: response.headerValue("content-type") || "application/octet-stream"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: ""
        };
        const timing = response.timing();
        if (pageEntry.startedDateTime.valueOf() > timing.startTime)
          pageEntry.startedDateTime = new Date(timing.startTime);
        harEntry.timings = {
          dns: timing.domainLookupEnd !== -1 ? helper_1.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1,
          connect: timing.connectEnd !== -1 ? helper_1.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1,
          ssl: timing.connectEnd !== -1 ? helper_1.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1,
          send: 0,
          wait: timing.responseStart !== -1 ? helper_1.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1,
          receive: response.request()._responseEndTiming !== -1 ? helper_1.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1
        };
        if (!this._options.omitContent && response.status() === 200) {
          const promise = response.body().then((buffer) => {
            harEntry.response.content.text = buffer.toString("base64");
            harEntry.response.content.encoding = "base64";
          }).catch(() => {
          });
          this._addBarrier(page, promise);
        }
      }
      async flush() {
        await Promise.all(this._barrierPromises);
        for (const pageEntry of this._log.pages) {
          if (pageEntry.pageTimings.onContentLoad >= 0)
            pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onContentLoad = -1;
          if (pageEntry.pageTimings.onLoad >= 0)
            pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onLoad = -1;
        }
        await fsWriteFileAsync(this._options.path, JSON.stringify({log: this._log}, void 0, 2));
      }
    };
    exports2.HarTracer = HarTracer;
    function postDataForHar(request) {
      const postData = request.postDataBuffer();
      if (!postData)
        return null;
      const contentType = request.headerValue("content-type") || "application/octet-stream";
      const result = {
        mimeType: contentType,
        text: contentType === "application/octet-stream" ? "" : postData.toString(),
        params: []
      };
      if (contentType === "application/x-www-form-urlencoded") {
        const parsed = new URLSearchParams(postData.toString());
        for (const [name, value] of parsed.entries())
          result.params.push({name, value});
      }
      return result;
    }
    function cookiesForHar(header, separator) {
      if (!header)
        return [];
      return header.split(separator).map((c) => parseCookie(c));
    }
    function parseCookie(c) {
      const cookie = {
        name: "",
        value: ""
      };
      let first = true;
      for (const pair of c.split(/; */)) {
        const indexOfEquals = pair.indexOf("=");
        const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
        const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : "";
        if (first) {
          first = false;
          cookie.name = name;
          cookie.value = value;
          continue;
        }
        if (name === "Domain")
          cookie.domain = value;
        if (name === "Expires")
          cookie.expires = new Date(value);
        if (name === "HttpOnly")
          cookie.httpOnly = true;
        if (name === "Max-Age")
          cookie.expires = new Date(Date.now() + +value * 1e3);
        if (name === "Path")
          cookie.path = value;
        if (name === "SameSite")
          cookie.sameSite = value;
        if (name === "Secure")
          cookie.secure = true;
      }
      return cookie;
    }
  }
});

// node_modules/playwright/lib/server/supplements/recorder/utils.js
var require_utils2 = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.describeFrame = exports2.toModifiers = exports2.toClickOptions = void 0;
    function toClickOptions(action) {
      let method = "click";
      if (action.clickCount === 2)
        method = "dblclick";
      const modifiers = toModifiers(action.modifiers);
      const options2 = {};
      if (action.button !== "left")
        options2.button = action.button;
      if (modifiers.length)
        options2.modifiers = modifiers;
      if (action.clickCount > 2)
        options2.clickCount = action.clickCount;
      return {method, options: options2};
    }
    exports2.toClickOptions = toClickOptions;
    function toModifiers(modifiers) {
      const result = [];
      if (modifiers & 1)
        result.push("Alt");
      if (modifiers & 2)
        result.push("Control");
      if (modifiers & 4)
        result.push("Meta");
      if (modifiers & 8)
        result.push("Shift");
      return result;
    }
    exports2.toModifiers = toModifiers;
    function describeFrame(frame) {
      const page = frame._page;
      if (page.mainFrame() === frame)
        return {isMainFrame: true, frameUrl: frame.url()};
      const frames = page.frames().filter((f) => f.name() === frame.name());
      if (frames.length === 1 && frames[0] === frame)
        return {isMainFrame: false, frameUrl: frame.url(), frameName: frame.name()};
      return {isMainFrame: false, frameUrl: frame.url()};
    }
    exports2.describeFrame = describeFrame;
  }
});

// node_modules/playwright/lib/server/supplements/recorder/codeGenerator.js
var require_codeGenerator = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/codeGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CodeGenerator = void 0;
    var events_1 = require("events");
    var utils_1 = require_utils2();
    var CodeGenerator = class extends events_1.EventEmitter {
      constructor(browserName, generateHeaders, launchOptions, contextOptions, deviceName, saveStorage) {
        super();
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        launchOptions = {headless: false, ...launchOptions};
        this._enabled = generateHeaders;
        this._options = {browserName, generateHeaders, launchOptions, contextOptions, deviceName, saveStorage};
        this.restart();
      }
      restart() {
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this.emit("change");
      }
      setEnabled(enabled) {
        this._enabled = enabled;
      }
      addAction(action) {
        if (!this._enabled)
          return;
        this.willPerformAction(action);
        this.didPerformAction(action);
      }
      willPerformAction(action) {
        if (!this._enabled)
          return;
        this._currentAction = action;
      }
      performedActionFailed(action) {
        if (!this._enabled)
          return;
        if (this._currentAction === action)
          this._currentAction = null;
      }
      didPerformAction(actionInContext) {
        if (!this._enabled)
          return;
        const {action, pageAlias} = actionInContext;
        let eraseLastAction = false;
        if (this._lastAction && this._lastAction.pageAlias === pageAlias) {
          const {action: lastAction} = this._lastAction;
          if (this._lastAction && action.name === "fill" && lastAction.name === "fill") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "click" && lastAction.name === "click") {
            if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "navigate" && lastAction.name === "navigate") {
            if (action.url === lastAction.url) {
              this._currentAction = null;
              return;
            }
          }
          if (lastAction && (action.name === "check" || action.name === "uncheck") && lastAction.name === "click") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
        }
        this._lastAction = actionInContext;
        this._currentAction = null;
        if (eraseLastAction)
          this._actions.pop();
        this._actions.push(actionInContext);
        this.emit("change");
      }
      commitLastAction() {
        if (!this._enabled)
          return;
        const action = this._lastAction;
        if (action)
          action.committed = true;
      }
      signal(pageAlias, frame, signal) {
        if (!this._enabled)
          return;
        if (this._currentAction) {
          this._currentAction.action.signals.push(signal);
          return;
        }
        if (this._lastAction && !this._lastAction.committed) {
          const signals = this._lastAction.action.signals;
          if (signal.name === "navigation" && signals.length && signals[signals.length - 1].name === "download")
            return;
          if (signal.name === "download" && signals.length && signals[signals.length - 1].name === "navigation")
            signals.length = signals.length - 1;
          signal.isAsync = true;
          this._lastAction.action.signals.push(signal);
          this.emit("change");
          return;
        }
        if (signal.name === "navigation") {
          this.addAction({
            pageAlias,
            ...utils_1.describeFrame(frame),
            committed: true,
            action: {
              name: "navigate",
              url: frame.url(),
              signals: []
            }
          });
        }
      }
      generateText(languageGenerator) {
        const text = [];
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateHeader(this._options));
        for (const action of this._actions)
          text.push(languageGenerator.generateAction(action));
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateFooter(this._options.saveStorage));
        return text.join("\n");
      }
    };
    exports2.CodeGenerator = CodeGenerator;
  }
});

// node_modules/playwright/lib/server/supplements/recorder/language.js
var require_language = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.toSignalMap = exports2.sanitizeDeviceOptions = void 0;
    function sanitizeDeviceOptions(device, options2) {
      const cleanedOptions = {};
      for (const property in options2) {
        if (JSON.stringify(device[property]) !== JSON.stringify(options2[property]))
          cleanedOptions[property] = options2[property];
      }
      return cleanedOptions;
    }
    exports2.sanitizeDeviceOptions = sanitizeDeviceOptions;
    function toSignalMap(action) {
      let waitForNavigation;
      let assertNavigation;
      let popup;
      let download;
      let dialog;
      for (const signal of action.signals) {
        if (signal.name === "navigation" && signal.isAsync)
          waitForNavigation = signal;
        else if (signal.name === "navigation" && !signal.isAsync)
          assertNavigation = signal;
        else if (signal.name === "popup")
          popup = signal;
        else if (signal.name === "download")
          download = signal;
        else if (signal.name === "dialog")
          dialog = signal;
      }
      return {
        waitForNavigation,
        assertNavigation,
        popup,
        download,
        dialog
      };
    }
    exports2.toSignalMap = toSignalMap;
  }
});

// node_modules/playwright/lib/server/supplements/recorder/recorderActions.js
var require_recorderActions = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/recorderActions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.actionTitle = void 0;
    function actionTitle(action) {
      switch (action.name) {
        case "openPage":
          return `Open new page`;
        case "closePage":
          return `Close page`;
        case "check":
          return `Check ${action.selector}`;
        case "uncheck":
          return `Uncheck ${action.selector}`;
        case "click": {
          if (action.clickCount === 1)
            return `Click ${action.selector}`;
          if (action.clickCount === 2)
            return `Double click ${action.selector}`;
          if (action.clickCount === 3)
            return `Triple click ${action.selector}`;
          return `${action.clickCount}\xD7 click`;
        }
        case "fill":
          return `Fill ${action.selector}`;
        case "setInputFiles":
          if (action.files.length === 0)
            return `Clear selected files`;
          else
            return `Upload ${action.files.join(", ")}`;
        case "navigate":
          return `Go to ${action.url}`;
        case "press":
          return `Press ${action.key}` + (action.modifiers ? " with modifiers" : "");
        case "select":
          return `Select ${action.options.join(", ")}`;
      }
    }
    exports2.actionTitle = actionTitle;
  }
});

// node_modules/playwright/lib/server/deviceDescriptors.js
var require_deviceDescriptors = __commonJS({
  "node_modules/playwright/lib/server/deviceDescriptors.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "Blackberry PlayBook": {
        "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        "viewport": {
          "width": 600,
          "height": 1024
        },
        "deviceScaleFactor": 1,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Blackberry PlayBook landscape": {
        "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        "viewport": {
          "width": 1024,
          "height": 600
        },
        "deviceScaleFactor": 1,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "BlackBerry Z30": {
        "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "BlackBerry Z30 landscape": {
        "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Galaxy Note 3": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Galaxy Note 3 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Galaxy Note II": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Galaxy Note II landscape": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Galaxy S III": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Galaxy S III landscape": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Galaxy S5": {
        "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Galaxy S5 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Galaxy S8": {
        "userAgent": "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "viewport": {
          "width": 360,
          "height": 740
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Galaxy S8 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        "viewport": {
          "width": 740,
          "height": 360
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Galaxy S9+": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "viewport": {
          "width": 320,
          "height": 658
        },
        "deviceScaleFactor": 4.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Galaxy S9+ landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        "viewport": {
          "width": 658,
          "height": 320
        },
        "deviceScaleFactor": 4.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Galaxy Tab S4": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
        "viewport": {
          "width": 712,
          "height": 1138
        },
        "deviceScaleFactor": 2.25,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Galaxy Tab S4 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
        "viewport": {
          "width": 1138,
          "height": 712
        },
        "deviceScaleFactor": 2.25,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "iPad (gen 6)": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 768,
          "height": 1024
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPad (gen 6) landscape": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 768
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPad (gen 7)": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 810,
          "height": 1080
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPad (gen 7) landscape": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 1080,
          "height": 810
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPad Mini": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 768,
          "height": 1024
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPad Mini landscape": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 768
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPad Pro 11": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 834,
          "height": 1194
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPad Pro 11 landscape": {
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 1194,
          "height": 834
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 6": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 6 landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 6 Plus": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 6 Plus landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 7": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 7 landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 7 Plus": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 7 Plus landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 8": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 8 landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 8 Plus": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 8 Plus landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone SE": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 320,
          "height": 568
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone SE landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 568,
          "height": 320
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone X": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 812
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone X landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 812,
          "height": 375
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone XR": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 896
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone XR landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
        "viewport": {
          "width": 896,
          "height": 414
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 11": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 414,
          "height": 896
        },
        "viewport": {
          "width": 414,
          "height": 715
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 11 landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 414,
          "height": 896
        },
        "viewport": {
          "width": 800,
          "height": 364
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 11 Pro": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 375,
          "height": 812
        },
        "viewport": {
          "width": 375,
          "height": 635
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 11 Pro landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 375,
          "height": 812
        },
        "viewport": {
          "width": 724,
          "height": 325
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 11 Pro Max": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 414,
          "height": 896
        },
        "viewport": {
          "width": 414,
          "height": 715
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 11 Pro Max landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 414,
          "height": 896
        },
        "viewport": {
          "width": 808,
          "height": 364
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 12": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 390,
          "height": 844
        },
        "viewport": {
          "width": 390,
          "height": 664
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 12 landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 390,
          "height": 844
        },
        "viewport": {
          "width": 750,
          "height": 340
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 12 Pro": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 390,
          "height": 844
        },
        "viewport": {
          "width": 390,
          "height": 664
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 12 Pro landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 390,
          "height": 844
        },
        "viewport": {
          "width": 750,
          "height": 340
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 12 Pro Max": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 428,
          "height": 926
        },
        "viewport": {
          "width": 428,
          "height": 746
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "iPhone 12 Pro Max landscape": {
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Mobile/15E148 Safari/604.1",
        "screen": {
          "width": 428,
          "height": 926
        },
        "viewport": {
          "width": 832,
          "height": 378
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "JioPhone 2": {
        "userAgent": "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        "viewport": {
          "width": 240,
          "height": 320
        },
        "deviceScaleFactor": 1,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "firefox"
      },
      "JioPhone 2 landscape": {
        "userAgent": "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        "viewport": {
          "width": 320,
          "height": 240
        },
        "deviceScaleFactor": 1,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "firefox"
      },
      "Kindle Fire HDX": {
        "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        "viewport": {
          "width": 800,
          "height": 1280
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Kindle Fire HDX landscape": {
        "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        "viewport": {
          "width": 1280,
          "height": 800
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "LG Optimus L70": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 384,
          "height": 640
        },
        "deviceScaleFactor": 1.25,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "LG Optimus L70 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 384
        },
        "deviceScaleFactor": 1.25,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Microsoft Lumia 550": {
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Microsoft Lumia 550 landscape": {
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Microsoft Lumia 950": {
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 4,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Microsoft Lumia 950 landscape": {
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 4,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 10": {
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 800,
          "height": 1280
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 10 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 1280,
          "height": 800
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 4": {
        "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 384,
          "height": 640
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 4 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 384
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 5": {
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 360,
          "height": 640
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 5 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 360
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 5X": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732
        },
        "deviceScaleFactor": 2.625,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 5X landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412
        },
        "deviceScaleFactor": 2.625,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 6": {
        "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732
        },
        "deviceScaleFactor": 3.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 6 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412
        },
        "deviceScaleFactor": 3.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 6P": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732
        },
        "deviceScaleFactor": 3.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 6P landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412
        },
        "deviceScaleFactor": 3.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 7": {
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 600,
          "height": 960
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nexus 7 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 960,
          "height": 600
        },
        "deviceScaleFactor": 2,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nokia Lumia 520": {
        "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        "viewport": {
          "width": 320,
          "height": 533
        },
        "deviceScaleFactor": 1.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nokia Lumia 520 landscape": {
        "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        "viewport": {
          "width": 533,
          "height": 320
        },
        "deviceScaleFactor": 1.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Nokia N9": {
        "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        "viewport": {
          "width": 480,
          "height": 854
        },
        "deviceScaleFactor": 1,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Nokia N9 landscape": {
        "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        "viewport": {
          "width": 854,
          "height": 480
        },
        "deviceScaleFactor": 1,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "webkit"
      },
      "Pixel 2": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 411,
          "height": 731
        },
        "deviceScaleFactor": 2.625,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 2 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 731,
          "height": 411
        },
        "deviceScaleFactor": 2.625,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 2 XL": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 411,
          "height": 823
        },
        "deviceScaleFactor": 3.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 2 XL landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 823,
          "height": 411
        },
        "deviceScaleFactor": 3.5,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 3": {
        "userAgent": "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
        "viewport": {
          "width": 393,
          "height": 786
        },
        "deviceScaleFactor": 2.75,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 3 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
        "viewport": {
          "width": 786,
          "height": 393
        },
        "deviceScaleFactor": 2.75,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 4": {
        "userAgent": "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
        "viewport": {
          "width": 353,
          "height": 745
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 4 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
        "viewport": {
          "width": 745,
          "height": 353
        },
        "deviceScaleFactor": 3,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 4a (5G)": {
        "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.105 Mobile Safari/537.36",
        "screen": {
          "width": 412,
          "height": 892
        },
        "viewport": {
          "width": 412,
          "height": 765
        },
        "deviceScaleFactor": 2.63,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 4a (5G) landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.105 Mobile Safari/537.36",
        "screen": {
          "height": 892,
          "width": 412
        },
        "viewport": {
          "width": 840,
          "height": 312
        },
        "deviceScaleFactor": 2.63,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 5": {
        "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.105 Mobile Safari/537.36",
        "screen": {
          "width": 393,
          "height": 851
        },
        "viewport": {
          "width": 393,
          "height": 727
        },
        "deviceScaleFactor": 2.75,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      },
      "Pixel 5 landscape": {
        "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.105 Mobile Safari/537.36",
        "screen": {
          "width": 851,
          "height": 393
        },
        "viewport": {
          "width": 802,
          "height": 293
        },
        "deviceScaleFactor": 2.75,
        "isMobile": true,
        "hasTouch": true,
        "defaultBrowserType": "chromium"
      }
    };
  }
});

// node_modules/playwright/lib/server/supplements/recorder/javascript.js
var require_javascript2 = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/javascript.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.JavaScriptFormatter = exports2.JavaScriptLanguageGenerator = void 0;
    var language_1 = require_language();
    var recorderActions_1 = require_recorderActions();
    var utils_1 = require_utils2();
    var deviceDescriptors_1 = __importDefault(require_deviceDescriptors());
    var JavaScriptLanguageGenerator = class {
      constructor() {
        this.id = "javascript";
        this.fileName = "<javascript>";
        this.highlighter = "javascript";
      }
      generateAction(actionInContext) {
        const {action, pageAlias} = actionInContext;
        const formatter = new JavaScriptFormatter(2);
        formatter.newLine();
        formatter.add("// " + recorderActions_1.actionTitle(action));
        if (action.name === "openPage") {
          formatter.add(`const ${pageAlias} = await context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${formatObject({name: actionInContext.frameName})})` : `${pageAlias}.frame(${formatObject({url: actionInContext.frameUrl})})`;
        const signals = language_1.toSignalMap(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: \${dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
        }
        const emitPromiseAll = signals.waitForNavigation || signals.popup || signals.download;
        if (emitPromiseAll) {
          let leftHandSide = "";
          if (signals.popup)
            leftHandSide = `const [${signals.popup.popupAlias}] = `;
          else if (signals.download)
            leftHandSide = `const [download] = `;
          formatter.add(`${leftHandSide}await Promise.all([`);
        }
        if (signals.popup)
          formatter.add(`${pageAlias}.waitForEvent('popup'),`);
        if (signals.waitForNavigation)
          formatter.add(`${pageAlias}.waitForNavigation(/*{ url: ${quote(signals.waitForNavigation.url)} }*/),`);
        if (signals.download)
          formatter.add(`${pageAlias}.waitForEvent('download'),`);
        const prefix = signals.popup || signals.waitForNavigation || signals.download ? "" : "await ";
        const actionCall = this._generateActionCall(action);
        const suffix = signals.waitForNavigation || emitPromiseAll ? "" : ";";
        formatter.add(`${prefix}${subject}.${actionCall}${suffix}`);
        if (emitPromiseAll)
          formatter.add(`]);`);
        else if (signals.assertNavigation)
          formatter.add(`  // assert.equal(${pageAlias}.url(), ${quote(signals.assertNavigation.url)});`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = utils_1.toModifiers(action.modifiers);
            const options2 = {};
            if (action.button !== "left")
              options2.button = action.button;
            if (modifiers.length)
              options2.modifiers = modifiers;
            if (action.clickCount > 2)
              options2.clickCount = action.clickCount;
            const optionsString = formatOptions(options2);
            return `${method}(${quote(action.selector)}${optionsString})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `setInputFiles(${quote(action.selector)}, ${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = utils_1.toModifiers(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return `selectOption(${quote(action.selector)}, ${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options2) {
        const formatter = new JavaScriptFormatter();
        formatter.add(`
      const { ${options2.browserName}${options2.deviceName ? ", devices" : ""} } = require('playwright');

      (async () => {
        const browser = await ${options2.browserName}.launch(${formatObjectOrVoid(options2.launchOptions)});
        const context = await browser.newContext(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
  await context.storageState({ path: '${saveStorage}' });` : "";
        return `
  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
      }
    };
    exports2.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;
    function formatOptions(value) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return ", " + formatObject(value);
    }
    function formatObject(value, indent = "  ") {
      if (typeof value === "string")
        return quote(value);
      if (Array.isArray(value))
        return `[${value.map((o) => formatObject(o)).join(", ")}]`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return "{}";
        const tokens = [];
        for (const key of keys)
          tokens.push(`${key}: ${formatObject(value[key])}`);
        return `{
${indent}${tokens.join(`,
${indent}`)}
}`;
      }
      return String(value);
    }
    function formatObjectOrVoid(value, indent = "  ") {
      const result = formatObject(value, indent);
      return result === "{}" ? "" : result;
    }
    function formatContextOptions(options2, deviceName) {
      const device = deviceName && deviceDescriptors_1.default[deviceName];
      if (!device)
        return formatObjectOrVoid(options2);
      let serializedObject = formatObjectOrVoid(language_1.sanitizeDeviceOptions(device, options2));
      if (!serializedObject)
        serializedObject = "{\n}";
      const lines = serializedObject.split("\n");
      lines.splice(1, 0, `...devices['${deviceName}'],`);
      return lines.join("\n");
    }
    var JavaScriptFormatter = class {
      constructor(offset = 0) {
        this._lines = [];
        this._baseIndent = " ".repeat(2);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]"))
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          const callCarryOver = line.startsWith(".set");
          line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : "") + line;
          if (line.endsWith("{") || line.endsWith("["))
            spaces += this._baseIndent;
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    exports2.JavaScriptFormatter = JavaScriptFormatter;
    function quote(text, char = "'") {
      if (char === "'")
        return char + text.replace(/[']/g, "\\'") + char;
      if (char === '"')
        return char + text.replace(/["]/g, '\\"') + char;
      if (char === "`")
        return char + text.replace(/[`]/g, "\\`") + char;
      throw new Error("Invalid escape char");
    }
  }
});

// node_modules/playwright/lib/server/supplements/recorder/java.js
var require_java = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/java.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.JavaLanguageGenerator = void 0;
    var language_1 = require_language();
    var recorderActions_1 = require_recorderActions();
    var utils_1 = require_utils2();
    var deviceDescriptors_1 = __importDefault(require_deviceDescriptors());
    var javascript_1 = require_javascript2();
    var JavaLanguageGenerator = class {
      constructor() {
        this.id = "java";
        this.fileName = "<java>";
        this.highlighter = "java";
      }
      generateAction(actionInContext) {
        const {action, pageAlias} = actionInContext;
        const formatter = new javascript_1.JavaScriptFormatter(6);
        formatter.newLine();
        formatter.add("// " + recorderActions_1.actionTitle(action));
        if (action.name === "openPage") {
          formatter.add(`Page ${pageAlias} = context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${pageAlias}.navigate("${action.url}");`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${quote(actionInContext.frameName)})` : `${pageAlias}.frameByUrl(${quote(actionInContext.frameUrl)})`;
        const signals = language_1.toSignalMap(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
        }
        const actionCall = this._generateActionCall(action);
        let code = `${subject}.${actionCall};`;
        if (signals.popup) {
          code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
        }
        if (signals.download) {
          code = `Download download = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
        }
        if (signals.waitForNavigation) {
          code = `
      // ${pageAlias}.waitForNavigation(new Page.WaitForNavigationOptions().setUrl(${quote(signals.waitForNavigation.url)}), () ->
      ${pageAlias}.waitForNavigation(() -> {
        ${code}
      });`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`// assert ${pageAlias}.url().equals(${quote(signals.assertNavigation.url)});`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            return `${method}(${quote(action.selector)})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `setInputFiles(${quote(action.selector)}, ${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = utils_1.toModifiers(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `navigate(${quote(action.url)})`;
          case "select":
            return `selectOption(${quote(action.selector)}, ${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options2) {
        const formatter = new javascript_1.JavaScriptFormatter();
        formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options2.browserName}().launch(${formatLaunchOptions(options2.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));` : "";
        return `
      // ---------------------${storageStateLine}
    }
  }
}`;
      }
    };
    exports2.JavaLanguageGenerator = JavaLanguageGenerator;
    function formatPath(files) {
      if (Array.isArray(files)) {
        if (files.length === 0)
          return "new Path[0]";
        return `new Path[] {${files.map((s2) => "Paths.get(" + quote(s2) + ")").join(", ")}}`;
      }
      return `Paths.get(${quote(files)})`;
    }
    function formatSelectOption(options2) {
      if (Array.isArray(options2)) {
        if (options2.length === 0)
          return "new String[0]";
        return `new String[] {${options2.map((s2) => quote(s2)).join(", ")}}`;
      }
      return quote(options2);
    }
    function formatLaunchOptions(options2) {
      const lines = [];
      if (!Object.keys(options2).length)
        return "";
      lines.push("new BrowserType.LaunchOptions()");
      if (typeof options2.headless === "boolean")
        lines.push(`  .setHeadless(false)`);
      if (options2.channel)
        lines.push(`  .setChannel("${options2.channel}")`);
      return lines.join("\n");
    }
    function formatContextOptions(contextOptions, deviceName) {
      const lines = [];
      if (!Object.keys(contextOptions).length && !deviceName)
        return "";
      const device = deviceName ? deviceDescriptors_1.default[deviceName] : {};
      const options2 = {...device, ...contextOptions};
      lines.push("new Browser.NewContextOptions()");
      if (options2.colorScheme)
        lines.push(`  .setColorScheme(ColorScheme.${options2.colorScheme.toUpperCase()})`);
      if (options2.geolocation)
        lines.push(`  .setGeolocation(${options2.geolocation.latitude}, ${options2.geolocation.longitude})`);
      if (options2.locale)
        lines.push(`  .setLocale("${options2.locale}")`);
      if (options2.proxy)
        lines.push(`  .setProxy(new Proxy("${options2.proxy.server}"))`);
      if (options2.timezoneId)
        lines.push(`  .setTimezoneId("${options2.timezoneId}")`);
      if (options2.userAgent)
        lines.push(`  .setUserAgent("${options2.userAgent}")`);
      if (options2.viewport)
        lines.push(`  .setViewportSize(${options2.viewport.width}, ${options2.viewport.height})`);
      if (options2.deviceScaleFactor)
        lines.push(`  .setDeviceScaleFactor(${options2.deviceScaleFactor})`);
      if (options2.isMobile)
        lines.push(`  .setIsMobile(${options2.isMobile})`);
      if (options2.hasTouch)
        lines.push(`  .setHasTouch(${options2.hasTouch})`);
      if (options2.storageState)
        lines.push(`  .setStorageStatePath(Paths.get(${quote(options2.storageState)}))`);
      return lines.join("\n");
    }
    function quote(text, char = '"') {
      if (char === "'")
        return char + text.replace(/[']/g, "\\'") + char;
      if (char === '"')
        return char + text.replace(/["]/g, '\\"') + char;
      if (char === "`")
        return char + text.replace(/[`]/g, "\\`") + char;
      throw new Error("Invalid escape char");
    }
  }
});

// node_modules/playwright/lib/server/supplements/recorder/csharp.js
var require_csharp = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/csharp.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CSharpLanguageGenerator = void 0;
    var language_1 = require_language();
    var recorderActions_1 = require_recorderActions();
    var utils_1 = require_utils2();
    var deviceDescriptors_1 = __importDefault(require_deviceDescriptors());
    var CSharpLanguageGenerator = class {
      constructor() {
        this.id = "csharp";
        this.fileName = "<csharp>";
        this.highlighter = "csharp";
      }
      generateAction(actionInContext) {
        const {action, pageAlias} = actionInContext;
        const formatter = new CSharpFormatter(0);
        formatter.newLine();
        formatter.add("// " + recorderActions_1.actionTitle(action));
        if (action.name === "openPage") {
          formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.GoToAsync(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.GetFrame(name: ${quote(actionInContext.frameName)})` : `${pageAlias}.GetFrame(url: ${quote(actionInContext.frameUrl)})`;
        const signals = language_1.toSignalMap(action);
        if (signals.dialog) {
          formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, DialogEventArgs e)
      {
          Console.WriteLine($"Dialog message: {e.Dialog.Message}");
          e.Dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);
        }
        const emitTaskWhenAll = signals.waitForNavigation || signals.popup || signals.download;
        if (emitTaskWhenAll) {
          if (signals.popup)
            formatter.add(`var ${signals.popup.popupAlias}Task = ${pageAlias}.WaitForEventAsync(PageEvent.Popup)`);
          else if (signals.download)
            formatter.add(`var downloadTask = ${pageAlias}.WaitForEventAsync(PageEvent.Download);`);
          formatter.add(`await Task.WhenAll(`);
        }
        if (signals.popup)
          formatter.add(`${signals.popup.popupAlias}Task,`);
        if (signals.waitForNavigation)
          formatter.add(`${pageAlias}.WaitForNavigationAsync(/*${quote(signals.waitForNavigation.url)}*/),`);
        if (signals.download)
          formatter.add(`downloadTask,`);
        const prefix = signals.popup || signals.waitForNavigation || signals.download ? "" : "await ";
        const actionCall = this._generateActionCall(action);
        const suffix = emitTaskWhenAll ? ");" : ";";
        formatter.add(`${prefix}${subject}.${actionCall}${suffix}`);
        if (signals.assertNavigation)
          formatter.add(`  // Assert.Equal(${quote(signals.assertNavigation.url)}, ${pageAlias}.Url);`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "CloseAsync()";
          case "click": {
            let method = "ClickAsync";
            if (action.clickCount === 2)
              method = "DblClickAsync";
            const modifiers = utils_1.toModifiers(action.modifiers);
            const options2 = {};
            if (action.button !== "left")
              options2.button = action.button;
            if (modifiers.length)
              options2.modifiers = modifiers;
            if (action.clickCount > 2)
              options2.clickCount = action.clickCount;
            const optionsString = formatOptions(options2, true, false);
            return `${method}(${quote(action.selector)}${optionsString})`;
          }
          case "check":
            return `CheckAsync(${quote(action.selector)})`;
          case "uncheck":
            return `UncheckAsync(${quote(action.selector)})`;
          case "fill":
            return `FillAsync(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `SetInputFilesAsync(${quote(action.selector)}, ${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = utils_1.toModifiers(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `PressAsync(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `GoToAsync(${quote(action.url)})`;
          case "select":
            return `SelectOptionAsync(${quote(action.selector)}, ${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options2) {
        const formatter = new CSharpFormatter(0);
        formatter.add(`
      await Playwright.InstallAsync();
      using var playwright = await Playwright.CreateAsync();
      await using var browser = await playwright.${toPascal(options2.browserName)}.LaunchAsync(${formatArgs(options2.launchOptions)}
      );
      var context = await browser.NewContextAsync(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
await context.StorageStateAsync(path: "${saveStorage}");` : "";
        return `
// ---------------------${storageStateLine}`;
      }
    };
    exports2.CSharpLanguageGenerator = CSharpLanguageGenerator;
    function formatValue(value) {
      if (value === false)
        return "false";
      if (value === true)
        return "true";
      if (value === void 0)
        return "null";
      if (Array.isArray(value))
        return `new [] {${value.map(formatValue).join(", ")}}`;
      if (typeof value === "string")
        return quote(value);
      return String(value);
    }
    function formatOptions(value, hasArguments, isInitializing) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + keys.map((key) => `${key}${isInitializing ? ": " : " = "}${formatValue(value[key])}`).join(", ");
    }
    function formatArgs(value, indent = "    ") {
      if (typeof value === "string")
        return quote(value);
      if (Array.isArray(value))
        return `new [] {${value.map((o) => formatObject(o)).join(", ")}}`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return "";
        const tokens = [];
        for (const key of keys)
          tokens.push(`${keys.length !== 1 ? indent : ""}${key}: ${formatObject(value[key], indent, key)}`);
        return `
${indent}${tokens.join(`,
${indent}`)}`;
      }
      return String(value);
    }
    function formatObject(value, indent = "    ", name = "") {
      if (typeof value === "string") {
        if (name === "permissions" || name === "colorScheme")
          return `${getClassName(name)}.${toPascal(value)}`;
        return quote(value);
      }
      if (Array.isArray(value))
        return `new[] { ${value.map((o) => formatObject(o, indent, name)).join(", ")} }`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return "";
        const tokens = [];
        for (const key of keys)
          tokens.push(`${toPascal(key)} = ${formatObject(value[key], indent, key)},`);
        if (name)
          return `new ${getClassName(name)}
{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
        return `{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
      }
      if (name === "latitude" || name === "longitude")
        return String(value) + "m";
      return String(value);
    }
    function getClassName(value) {
      switch (value) {
        case "viewport":
          return "ViewportSize";
        case "proxy":
          return "ProxySettings";
        case "permissions":
          return "ContextPermission";
        default:
          return toPascal(value);
      }
    }
    function toPascal(value) {
      return value[0].toUpperCase() + value.slice(1);
    }
    function formatContextOptions(options2, deviceName) {
      const device = deviceName && deviceDescriptors_1.default[deviceName];
      if (!device)
        return formatArgs(options2);
      const serializedObject = formatObject(language_1.sanitizeDeviceOptions(device, options2), "    ");
      if (!serializedObject)
        return `playwright.Devices["${deviceName}"]`;
      let result = `new BrowserContextOptions(playwright.Devices["${deviceName}"])`;
      if (serializedObject) {
        const lines = serializedObject.split("\n");
        result = `${result} 
${lines.join("\n")}`;
      }
      return result;
    }
    var CSharpFormatter = class {
      constructor(offset = 0) {
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]") || line.includes("});") || line === ");")
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          line = spaces + extraSpaces + line;
          if (line.endsWith("{") || line.endsWith("[") || line.endsWith("("))
            spaces += this._baseIndent;
          if (line.endsWith("});"))
            spaces = spaces.substring(this._baseIndent.length);
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    function quote(text) {
      return `"${text.replace(/["]/g, '\\"')}"`;
    }
  }
});

// node_modules/playwright/lib/server/supplements/recorder/python.js
var require_python = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/python.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.PythonLanguageGenerator = void 0;
    var language_1 = require_language();
    var recorderActions_1 = require_recorderActions();
    var utils_1 = require_utils2();
    var deviceDescriptors_1 = __importDefault(require_deviceDescriptors());
    var PythonLanguageGenerator = class {
      constructor(isAsync) {
        this.id = "python";
        this.fileName = "<python>";
        this.highlighter = "python";
        this.id = isAsync ? "python-async" : "python";
        this.fileName = isAsync ? "<async python>" : "<python>";
        this._isAsync = isAsync;
        this._awaitPrefix = isAsync ? "await " : "";
        this._asyncPrefix = isAsync ? "async " : "";
      }
      generateAction(actionInContext) {
        const {action, pageAlias} = actionInContext;
        const formatter = new PythonFormatter(4);
        formatter.newLine();
        formatter.add("# " + recorderActions_1.actionTitle(action));
        if (action.name === "openPage") {
          formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${formatOptions({name: actionInContext.frameName}, false)})` : `${pageAlias}.frame(${formatOptions({url: actionInContext.frameUrl}, false)})`;
        const signals = language_1.toSignalMap(action);
        if (signals.dialog)
          formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
        const actionCall = this._generateActionCall(action);
        let code = `${this._awaitPrefix}${subject}.${actionCall}`;
        if (signals.popup) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as popup_info {
        ${code}
      }
      ${signals.popup.popupAlias} = ${this._awaitPrefix}popup_info.value`;
        }
        if (signals.download) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download_info {
        ${code}
      }
      download = ${this._awaitPrefix}download_info.value`;
        }
        if (signals.waitForNavigation) {
          code = `
      # ${this._asyncPrefix}with ${pageAlias}.expect_navigation(url=${quote(signals.waitForNavigation.url)}):
      ${this._asyncPrefix}with ${pageAlias}.expect_navigation() {
        ${code}
      }`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`  # assert ${pageAlias}.url == ${quote(signals.assertNavigation.url)}`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = utils_1.toModifiers(action.modifiers);
            const options2 = {};
            if (action.button !== "left")
              options2.button = action.button;
            if (modifiers.length)
              options2.modifiers = modifiers;
            if (action.clickCount > 2)
              options2.clickCount = action.clickCount;
            const optionsString = formatOptions(options2, true);
            return `${method}(${quote(action.selector)}${optionsString})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `set_input_files(${quote(action.selector)}, ${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = utils_1.toModifiers(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return `select_option(${quote(action.selector)}, ${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
        }
      }
      generateHeader(options2) {
        const formatter = new PythonFormatter();
        if (this._isAsync) {
          formatter.add(`
import asyncio
from playwright.async_api import async_playwright

async def run(playwright) {
    browser = await playwright.${options2.browserName}.launch(${formatOptions(options2.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions(options2.contextOptions, options2.deviceName)})`);
        } else {
          formatter.add(`
from playwright.sync_api import sync_playwright

def run(playwright) {
    browser = playwright.${options2.browserName}.launch(${formatOptions(options2.launchOptions, false)})
    context = browser.new_context(${formatContextOptions(options2.contextOptions, options2.deviceName)})`);
        }
        return formatter.format();
      }
      generateFooter(saveStorage) {
        if (this._isAsync) {
          const storageStateLine = saveStorage ? `
    await context.storage_state(path="${saveStorage}")` : "";
          return `
    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())`;
        } else {
          const storageStateLine = saveStorage ? `
    context.storage_state(path="${saveStorage}")` : "";
          return `
    # ---------------------${storageStateLine}
    context.close()
    browser.close()

with sync_playwright() as playwright:
    run(playwright)`;
        }
      }
    };
    exports2.PythonLanguageGenerator = PythonLanguageGenerator;
    function formatValue(value) {
      if (value === false)
        return "False";
      if (value === true)
        return "True";
      if (value === void 0)
        return "None";
      if (Array.isArray(value))
        return `[${value.map(formatValue).join(", ")}]`;
      if (typeof value === "string")
        return quote(value);
      return String(value);
    }
    function toSnakeCase(name) {
      const toSnakeCaseRegex = /((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))/g;
      return name.replace(toSnakeCaseRegex, `_$1`).toLowerCase();
    }
    function formatOptions(value, hasArguments) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + keys.map((key) => `${toSnakeCase(key)}=${formatValue(value[key])}`).join(", ");
    }
    function formatContextOptions(options2, deviceName) {
      const device = deviceName && deviceDescriptors_1.default[deviceName];
      if (!device)
        return formatOptions(options2, false);
      return `**playwright.devices["${deviceName}"]` + formatOptions(language_1.sanitizeDeviceOptions(device, options2), true);
    }
    var PythonFormatter = class {
      constructor(offset = 0) {
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        const lines = [];
        this._lines.forEach((line) => {
          if (line === "")
            return lines.push(line);
          if (line === "}") {
            spaces = spaces.substring(this._baseIndent.length);
            return;
          }
          line = spaces + line;
          if (line.endsWith("{")) {
            spaces += this._baseIndent;
            line = line.substring(0, line.length - 1).trimEnd() + ":";
          }
          return lines.push(this._baseOffset + line);
        });
        return lines.join("\n");
      }
    };
    function quote(text, char = '"') {
      if (char === "'")
        return char + text.replace(/[']/g, "\\'") + char;
      if (char === '"')
        return char + text.replace(/["]/g, '\\"') + char;
      if (char === "`")
        return char + text.replace(/[`]/g, "\\`") + char;
      throw new Error("Invalid escape char");
    }
  }
});

// node_modules/playwright/lib/generated/recorderSource.js
var require_recorderSource = __commonJS({
  "node_modules/playwright/lib/generated/recorderSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.source = void 0;
    exports2.source = `var pwExport =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/supplements/injected/recorder.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/server/common/cssParser.ts":
/*!****************************************!*\\
  !*** ./src/server/common/cssParser.ts ***!
  \\****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeSelector = exports.parseCSS = void 0;
const css = __importStar(__webpack_require__(/*! ./cssTokenizer */ "./src/server/common/cssTokenizer.js"));
function parseCSS(selector, customNames) {
    let tokens;
    try {
        tokens = css.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))
            tokens.push(new css.EOFToken());
    }
    catch (e) {
        const newMessage = e.message + \` while parsing selector "\${selector}"\`;
        const index = (e.stack || '').indexOf(e.message);
        if (index !== -1)
            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
    }
    const unsupportedToken = tokens.find(token => {
        return (token instanceof css.AtKeywordToken) ||
            (token instanceof css.BadStringToken) ||
            (token instanceof css.BadURLToken) ||
            (token instanceof css.ColumnToken) ||
            (token instanceof css.CDOToken) ||
            (token instanceof css.CDCToken) ||
            (token instanceof css.SemicolonToken) ||
            // TODO: Consider using these for something, e.g. to escape complex strings.
            // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }
            // Or this way :xpath( {complex-xpath-goes-here("hello")} )
            (token instanceof css.OpenCurlyToken) ||
            (token instanceof css.CloseCurlyToken) ||
            // TODO: Consider treating these as strings?
            (token instanceof css.URLToken) ||
            (token instanceof css.PercentageToken);
    });
    if (unsupportedToken)
        throw new Error(\`Unsupported token "\${unsupportedToken.toSource()}" while parsing selector "\${selector}"\`);
    let pos = 0;
    const names = new Set();
    function unexpected() {
        return new Error(\`Unexpected token "\${tokens[pos].toSource()}" while parsing selector "\${selector}"\`);
    }
    function skipWhitespace() {
        while (tokens[pos] instanceof css.WhitespaceToken)
            pos++;
    }
    function isIdent(p = pos) {
        return tokens[p] instanceof css.IdentToken;
    }
    function isString(p = pos) {
        return tokens[p] instanceof css.StringToken;
    }
    function isNumber(p = pos) {
        return tokens[p] instanceof css.NumberToken;
    }
    function isComma(p = pos) {
        return tokens[p] instanceof css.CommaToken;
    }
    function isCloseParen(p = pos) {
        return tokens[p] instanceof css.CloseParenToken;
    }
    function isStar(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';
    }
    function isEOF(p = pos) {
        return tokens[p] instanceof css.EOFToken;
    }
    function isClauseCombinator(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));
    }
    function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);
    }
    function consumeFunctionArguments() {
        const result = [consumeArgument()];
        while (true) {
            skipWhitespace();
            if (!isComma())
                break;
            pos++;
            result.push(consumeArgument());
        }
        return result;
    }
    function consumeArgument() {
        skipWhitespace();
        if (isNumber())
            return tokens[pos++].value;
        if (isString())
            return tokens[pos++].value;
        return consumeComplexSelector();
    }
    function consumeComplexSelector() {
        skipWhitespace();
        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };
        while (true) {
            skipWhitespace();
            if (isClauseCombinator()) {
                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;
                skipWhitespace();
            }
            else if (isSelectorClauseEnd()) {
                break;
            }
            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });
        }
        return result;
    }
    function consumeSimpleSelector() {
        let rawCSSString = '';
        const functions = [];
        while (!isSelectorClauseEnd()) {
            if (isIdent() || isStar()) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if (tokens[pos] instanceof css.HashToken) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {
                pos++;
                if (isIdent())
                    rawCSSString += '.' + tokens[pos++].toSource();
                else
                    throw unexpected();
            }
            else if (tokens[pos] instanceof css.ColonToken) {
                pos++;
                if (isIdent()) {
                    if (!customNames.has(tokens[pos].value.toLowerCase())) {
                        rawCSSString += ':' + tokens[pos++].toSource();
                    }
                    else {
                        const name = tokens[pos++].value.toLowerCase();
                        functions.push({ name, args: [] });
                        names.add(name);
                    }
                }
                else if (tokens[pos] instanceof css.FunctionToken) {
                    const name = tokens[pos++].value.toLowerCase();
                    if (!customNames.has(name)) {
                        rawCSSString += \`:\${name}(\${consumeBuiltinFunctionArguments()})\`;
                    }
                    else {
                        functions.push({ name, args: consumeFunctionArguments() });
                        names.add(name);
                    }
                    skipWhitespace();
                    if (!isCloseParen())
                        throw unexpected();
                    pos++;
                }
                else {
                    throw unexpected();
                }
            }
            else if (tokens[pos] instanceof css.OpenSquareToken) {
                rawCSSString += '[';
                pos++;
                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())
                    rawCSSString += tokens[pos++].toSource();
                if (!(tokens[pos] instanceof css.CloseSquareToken))
                    throw unexpected();
                rawCSSString += ']';
                pos++;
            }
            else {
                throw unexpected();
            }
        }
        if (!rawCSSString && !functions.length)
            throw unexpected();
        return { css: rawCSSString || undefined, functions };
    }
    function consumeBuiltinFunctionArguments() {
        let s = '';
        while (!isCloseParen() && !isEOF())
            s += tokens[pos++].toSource();
        return s;
    }
    const result = consumeFunctionArguments();
    if (!isEOF())
        throw new Error(\`Error while parsing selector "\${selector}"\`);
    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))
        throw new Error(\`Error while parsing selector "\${selector}"\`);
    return { selector: result, names: Array.from(names) };
}
exports.parseCSS = parseCSS;
function serializeSelector(args) {
    return args.map(arg => {
        if (typeof arg === 'string')
            return \`"\${arg}"\`;
        if (typeof arg === 'number')
            return String(arg);
        return arg.simples.map(({ selector, combinator }) => {
            let s = selector.css || '';
            s = s + selector.functions.map(func => \`:\${func.name}(\${serializeSelector(func.args)})\`).join('');
            if (combinator)
                s += ' ' + combinator;
            return s;
        }).join(' ');
    }).join(', ');
}
exports.serializeSelector = serializeSelector;


/***/ }),

/***/ "./src/server/common/cssTokenizer.js":
/*!*******************************************!*\\
  !*** ./src/server/common/cssTokenizer.js ***!
  \\*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
/*
 * Original at https://github.com/tabatkins/parse-css
 * licensed under http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Changes from https://github.com/tabatkins/parse-css
//   - Tabs are replaced with two spaces.
//   - Everything not related to tokenizing - below the first exports block - is removed.
// @ts-nocheck
(function (root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else {}
}(this, function (exports) {
    var between = function (num, first, last) { return num >= first && num <= last; };
    function digit(code) { return between(code, 0x30, 0x39); }
    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }
    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }
    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }
    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
    function nonascii(code) { return code >= 0x80; }
    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }
    function newline(code) { return code == 0xa; }
    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
    function badescape(code) { return newline(code) || isNaN(code); }
    var maximumallowedcodepoint = 0x10ffff;
    var InvalidCharacterError = function (message) {
        this.message = message;
    };
    InvalidCharacterError.prototype = new Error;
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';
    function preprocess(str) {
        // Turn a string into an array of code points,
        // following the preprocessing cleanup rules.
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {
                code = 0xa;
                i++;
            }
            if (code == 0xd || code == 0xc)
                code = 0xa;
            if (code == 0x0)
                code = 0xfffd;
            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {
                // Decode a surrogate pair into an astral codepoint.
                var lead = code - 0xd800;
                var trail = str.charCodeAt(i + 1) - 0xdc00;
                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
                i++;
            }
            codepoints.push(code);
        }
        return codepoints;
    }
    function stringFromCode(code) {
        if (code <= 0xffff)
            return String.fromCharCode(code);
        // Otherwise, encode astral char as surrogate pair.
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;
        var trail = code % Math.pow(2, 10) + 0xdc00;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
    }
    function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        // Line number information.
        var line = 0;
        var column = 0;
        // The only use of lastLineLength is in reconsume().
        var lastLineLength = 0;
        var incrLineno = function () {
            line += 1;
            lastLineLength = column;
            column = 0;
        };
        var locStart = { line: line, column: column };
        var codepoint = function (i) {
            if (i >= str.length) {
                return -1;
            }
            return str[i];
        };
        var next = function (num) {
            if (num === undefined)
                num = 1;
            if (num > 3)
                throw "Spec Error: no more than three codepoints of lookahead.";
            return codepoint(i + num);
        };
        var consume = function (num) {
            if (num === undefined)
                num = 1;
            i += num;
            code = codepoint(i);
            if (newline(code))
                incrLineno();
            else
                column += num;
            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
            return true;
        };
        var reconsume = function () {
            i -= 1;
            if (newline(code)) {
                line -= 1;
                column = lastLineLength;
            }
            else {
                column -= 1;
            }
            locStart.line = line;
            locStart.column = column;
            return true;
        };
        var eof = function (codepoint) {
            if (codepoint === undefined)
                codepoint = code;
            return codepoint == -1;
        };
        var donothing = function () { };
        var parseerror = function () { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + "."); return true; };
        var consumeAToken = function () {
            consumeComments();
            consume();
            if (whitespace(code)) {
                while (whitespace(next()))
                    consume();
                return new WhitespaceToken;
            }
            else if (code == 0x22)
                return consumeAStringToken();
            else if (code == 0x23) {
                if (namechar(next()) || areAValidEscape(next(1), next(2))) {
                    var token = new HashToken();
                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                        token.type = "id";
                    token.value = consumeAName();
                    return token;
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x24) {
                if (next() == 0x3d) {
                    consume();
                    return new SuffixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x27)
                return consumeAStringToken();
            else if (code == 0x28)
                return new OpenParenToken();
            else if (code == 0x29)
                return new CloseParenToken();
            else if (code == 0x2a) {
                if (next() == 0x3d) {
                    consume();
                    return new SubstringMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2b) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2c)
                return new CommaToken();
            else if (code == 0x2d) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else if (next(1) == 0x2d && next(2) == 0x3e) {
                    consume(2);
                    return new CDCToken();
                }
                else if (startsWithAnIdentifier()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2e) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x3a)
                return new ColonToken;
            else if (code == 0x3b)
                return new SemicolonToken;
            else if (code == 0x3c) {
                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
                    consume(3);
                    return new CDOToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x40) {
                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                    return new AtKeywordToken(consumeAName());
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5b)
                return new OpenSquareToken();
            else if (code == 0x5c) {
                if (startsWithAValidEscape()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    parseerror();
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5d)
                return new CloseSquareToken();
            else if (code == 0x5e) {
                if (next() == 0x3d) {
                    consume();
                    return new PrefixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7b)
                return new OpenCurlyToken();
            else if (code == 0x7c) {
                if (next() == 0x3d) {
                    consume();
                    return new DashMatchToken();
                }
                else if (next() == 0x7c) {
                    consume();
                    return new ColumnToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7d)
                return new CloseCurlyToken();
            else if (code == 0x7e) {
                if (next() == 0x3d) {
                    consume();
                    return new IncludeMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (digit(code)) {
                reconsume();
                return consumeANumericToken();
            }
            else if (namestartchar(code)) {
                reconsume();
                return consumeAnIdentlikeToken();
            }
            else if (eof())
                return new EOFToken();
            else
                return new DelimToken(code);
        };
        var consumeComments = function () {
            while (next(1) == 0x2f && next(2) == 0x2a) {
                consume(2);
                while (true) {
                    consume();
                    if (code == 0x2a && next() == 0x2f) {
                        consume();
                        break;
                    }
                    else if (eof()) {
                        parseerror();
                        return;
                    }
                }
            }
        };
        var consumeANumericToken = function () {
            var num = consumeANumber();
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                var token = new DimensionToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                token.unit = consumeAName();
                return token;
            }
            else if (next() == 0x25) {
                consume();
                var token = new PercentageToken();
                token.value = num.value;
                token.repr = num.repr;
                return token;
            }
            else {
                var token = new NumberToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                return token;
            }
        };
        var consumeAnIdentlikeToken = function () {
            var str = consumeAName();
            if (str.toLowerCase() == "url" && next() == 0x28) {
                consume();
                while (whitespace(next(1)) && whitespace(next(2)))
                    consume();
                if (next() == 0x22 || next() == 0x27) {
                    return new FunctionToken(str);
                }
                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
                    return new FunctionToken(str);
                }
                else {
                    return consumeAURLToken();
                }
            }
            else if (next() == 0x28) {
                consume();
                return new FunctionToken(str);
            }
            else {
                return new IdentToken(str);
            }
        };
        var consumeAStringToken = function (endingCodePoint) {
            if (endingCodePoint === undefined)
                endingCodePoint = code;
            var string = "";
            while (consume()) {
                if (code == endingCodePoint || eof()) {
                    return new StringToken(string);
                }
                else if (newline(code)) {
                    parseerror();
                    reconsume();
                    return new BadStringToken();
                }
                else if (code == 0x5c) {
                    if (eof(next())) {
                        donothing();
                    }
                    else if (newline(next())) {
                        consume();
                    }
                    else {
                        string += stringFromCode(consumeEscape());
                    }
                }
                else {
                    string += stringFromCode(code);
                }
            }
        };
        var consumeAURLToken = function () {
            var token = new URLToken("");
            while (whitespace(next()))
                consume();
            if (eof(next()))
                return token;
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return token;
                }
                else if (whitespace(code)) {
                    while (whitespace(next()))
                        consume();
                    if (next() == 0x29 || eof(next())) {
                        consume();
                        return token;
                    }
                    else {
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
                    parseerror();
                    consumeTheRemnantsOfABadURL();
                    return new BadURLToken();
                }
                else if (code == 0x5c) {
                    if (startsWithAValidEscape()) {
                        token.value += stringFromCode(consumeEscape());
                    }
                    else {
                        parseerror();
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else {
                    token.value += stringFromCode(code);
                }
            }
        };
        var consumeEscape = function () {
            // Assume the the current character is the \\
            // and the next code point is not a newline.
            consume();
            if (hexdigit(code)) {
                // Consume 1-6 hex digits
                var digits = [code];
                for (var total = 0; total < 5; total++) {
                    if (hexdigit(next())) {
                        consume();
                        digits.push(code);
                    }
                    else {
                        break;
                    }
                }
                if (whitespace(next()))
                    consume();
                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);
                if (value > maximumallowedcodepoint)
                    value = 0xfffd;
                return value;
            }
            else if (eof()) {
                return 0xfffd;
            }
            else {
                return code;
            }
        };
        var areAValidEscape = function (c1, c2) {
            if (c1 != 0x5c)
                return false;
            if (newline(c2))
                return false;
            return true;
        };
        var startsWithAValidEscape = function () {
            return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function (c1, c2, c3) {
            if (c1 == 0x2d) {
                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
            }
            else if (namestartchar(c1)) {
                return true;
            }
            else if (c1 == 0x5c) {
                return areAValidEscape(c1, c2);
            }
            else {
                return false;
            }
        };
        var startsWithAnIdentifier = function () {
            return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function (c1, c2, c3) {
            if (c1 == 0x2b || c1 == 0x2d) {
                if (digit(c2))
                    return true;
                if (c2 == 0x2e && digit(c3))
                    return true;
                return false;
            }
            else if (c1 == 0x2e) {
                if (digit(c2))
                    return true;
                return false;
            }
            else if (digit(c1)) {
                return true;
            }
            else {
                return false;
            }
        };
        var startsWithANumber = function () {
            return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function () {
            var result = "";
            while (consume()) {
                if (namechar(code)) {
                    result += stringFromCode(code);
                }
                else if (startsWithAValidEscape()) {
                    result += stringFromCode(consumeEscape());
                }
                else {
                    reconsume();
                    return result;
                }
            }
        };
        var consumeANumber = function () {
            var repr = [];
            var type = "integer";
            if (next() == 0x2b || next() == 0x2d) {
                consume();
                repr += stringFromCode(code);
            }
            while (digit(next())) {
                consume();
                repr += stringFromCode(code);
            }
            if (next(1) == 0x2e && digit(next(2))) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var c1 = next(1), c2 = next(2), c3 = next(3);
            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var value = convertAStringToANumber(repr);
            return { type: type, value: value, repr: repr };
        };
        var convertAStringToANumber = function (string) {
            // CSS's number rules are identical to JS, afaik.
            return +string;
        };
        var consumeTheRemnantsOfABadURL = function () {
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return;
                }
                else if (startsWithAValidEscape()) {
                    consumeEscape();
                    donothing();
                }
                else {
                    donothing();
                }
            }
        };
        var iterationCount = 0;
        while (!eof(next())) {
            tokens.push(consumeAToken());
            iterationCount++;
            if (iterationCount > str.length * 2)
                return "I'm infinite-looping!";
        }
        return tokens;
    }
    function CSSParserToken() { throw "Abstract Base Class"; }
    CSSParserToken.prototype.toJSON = function () {
        return { token: this.tokenType };
    };
    CSSParserToken.prototype.toString = function () { return this.tokenType; };
    CSSParserToken.prototype.toSource = function () { return '' + this; };
    function BadStringToken() { return this; }
    BadStringToken.prototype = Object.create(CSSParserToken.prototype);
    BadStringToken.prototype.tokenType = "BADSTRING";
    function BadURLToken() { return this; }
    BadURLToken.prototype = Object.create(CSSParserToken.prototype);
    BadURLToken.prototype.tokenType = "BADURL";
    function WhitespaceToken() { return this; }
    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
    WhitespaceToken.prototype.tokenType = "WHITESPACE";
    WhitespaceToken.prototype.toString = function () { return "WS"; };
    WhitespaceToken.prototype.toSource = function () { return " "; };
    function CDOToken() { return this; }
    CDOToken.prototype = Object.create(CSSParserToken.prototype);
    CDOToken.prototype.tokenType = "CDO";
    CDOToken.prototype.toSource = function () { return "<!--"; };
    function CDCToken() { return this; }
    CDCToken.prototype = Object.create(CSSParserToken.prototype);
    CDCToken.prototype.tokenType = "CDC";
    CDCToken.prototype.toSource = function () { return "-->"; };
    function ColonToken() { return this; }
    ColonToken.prototype = Object.create(CSSParserToken.prototype);
    ColonToken.prototype.tokenType = ":";
    function SemicolonToken() { return this; }
    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
    SemicolonToken.prototype.tokenType = ";";
    function CommaToken() { return this; }
    CommaToken.prototype = Object.create(CSSParserToken.prototype);
    CommaToken.prototype.tokenType = ",";
    function GroupingToken() { throw "Abstract Base Class"; }
    GroupingToken.prototype = Object.create(CSSParserToken.prototype);
    function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
    OpenCurlyToken.prototype.tokenType = "{";
    function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
    CloseCurlyToken.prototype.tokenType = "}";
    function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
    OpenSquareToken.prototype.tokenType = "[";
    function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
    CloseSquareToken.prototype.tokenType = "]";
    function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
    OpenParenToken.prototype = Object.create(GroupingToken.prototype);
    OpenParenToken.prototype.tokenType = "(";
    function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
    CloseParenToken.prototype = Object.create(GroupingToken.prototype);
    CloseParenToken.prototype.tokenType = ")";
    function IncludeMatchToken() { return this; }
    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
    IncludeMatchToken.prototype.tokenType = "~=";
    function DashMatchToken() { return this; }
    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
    DashMatchToken.prototype.tokenType = "|=";
    function PrefixMatchToken() { return this; }
    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    PrefixMatchToken.prototype.tokenType = "^=";
    function SuffixMatchToken() { return this; }
    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SuffixMatchToken.prototype.tokenType = "$=";
    function SubstringMatchToken() { return this; }
    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SubstringMatchToken.prototype.tokenType = "*=";
    function ColumnToken() { return this; }
    ColumnToken.prototype = Object.create(CSSParserToken.prototype);
    ColumnToken.prototype.tokenType = "||";
    function EOFToken() { return this; }
    EOFToken.prototype = Object.create(CSSParserToken.prototype);
    EOFToken.prototype.tokenType = "EOF";
    EOFToken.prototype.toSource = function () { return ""; };
    function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
    }
    DelimToken.prototype = Object.create(CSSParserToken.prototype);
    DelimToken.prototype.tokenType = "DELIM";
    DelimToken.prototype.toString = function () { return "DELIM(" + this.value + ")"; };
    DelimToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    DelimToken.prototype.toSource = function () {
        if (this.value == "\\\\")
            return "\\\\\\n";
        else
            return this.value;
    };
    function StringValuedToken() { throw "Abstract Base Class"; }
    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
    StringValuedToken.prototype.ASCIIMatch = function (str) {
        return this.value.toLowerCase() == str.toLowerCase();
    };
    StringValuedToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    function IdentToken(val) {
        this.value = val;
    }
    IdentToken.prototype = Object.create(StringValuedToken.prototype);
    IdentToken.prototype.tokenType = "IDENT";
    IdentToken.prototype.toString = function () { return "IDENT(" + this.value + ")"; };
    IdentToken.prototype.toSource = function () {
        return escapeIdent(this.value);
    };
    function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
    }
    FunctionToken.prototype = Object.create(StringValuedToken.prototype);
    FunctionToken.prototype.tokenType = "FUNCTION";
    FunctionToken.prototype.toString = function () { return "FUNCTION(" + this.value + ")"; };
    FunctionToken.prototype.toSource = function () {
        return escapeIdent(this.value) + "(";
    };
    function AtKeywordToken(val) {
        this.value = val;
    }
    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
    AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
    AtKeywordToken.prototype.toString = function () { return "AT(" + this.value + ")"; };
    AtKeywordToken.prototype.toSource = function () {
        return "@" + escapeIdent(this.value);
    };
    function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
    }
    HashToken.prototype = Object.create(StringValuedToken.prototype);
    HashToken.prototype.tokenType = "HASH";
    HashToken.prototype.toString = function () { return "HASH(" + this.value + ")"; };
    HashToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
    };
    HashToken.prototype.toSource = function () {
        if (this.type == "id") {
            return "#" + escapeIdent(this.value);
        }
        else {
            return "#" + escapeHash(this.value);
        }
    };
    function StringToken(val) {
        this.value = val;
    }
    StringToken.prototype = Object.create(StringValuedToken.prototype);
    StringToken.prototype.tokenType = "STRING";
    StringToken.prototype.toString = function () {
        return '"' + escapeString(this.value) + '"';
    };
    function URLToken(val) {
        this.value = val;
    }
    URLToken.prototype = Object.create(StringValuedToken.prototype);
    URLToken.prototype.tokenType = "URL";
    URLToken.prototype.toString = function () { return "URL(" + this.value + ")"; };
    URLToken.prototype.toSource = function () {
        return 'url("' + escapeString(this.value) + '")';
    };
    function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
    }
    NumberToken.prototype = Object.create(CSSParserToken.prototype);
    NumberToken.prototype.tokenType = "NUMBER";
    NumberToken.prototype.toString = function () {
        if (this.type == "integer")
            return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
    };
    NumberToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
    };
    NumberToken.prototype.toSource = function () { return this.repr; };
    function PercentageToken() {
        this.value = null;
        this.repr = "";
    }
    PercentageToken.prototype = Object.create(CSSParserToken.prototype);
    PercentageToken.prototype.tokenType = "PERCENTAGE";
    PercentageToken.prototype.toString = function () { return "PERCENTAGE(" + this.value + ")"; };
    PercentageToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
    };
    PercentageToken.prototype.toSource = function () { return this.repr + "%"; };
    function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
    }
    DimensionToken.prototype = Object.create(CSSParserToken.prototype);
    DimensionToken.prototype.tokenType = "DIMENSION";
    DimensionToken.prototype.toString = function () { return "DIM(" + this.value + "," + this.unit + ")"; };
    DimensionToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
    };
    DimensionToken.prototype.toSource = function () {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
            // Unit is ambiguous with scinot
            // Remove the leading "e", replace with escape.
            unit = "\\\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
    };
    function escapeIdent(string) {
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f ||
                (i == 0 && between(code, 0x30, 0x39)) ||
                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {
                result += '\\\\' + code.toString(16) + ' ';
            }
            else if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\\\' + string[i];
            }
        }
        return result;
    }
    function escapeHash(string) {
        // Escapes the contents of "unrestricted"-type hash tokens.
        // Won't preserve the ID-ness of "id"-type hash tokens;
        // use escapeIdent() for that.
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\\\' + code.toString(16) + ' ';
            }
        }
        return result;
    }
    function escapeString(string) {
        string = '' + string;
        var result = '';
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f) {
                result += '\\\\' + code.toString(16) + ' ';
            }
            else if (code == 0x22 || code == 0x5c) {
                result += '\\\\' + string[i];
            }
            else {
                result += string[i];
            }
        }
        return result;
    }
    // Exportation.
    exports.tokenize = tokenize;
    exports.IdentToken = IdentToken;
    exports.FunctionToken = FunctionToken;
    exports.AtKeywordToken = AtKeywordToken;
    exports.HashToken = HashToken;
    exports.StringToken = StringToken;
    exports.BadStringToken = BadStringToken;
    exports.URLToken = URLToken;
    exports.BadURLToken = BadURLToken;
    exports.DelimToken = DelimToken;
    exports.NumberToken = NumberToken;
    exports.PercentageToken = PercentageToken;
    exports.DimensionToken = DimensionToken;
    exports.IncludeMatchToken = IncludeMatchToken;
    exports.DashMatchToken = DashMatchToken;
    exports.PrefixMatchToken = PrefixMatchToken;
    exports.SuffixMatchToken = SuffixMatchToken;
    exports.SubstringMatchToken = SubstringMatchToken;
    exports.ColumnToken = ColumnToken;
    exports.WhitespaceToken = WhitespaceToken;
    exports.CDOToken = CDOToken;
    exports.CDCToken = CDCToken;
    exports.ColonToken = ColonToken;
    exports.SemicolonToken = SemicolonToken;
    exports.CommaToken = CommaToken;
    exports.OpenParenToken = OpenParenToken;
    exports.CloseParenToken = CloseParenToken;
    exports.OpenSquareToken = OpenSquareToken;
    exports.CloseSquareToken = CloseSquareToken;
    exports.OpenCurlyToken = OpenCurlyToken;
    exports.CloseCurlyToken = CloseCurlyToken;
    exports.EOFToken = EOFToken;
    exports.CSSParserToken = CSSParserToken;
    exports.GroupingToken = GroupingToken;
}));


/***/ }),

/***/ "./src/server/common/selectorParser.ts":
/*!*********************************************!*\\
  !*** ./src/server/common/selectorParser.ts ***!
  \\*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSelector = exports.customCSSNames = void 0;
const cssParser_1 = __webpack_require__(/*! ./cssParser */ "./src/server/common/cssParser.ts");
exports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);
function parseSelector(selector) {
    const result = parseSelectorV1(selector);
    result.parts = result.parts.map(part => {
        if (Array.isArray(part))
            return part;
        if (part.name === 'css' || part.name === 'css:light') {
            if (part.name === 'css:light')
                part.body = ':light(' + part.body + ')';
            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);
            return parsedCSS.selector;
        }
        return part;
    });
    return {
        parts: result.parts,
        capture: result.capture,
    };
}
exports.parseSelector = parseSelector;
function parseSelectorV1(selector) {
    let index = 0;
    let quote;
    let start = 0;
    const result = { parts: [] };
    const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf('=');
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
            name = part.substring(0, eqIndex).trim();
            body = part.substring(eqIndex + 1);
        }
        else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
            name = 'text';
            body = part;
        }
        else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
            name = 'text';
            body = part;
        }
        else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {
            // If selector starts with '//' or '//' prefixed with multiple opening
            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
            // If selector starts with '..', consider xpath as well.
            name = 'xpath';
            body = part;
        }
        else {
            name = 'css';
            body = part;
        }
        let capture = false;
        if (name[0] === '*') {
            capture = true;
            name = name.substring(1);
        }
        result.parts.push({ name, body });
        if (capture) {
            if (result.capture !== undefined)
                throw new Error(\`Only one of the selectors can capture using * modifier\`);
            result.capture = result.parts.length - 1;
        }
    };
    if (!selector.includes('>>')) {
        index = selector.length;
        append();
        return result;
    }
    while (index < selector.length) {
        const c = selector[index];
        if (c === '\\\\' && index + 1 < selector.length) {
            index += 2;
        }
        else if (c === quote) {
            quote = undefined;
            index++;
        }
        else if (!quote && (c === '"' || c === '\\'' || c === '\`')) {
            quote = c;
            index++;
        }
        else if (!quote && c === '>' && selector[index + 1] === '>') {
            append();
            index += 2;
            start = index;
        }
        else {
            index++;
        }
    }
    append();
    return result;
}


/***/ }),

/***/ "./src/server/injected/selectorEvaluator.ts":
/*!**************************************************!*\\
  !*** ./src/server/injected/selectorEvaluator.ts ***!
  \\**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVisible = exports.parentElementOrShadowHost = exports.elementMatchesText = exports.elementText = exports.createRegexTextMatcher = exports.createStrictTextMatcher = exports.createLaxTextMatcher = exports.SelectorEvaluatorImpl = void 0;
const selectorParser_1 = __webpack_require__(/*! ../common/selectorParser */ "./src/server/common/selectorParser.ts");
class SelectorEvaluatorImpl {
    constructor(extraEngines) {
        this._engines = new Map();
        this._cacheQueryCSS = new Map();
        this._cacheMatches = new Map();
        this._cacheQuery = new Map();
        this._cacheMatchesSimple = new Map();
        this._cacheMatchesParents = new Map();
        this._cacheCallMatches = new Map();
        this._cacheCallQuery = new Map();
        this._cacheQuerySimple = new Map();
        this._cacheText = new Map();
        this._retainCacheCounter = 0;
        for (const [name, engine] of extraEngines)
            this._engines.set(name, engine);
        this._engines.set('not', notEngine);
        this._engines.set('is', isEngine);
        this._engines.set('where', isEngine);
        this._engines.set('has', hasEngine);
        this._engines.set('scope', scopeEngine);
        this._engines.set('light', lightEngine);
        this._engines.set('visible', visibleEngine);
        this._engines.set('text', textEngine);
        this._engines.set('text-is', textIsEngine);
        this._engines.set('text-matches', textMatchesEngine);
        this._engines.set('has-text', hasTextEngine);
        this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));
        this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));
        this._engines.set('above', createPositionEngine('above', boxAbove));
        this._engines.set('below', createPositionEngine('below', boxBelow));
        this._engines.set('near', createPositionEngine('near', boxNear));
        this._engines.set('nth-match', nthMatchEngine);
        const allNames = Array.from(this._engines.keys());
        allNames.sort();
        const parserNames = Array.from(selectorParser_1.customCSSNames).slice();
        parserNames.sort();
        if (allNames.join('|') !== parserNames.join('|'))
            throw new Error(\`Please keep customCSSNames in sync with evaluator engines: \${allNames.join('|')} vs \${parserNames.join('|')}\`);
    }
    begin() {
        ++this._retainCacheCounter;
    }
    end() {
        --this._retainCacheCounter;
        if (!this._retainCacheCounter) {
            this._cacheQueryCSS.clear();
            this._cacheMatches.clear();
            this._cacheQuery.clear();
            this._cacheMatchesSimple.clear();
            this._cacheMatchesParents.clear();
            this._cacheCallMatches.clear();
            this._cacheCallQuery.clear();
            this._cacheQuerySimple.clear();
            this._cacheText.clear();
        }
    }
    _cached(cache, main, rest, cb) {
        if (!cache.has(main))
            cache.set(main, []);
        const entries = cache.get(main);
        const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));
        if (entry)
            return entry.result;
        const result = cb();
        entries.push({ rest, result });
        return result;
    }
    _checkSelector(s) {
        const wellFormed = typeof s === 'object' && s &&
            (Array.isArray(s) || ('simples' in s) && (s.simples.length));
        if (!wellFormed)
            throw new Error(\`Malformed selector "\${s}"\`);
        return s;
    }
    matches(element, s, context) {
        const selector = this._checkSelector(s);
        this.begin();
        try {
            return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {
                if (Array.isArray(selector))
                    return this._matchesEngine(isEngine, element, selector, context);
                if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))
                    return false;
                return this._matchesParents(element, selector, selector.simples.length - 2, context);
            });
        }
        finally {
            this.end();
        }
    }
    query(context, s) {
        const selector = this._checkSelector(s);
        this.begin();
        try {
            return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {
                if (Array.isArray(selector))
                    return this._queryEngine(isEngine, context, selector);
                // query() recursively calls itself, so we set up a new map for this particular query() call.
                const previousScoreMap = this._scoreMap;
                this._scoreMap = new Map();
                let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);
                elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));
                if (this._scoreMap.size) {
                    elements.sort((a, b) => {
                        const aScore = this._scoreMap.get(a);
                        const bScore = this._scoreMap.get(b);
                        if (aScore === bScore)
                            return 0;
                        if (aScore === undefined)
                            return 1;
                        if (bScore === undefined)
                            return -1;
                        return aScore - bScore;
                    });
                }
                this._scoreMap = previousScoreMap;
                return elements;
            });
        }
        finally {
            this.end();
        }
    }
    _markScore(element, score) {
        // HACK ALERT: temporary marks an element with a score, to be used
        // for sorting at the end of the query().
        if (this._scoreMap)
            this._scoreMap.set(element, score);
    }
    _matchesSimple(element, simple, context) {
        return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {
            const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');
            if (!isPossiblyScopeClause && element === context.scope)
                return false;
            if (simple.css && !this._matchesCSS(element, simple.css))
                return false;
            for (const func of simple.functions) {
                if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))
                    return false;
            }
            return true;
        });
    }
    _querySimple(context, simple) {
        if (!simple.functions.length)
            return this._queryCSS(context, simple.css || '*');
        return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {
            let css = simple.css;
            const funcs = simple.functions;
            if (css === '*' && funcs.length)
                css = undefined;
            let elements;
            let firstIndex = -1;
            if (css !== undefined) {
                elements = this._queryCSS(context, css);
            }
            else {
                firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);
                if (firstIndex === -1)
                    firstIndex = 0;
                elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);
            }
            for (let i = 0; i < funcs.length; i++) {
                if (i === firstIndex)
                    continue;
                const engine = this._getEngine(funcs[i].name);
                if (engine.matches !== undefined)
                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));
            }
            for (let i = 0; i < funcs.length; i++) {
                if (i === firstIndex)
                    continue;
                const engine = this._getEngine(funcs[i].name);
                if (engine.matches === undefined)
                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));
            }
            return elements;
        });
    }
    _matchesParents(element, complex, index, context) {
        if (index < 0)
            return true;
        return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {
            const { selector: simple, combinator } = complex.simples[index];
            if (combinator === '>') {
                const parent = parentElementOrShadowHostInContext(element, context);
                if (!parent || !this._matchesSimple(parent, simple, context))
                    return false;
                return this._matchesParents(parent, complex, index - 1, context);
            }
            if (combinator === '+') {
                const previousSibling = previousSiblingInContext(element, context);
                if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))
                    return false;
                return this._matchesParents(previousSibling, complex, index - 1, context);
            }
            if (combinator === '') {
                let parent = parentElementOrShadowHostInContext(element, context);
                while (parent) {
                    if (this._matchesSimple(parent, simple, context)) {
                        if (this._matchesParents(parent, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '')
                            break;
                    }
                    parent = parentElementOrShadowHostInContext(parent, context);
                }
                return false;
            }
            if (combinator === '~') {
                let previousSibling = previousSiblingInContext(element, context);
                while (previousSibling) {
                    if (this._matchesSimple(previousSibling, simple, context)) {
                        if (this._matchesParents(previousSibling, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '~')
                            break;
                    }
                    previousSibling = previousSiblingInContext(previousSibling, context);
                }
                return false;
            }
            if (combinator === '>=') {
                let parent = element;
                while (parent) {
                    if (this._matchesSimple(parent, simple, context)) {
                        if (this._matchesParents(parent, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '')
                            break;
                    }
                    parent = parentElementOrShadowHostInContext(parent, context);
                }
                return false;
            }
            throw new Error(\`Unsupported combinator "\${combinator}"\`);
        });
    }
    _matchesEngine(engine, element, args, context) {
        if (engine.matches)
            return this._callMatches(engine, element, args, context);
        if (engine.query)
            return this._callQuery(engine, args, context).includes(element);
        throw new Error(\`Selector engine should implement "matches" or "query"\`);
    }
    _queryEngine(engine, context, args) {
        if (engine.query)
            return this._callQuery(engine, args, context);
        if (engine.matches)
            return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));
        throw new Error(\`Selector engine should implement "matches" or "query"\`);
    }
    _callMatches(engine, element, args, context) {
        return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {
            return engine.matches(element, args, context, this);
        });
    }
    _callQuery(engine, args, context) {
        return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {
            return engine.query(context, args, this);
        });
    }
    _matchesCSS(element, css) {
        return element.matches(css);
    }
    _queryCSS(context, css) {
        return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {
            let result = [];
            function query(root) {
                result = result.concat([...root.querySelectorAll(css)]);
                if (!context.pierceShadow)
                    return;
                if (root.shadowRoot)
                    query(root.shadowRoot);
                for (const element of root.querySelectorAll('*')) {
                    if (element.shadowRoot)
                        query(element.shadowRoot);
                }
            }
            query(context.scope);
            return result;
        });
    }
    _getEngine(name) {
        const engine = this._engines.get(name);
        if (!engine)
            throw new Error(\`Unknown selector engine "\${name}"\`);
        return engine;
    }
}
exports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;
const isEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"is" engine expects non-empty selector list\`);
        return args.some(selector => evaluator.matches(element, selector, context));
    },
    query(context, args, evaluator) {
        if (args.length === 0)
            throw new Error(\`"is" engine expects non-empty selector list\`);
        let elements = [];
        for (const arg of args)
            elements = elements.concat(evaluator.query(context, arg));
        return args.length === 1 ? elements : sortInDOMOrder(elements);
    },
};
const hasEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"has" engine expects non-empty selector list\`);
        return evaluator.query({ ...context, scope: element }, args).length > 0;
    },
};
const scopeEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 0)
            throw new Error(\`"scope" engine expects no arguments\`);
        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */)
            return element === context.scope.documentElement;
        return element === context.scope;
    },
    query(context, args, evaluator) {
        if (args.length !== 0)
            throw new Error(\`"scope" engine expects no arguments\`);
        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */) {
            const root = context.scope.documentElement;
            return root ? [root] : [];
        }
        if (context.scope.nodeType === 1 /* Node.ELEMENT_NODE */)
            return [context.scope];
        return [];
    },
};
const notEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"not" engine expects non-empty selector list\`);
        return !evaluator.matches(element, args, context);
    },
};
const lightEngine = {
    query(context, args, evaluator) {
        return evaluator.query({ ...context, pierceShadow: false }, args);
    },
    matches(element, args, context, evaluator) {
        return evaluator.matches(element, args, { ...context, pierceShadow: false });
    }
};
const visibleEngine = {
    matches(element, args, context, evaluator) {
        if (args.length)
            throw new Error(\`"visible" engine expects no arguments\`);
        return isVisible(element);
    }
};
const textEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"text" engine expects a single string\`);
        const matcher = createLaxTextMatcher(args[0]);
        return elementMatchesText(evaluator, element, matcher) === 'self';
    },
};
const textIsEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"text-is" engine expects a single string\`);
        const matcher = createStrictTextMatcher(args[0]);
        return elementMatchesText(evaluator, element, matcher) !== 'none';
    },
};
const textMatchesEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || (args.length === 2 && typeof args[1] !== 'string'))
            throw new Error(\`"text-matches" engine expects a regexp body and optional regexp flags\`);
        const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);
        return elementMatchesText(evaluator, element, matcher) === 'self';
    },
};
const hasTextEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"has-text" engine expects a single string\`);
        if (shouldSkipForTextMatching(element))
            return false;
        const matcher = createLaxTextMatcher(args[0]);
        return matcher(elementText(evaluator, element));
    },
};
function createLaxTextMatcher(text) {
    text = text.trim().replace(/\\s+/g, ' ').toLowerCase();
    return (elementText) => {
        const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();
        return s.includes(text);
    };
}
exports.createLaxTextMatcher = createLaxTextMatcher;
function createStrictTextMatcher(text) {
    text = text.trim().replace(/\\s+/g, ' ');
    return (elementText) => {
        return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);
    };
}
exports.createStrictTextMatcher = createStrictTextMatcher;
function createRegexTextMatcher(source, flags) {
    const re = new RegExp(source, flags);
    return (elementText) => {
        return re.test(elementText.full);
    };
}
exports.createRegexTextMatcher = createRegexTextMatcher;
function shouldSkipForTextMatching(element) {
    return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);
}
function elementText(evaluator, root) {
    let value = evaluator._cacheText.get(root);
    if (value === undefined) {
        value = { full: '', immediate: [] };
        if (!shouldSkipForTextMatching(root)) {
            let currentImmediate = '';
            if ((root instanceof HTMLInputElement) && (root.type === 'submit' || root.type === 'button')) {
                value = { full: root.value, immediate: [root.value] };
            }
            else {
                for (let child = root.firstChild; child; child = child.nextSibling) {
                    if (child.nodeType === Node.TEXT_NODE) {
                        value.full += child.nodeValue || '';
                        currentImmediate += child.nodeValue || '';
                    }
                    else {
                        if (currentImmediate)
                            value.immediate.push(currentImmediate);
                        currentImmediate = '';
                        if (child.nodeType === Node.ELEMENT_NODE)
                            value.full += elementText(evaluator, child).full;
                    }
                }
                if (currentImmediate)
                    value.immediate.push(currentImmediate);
                if (root.shadowRoot)
                    value.full += elementText(evaluator, root.shadowRoot).full;
            }
        }
        evaluator._cacheText.set(root, value);
    }
    return value;
}
exports.elementText = elementText;
function elementMatchesText(evaluator, element, matcher) {
    if (shouldSkipForTextMatching(element))
        return 'none';
    if (!matcher(elementText(evaluator, element)))
        return 'none';
    for (let child = element.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))
            return 'selfAndChildren';
    }
    if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))
        return 'selfAndChildren';
    return 'self';
}
exports.elementMatchesText = elementMatchesText;
function boxRightOf(box1, box2, maxDistance) {
    const distance = box1.left - box2.right;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);
}
function boxLeftOf(box1, box2, maxDistance) {
    const distance = box2.left - box1.right;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);
}
function boxAbove(box1, box2, maxDistance) {
    const distance = box2.top - box1.bottom;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);
}
function boxBelow(box1, box2, maxDistance) {
    const distance = box1.top - box2.bottom;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);
}
function boxNear(box1, box2, maxDistance) {
    const kThreshold = maxDistance === undefined ? 50 : maxDistance;
    let score = 0;
    if (box1.left - box2.right >= 0)
        score += box1.left - box2.right;
    if (box2.left - box1.right >= 0)
        score += box2.left - box1.right;
    if (box2.top - box1.bottom >= 0)
        score += box2.top - box1.bottom;
    if (box1.top - box2.bottom >= 0)
        score += box1.top - box2.bottom;
    return score > kThreshold ? undefined : score;
}
function createPositionEngine(name, scorer) {
    return {
        matches(element, args, context, evaluator) {
            const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;
            const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);
            if (args.length < 1 + (maxDistance === undefined ? 0 : 1))
                throw new Error(\`"\${name}" engine expects a selector list and optional maximum distance in pixels\`);
            const box = element.getBoundingClientRect();
            let bestScore;
            for (const e of evaluator.query(context, queryArgs)) {
                if (e === element)
                    continue;
                const score = scorer(box, e.getBoundingClientRect(), maxDistance);
                if (score === undefined)
                    continue;
                if (bestScore === undefined || score < bestScore)
                    bestScore = score;
            }
            if (bestScore === undefined)
                return false;
            evaluator._markScore(element, bestScore);
            return true;
        }
    };
}
const nthMatchEngine = {
    query(context, args, evaluator) {
        let index = args[args.length - 1];
        if (args.length < 2)
            throw new Error(\`"nth-match" engine expects non-empty selector list and an index argument\`);
        if (typeof index !== 'number' || index < 1)
            throw new Error(\`"nth-match" engine expects a one-based index as the last argument\`);
        const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);
        index--; // one-based
        return index < elements.length ? [elements[index]] : [];
    },
};
function parentElementOrShadowHost(element) {
    if (element.parentElement)
        return element.parentElement;
    if (!element.parentNode)
        return;
    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)
        return element.parentNode.host;
}
exports.parentElementOrShadowHost = parentElementOrShadowHost;
function parentElementOrShadowHostInContext(element, context) {
    if (element === context.scope)
        return;
    if (!context.pierceShadow)
        return element.parentElement || undefined;
    return parentElementOrShadowHost(element);
}
function previousSiblingInContext(element, context) {
    if (element === context.scope)
        return;
    return element.previousElementSibling || undefined;
}
function isVisible(element) {
    // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.
    if (!element.ownerDocument || !element.ownerDocument.defaultView)
        return true;
    const style = element.ownerDocument.defaultView.getComputedStyle(element);
    if (!style || style.visibility === 'hidden')
        return false;
    const rect = element.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0;
}
exports.isVisible = isVisible;
function sortInDOMOrder(elements) {
    const elementToEntry = new Map();
    const roots = [];
    const result = [];
    function append(element) {
        let entry = elementToEntry.get(element);
        if (entry)
            return entry;
        const parent = parentElementOrShadowHost(element);
        if (parent) {
            const parentEntry = append(parent);
            parentEntry.children.push(element);
        }
        else {
            roots.push(element);
        }
        entry = { children: [], taken: false };
        elementToEntry.set(element, entry);
        return entry;
    }
    elements.forEach(e => append(e).taken = true);
    function visit(element) {
        const entry = elementToEntry.get(element);
        if (entry.taken)
            result.push(element);
        if (entry.children.length > 1) {
            const set = new Set(entry.children);
            entry.children = [];
            let child = element.firstElementChild;
            while (child && entry.children.length < set.size) {
                if (set.has(child))
                    entry.children.push(child);
                child = child.nextElementSibling;
            }
            child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;
            while (child && entry.children.length < set.size) {
                if (set.has(child))
                    entry.children.push(child);
                child = child.nextElementSibling;
            }
        }
        entry.children.forEach(visit);
    }
    roots.forEach(visit);
    return result;
}


/***/ }),

/***/ "./src/server/supplements/injected/recorder.ts":
/*!*****************************************************!*\\
  !*** ./src/server/supplements/injected/recorder.ts ***!
  \\*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Recorder = void 0;
const selectorGenerator_1 = __webpack_require__(/*! ./selectorGenerator */ "./src/server/supplements/injected/selectorGenerator.ts");
const scriptSymbol = Symbol('scriptSymbol');
class Recorder {
    constructor(injectedScript, params) {
        this._performingAction = false;
        this._highlightElements = [];
        this._listeners = [];
        this._hoveredModel = null;
        this._hoveredElement = null;
        this._activeModel = null;
        this._expectProgrammaticKeyUp = false;
        this._mode = 'none';
        this._params = params;
        this._injectedScript = injectedScript;
        this._outerGlassPaneElement = document.createElement('x-pw-glass');
        this._outerGlassPaneElement.style.position = 'fixed';
        this._outerGlassPaneElement.style.top = '0';
        this._outerGlassPaneElement.style.right = '0';
        this._outerGlassPaneElement.style.bottom = '0';
        this._outerGlassPaneElement.style.left = '0';
        this._outerGlassPaneElement.style.zIndex = '2147483647';
        this._outerGlassPaneElement.style.pointerEvents = 'none';
        this._outerGlassPaneElement.style.display = 'flex';
        this._snapshotBaseUrl = params.snapshotBaseUrl;
        this._tooltipElement = document.createElement('x-pw-tooltip');
        this._actionPointElement = document.createElement('x-pw-action-point');
        this._actionPointElement.setAttribute('hidden', 'true');
        this._innerGlassPaneElement = document.createElement('x-pw-glass-inner');
        this._innerGlassPaneElement.style.flex = 'auto';
        this._innerGlassPaneElement.appendChild(this._tooltipElement);
        // Use a closed shadow root to prevent selectors matching our internal previews.
        this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({ mode: this._params.isUnderTest ? 'open' : 'closed' });
        this._glassPaneShadow.appendChild(this._innerGlassPaneElement);
        this._glassPaneShadow.appendChild(this._actionPointElement);
        const styleElement = document.createElement('style');
        styleElement.textContent = \`
        x-pw-tooltip {
          align-items: center;
          backdrop-filter: blur(5px);
          background-color: rgba(0, 0, 0, 0.7);
          border-radius: 2px;
          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,
                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,
                      rgba(0, 0, 0, 0.1) 0px -2px 4px,
                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,
                      rgba(0, 0, 0, 0.25) 0px 54px 55px;
          color: rgb(204, 204, 204);
          display: none;
          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',
                       'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;
          font-size: 12.8px;
          font-weight: normal;
          left: 0;
          line-height: 1.5;
          max-width: 600px;
          padding: 3.2px 5.12px 3.2px;
          position: absolute;
          top: 0;
        }
        x-pw-action-point {
          position: absolute;
          width: 20px;
          height: 20px;
          background: red;
          border-radius: 10px;
          pointer-events: none;
          margin: -10px 0 0 -10px;
          z-index: 2;
        }
        *[hidden] {
          display: none !important;
        }
    \`;
        this._glassPaneShadow.appendChild(styleElement);
        this._refreshListenersIfNeeded();
        setInterval(() => {
            this._refreshListenersIfNeeded();
            if (window._recorderScriptReadyForTest) {
                window._recorderScriptReadyForTest();
                delete window._recorderScriptReadyForTest;
            }
        }, 500);
        window._playwrightRefreshOverlay = () => {
            this._pollRecorderMode().catch(e => console.log(e)); // eslint-disable-line no-console
        };
        window._playwrightRefreshOverlay();
    }
    _refreshListenersIfNeeded() {
        if (document.documentElement[scriptSymbol])
            return;
        document.documentElement[scriptSymbol] = true;
        removeEventListeners(this._listeners);
        this._listeners = [
            addEventListener(document, 'click', event => this._onClick(event), true),
            addEventListener(document, 'input', event => this._onInput(event), true),
            addEventListener(document, 'keydown', event => this._onKeyDown(event), true),
            addEventListener(document, 'keyup', event => this._onKeyUp(event), true),
            addEventListener(document, 'mousedown', event => this._onMouseDown(event), true),
            addEventListener(document, 'mouseup', event => this._onMouseUp(event), true),
            addEventListener(document, 'mousemove', event => this._onMouseMove(event), true),
            addEventListener(document, 'mouseleave', event => this._onMouseLeave(event), true),
            addEventListener(document, 'focus', () => this._onFocus(), true),
            addEventListener(document, 'scroll', () => {
                this._hoveredModel = null;
                this._actionPointElement.hidden = true;
                this._updateHighlight();
            }, true),
        ];
        document.documentElement.appendChild(this._outerGlassPaneElement);
    }
    _createSnapshotIframeIfNeeded() {
        if (this._snapshotIframe)
            return this._snapshotIframe;
        if (window.top === window) {
            this._snapshotIframe = document.createElement('iframe');
            this._snapshotIframe.src = this._snapshotBaseUrl;
            this._snapshotIframe.style.background = '#ff000060';
            this._snapshotIframe.style.position = 'fixed';
            this._snapshotIframe.style.top = '0';
            this._snapshotIframe.style.right = '0';
            this._snapshotIframe.style.bottom = '0';
            this._snapshotIframe.style.left = '0';
            this._snapshotIframe.style.border = 'none';
            this._snapshotIframe.style.width = '100%';
            this._snapshotIframe.style.height = '100%';
            this._snapshotIframe.style.zIndex = '2147483647';
            this._snapshotIframe.style.visibility = 'hidden';
            document.documentElement.appendChild(this._snapshotIframe);
        }
        return this._snapshotIframe;
    }
    async _pollRecorderMode() {
        var _a, _b;
        const pollPeriod = 1000;
        if (this._pollRecorderModeTimer)
            clearTimeout(this._pollRecorderModeTimer);
        const state = await window._playwrightRecorderState().catch(e => null);
        if (!state) {
            this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);
            return;
        }
        const { mode, actionPoint, actionSelector, snapshotUrl } = state;
        if (mode !== this._mode) {
            this._mode = mode;
            this._clearHighlight();
        }
        if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {
            // All good.
        }
        else if (!actionPoint && !this._actionPoint) {
            // All good.
        }
        else {
            if (actionPoint) {
                this._actionPointElement.style.top = actionPoint.y + 'px';
                this._actionPointElement.style.left = actionPoint.x + 'px';
                this._actionPointElement.hidden = false;
            }
            else {
                this._actionPointElement.hidden = true;
            }
            this._actionPoint = actionPoint;
        }
        // Race or scroll.
        if (this._actionSelector && !((_a = this._hoveredModel) === null || _a === void 0 ? void 0 : _a.elements.length))
            this._actionSelector = undefined;
        if (actionSelector !== this._actionSelector) {
            this._hoveredModel = actionSelector ? selectorGenerator_1.querySelector(this._injectedScript, actionSelector, document) : null;
            this._updateHighlight();
            this._actionSelector = actionSelector;
        }
        if (snapshotUrl !== this._snapshotUrl) {
            this._snapshotUrl = snapshotUrl;
            const snapshotIframe = this._createSnapshotIframeIfNeeded();
            if (snapshotIframe) {
                if (!snapshotUrl) {
                    snapshotIframe.style.visibility = 'hidden';
                }
                else {
                    snapshotIframe.style.visibility = 'visible';
                    (_b = snapshotIframe.contentWindow) === null || _b === void 0 ? void 0 : _b.postMessage({ snapshotUrl }, '*');
                }
            }
        }
        this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);
    }
    _clearHighlight() {
        this._hoveredModel = null;
        this._activeModel = null;
        this._updateHighlight();
    }
    _actionInProgress(event) {
        // If Playwright is performing action for us, bail.
        if (this._performingAction)
            return true;
        // Consume as the first thing.
        consumeEvent(event);
        return false;
    }
    _consumedDueToNoModel(event, model) {
        if (model)
            return false;
        consumeEvent(event);
        return true;
    }
    _consumedDueWrongTarget(event) {
        if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event))
            return false;
        consumeEvent(event);
        return true;
    }
    _onClick(event) {
        if (this._mode === 'inspecting')
            window._playwrightRecorderSetSelector(this._hoveredModel ? this._hoveredModel.selector : '');
        if (this._shouldIgnoreMouseEvent(event))
            return;
        if (this._actionInProgress(event))
            return;
        if (this._consumedDueToNoModel(event, this._hoveredModel))
            return;
        const checkbox = asCheckbox(this._deepEventTarget(event));
        if (checkbox) {
            // Interestingly, inputElement.checked is reversed inside this event handler.
            this._performAction({
                name: checkbox.checked ? 'check' : 'uncheck',
                selector: this._hoveredModel.selector,
                signals: [],
            });
            return;
        }
        this._performAction({
            name: 'click',
            selector: this._hoveredModel.selector,
            signals: [],
            button: buttonForEvent(event),
            modifiers: modifiersForEvent(event),
            clickCount: event.detail
        });
    }
    _shouldIgnoreMouseEvent(event) {
        const target = this._deepEventTarget(event);
        if (this._mode === 'none')
            return true;
        if (this._mode === 'inspecting') {
            consumeEvent(event);
            return true;
        }
        const nodeName = target.nodeName;
        if (nodeName === 'SELECT')
            return true;
        if (nodeName === 'INPUT' && ['date'].includes(target.type))
            return true;
        return false;
    }
    _onMouseDown(event) {
        if (this._shouldIgnoreMouseEvent(event))
            return;
        if (!this._performingAction)
            consumeEvent(event);
        this._activeModel = this._hoveredModel;
    }
    _onMouseUp(event) {
        if (this._shouldIgnoreMouseEvent(event))
            return;
        if (!this._performingAction)
            consumeEvent(event);
    }
    _onMouseMove(event) {
        if (this._mode === 'none')
            return;
        const target = this._deepEventTarget(event);
        if (this._hoveredElement === target)
            return;
        this._hoveredElement = target;
        this._updateModelForHoveredElement();
    }
    _onMouseLeave(event) {
        // Leaving iframe.
        if (this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {
            this._hoveredElement = null;
            this._updateModelForHoveredElement();
        }
    }
    _onFocus() {
        const activeElement = this._deepActiveElement(document);
        const result = activeElement ? selectorGenerator_1.generateSelector(this._injectedScript, activeElement) : null;
        this._activeModel = result && result.selector ? result : null;
        if (window._highlightUpdatedForTest)
            window._highlightUpdatedForTest(result ? result.selector : null);
    }
    _updateModelForHoveredElement() {
        if (!this._hoveredElement) {
            this._hoveredModel = null;
            this._updateHighlight();
            return;
        }
        const hoveredElement = this._hoveredElement;
        const { selector, elements } = selectorGenerator_1.generateSelector(this._injectedScript, hoveredElement);
        if ((this._hoveredModel && this._hoveredModel.selector === selector) || this._hoveredElement !== hoveredElement)
            return;
        this._hoveredModel = selector ? { selector, elements } : null;
        this._updateHighlight();
        if (window._highlightUpdatedForTest)
            window._highlightUpdatedForTest(selector);
    }
    _updateHighlight() {
        const elements = this._hoveredModel ? this._hoveredModel.elements : [];
        // Code below should trigger one layout and leave with the
        // destroyed layout.
        // Destroy the layout
        this._tooltipElement.textContent = this._hoveredModel ? this._hoveredModel.selector : '';
        this._tooltipElement.style.top = '0';
        this._tooltipElement.style.left = '0';
        this._tooltipElement.style.display = 'flex';
        // Trigger layout.
        const boxes = elements.map(e => e.getBoundingClientRect());
        const tooltipWidth = this._tooltipElement.offsetWidth;
        const tooltipHeight = this._tooltipElement.offsetHeight;
        const totalWidth = this._innerGlassPaneElement.offsetWidth;
        const totalHeight = this._innerGlassPaneElement.offsetHeight;
        // Destroy the layout again.
        if (boxes.length) {
            const primaryBox = boxes[0];
            let anchorLeft = primaryBox.left;
            if (anchorLeft + tooltipWidth > totalWidth - 5)
                anchorLeft = totalWidth - tooltipWidth - 5;
            let anchorTop = primaryBox.bottom + 5;
            if (anchorTop + tooltipHeight > totalHeight - 5) {
                // If can't fit below, either position above...
                if (primaryBox.top > tooltipHeight + 5) {
                    anchorTop = primaryBox.top - tooltipHeight - 5;
                }
                else {
                    // Or on top in case of large element
                    anchorTop = totalHeight - 5 - tooltipHeight;
                }
            }
            this._tooltipElement.style.top = anchorTop + 'px';
            this._tooltipElement.style.left = anchorLeft + 'px';
        }
        else {
            this._tooltipElement.style.display = 'none';
        }
        const pool = this._highlightElements;
        this._highlightElements = [];
        for (const box of boxes) {
            const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();
            const color = this._mode === 'recording' ? '#dc6f6f7f' : '#6fa8dc7f';
            highlightElement.style.backgroundColor = this._highlightElements.length ? '#f6b26b7f' : color;
            highlightElement.style.left = box.x + 'px';
            highlightElement.style.top = box.y + 'px';
            highlightElement.style.width = box.width + 'px';
            highlightElement.style.height = box.height + 'px';
            highlightElement.style.display = 'block';
            this._highlightElements.push(highlightElement);
        }
        for (const highlightElement of pool) {
            highlightElement.style.display = 'none';
            this._highlightElements.push(highlightElement);
        }
    }
    _createHighlightElement() {
        const highlightElement = document.createElement('x-pw-highlight');
        highlightElement.style.position = 'absolute';
        highlightElement.style.top = '0';
        highlightElement.style.left = '0';
        highlightElement.style.width = '0';
        highlightElement.style.height = '0';
        highlightElement.style.boxSizing = 'border-box';
        this._glassPaneShadow.appendChild(highlightElement);
        return highlightElement;
    }
    _onInput(event) {
        if (this._mode !== 'recording')
            return true;
        const target = this._deepEventTarget(event);
        if (['INPUT', 'TEXTAREA'].includes(target.nodeName)) {
            const inputElement = target;
            const elementType = (inputElement.type || '').toLowerCase();
            if (elementType === 'checkbox') {
                // Checkbox is handled in click, we can't let input trigger on checkbox - that would mean we dispatched click events while recording.
                return;
            }
            if (elementType === 'file') {
                window._playwrightRecorderRecordAction({
                    name: 'setInputFiles',
                    selector: this._activeModel.selector,
                    signals: [],
                    files: [...(inputElement.files || [])].map(file => file.name),
                });
                return;
            }
            // Non-navigating actions are simply recorded by Playwright.
            if (this._consumedDueWrongTarget(event))
                return;
            window._playwrightRecorderRecordAction({
                name: 'fill',
                selector: this._activeModel.selector,
                signals: [],
                text: inputElement.value,
            });
        }
        if (target.nodeName === 'SELECT') {
            const selectElement = target;
            if (this._actionInProgress(event))
                return;
            this._performAction({
                name: 'select',
                selector: this._hoveredModel.selector,
                options: [...selectElement.selectedOptions].map(option => option.value),
                signals: []
            });
        }
    }
    _shouldGenerateKeyPressFor(event) {
        // Backspace, Delete, AltGraph are changing input, will handle it there.
        if (['Backspace', 'Delete', 'AltGraph'].includes(event.key))
            return false;
        // Ignore the QWERTZ shortcut for creating a at sign on MacOS
        if (event.key === '@' && event.code === 'KeyL')
            return false;
        // Allow and ignore common used shortcut for pasting.
        if (navigator.platform.includes('Mac')) {
            if (event.key === 'v' && event.metaKey)
                return false;
        }
        else {
            if (event.key === 'v' && event.ctrlKey)
                return false;
            if (event.key === 'Insert' && event.shiftKey)
                return false;
        }
        if (['Shift', 'Control', 'Meta', 'Alt'].includes(event.key))
            return false;
        const hasModifier = event.ctrlKey || event.altKey || event.metaKey;
        if (event.key.length === 1 && !hasModifier)
            return !!asCheckbox(this._deepEventTarget(event));
        return true;
    }
    _onKeyDown(event) {
        if (this._mode === 'inspecting') {
            consumeEvent(event);
            return;
        }
        if (this._mode !== 'recording')
            return true;
        if (!this._shouldGenerateKeyPressFor(event))
            return;
        if (this._actionInProgress(event)) {
            this._expectProgrammaticKeyUp = true;
            return;
        }
        if (this._consumedDueWrongTarget(event))
            return;
        // Similarly to click, trigger checkbox on key event, not input.
        if (event.key === ' ') {
            const checkbox = asCheckbox(this._deepEventTarget(event));
            if (checkbox) {
                this._performAction({
                    name: checkbox.checked ? 'uncheck' : 'check',
                    selector: this._activeModel.selector,
                    signals: [],
                });
                return;
            }
        }
        this._performAction({
            name: 'press',
            selector: this._activeModel.selector,
            signals: [],
            key: event.key,
            modifiers: modifiersForEvent(event),
        });
    }
    _onKeyUp(event) {
        if (!this._shouldGenerateKeyPressFor(event))
            return;
        // Only allow programmatic keyups, ignore user input.
        if (!this._expectProgrammaticKeyUp) {
            consumeEvent(event);
            return;
        }
        this._expectProgrammaticKeyUp = false;
    }
    async _performAction(action) {
        this._performingAction = true;
        await window._playwrightRecorderPerformAction(action).catch(() => { });
        this._performingAction = false;
        // Action could have changed DOM, update hovered model selectors.
        this._updateModelForHoveredElement();
        // If that was a keyboard action, it similarly requires new selectors for active model.
        this._onFocus();
        if (window._actionPerformedForTest) {
            window._actionPerformedForTest({
                hovered: this._hoveredModel ? this._hoveredModel.selector : null,
                active: this._activeModel ? this._activeModel.selector : null,
            });
        }
    }
    _deepEventTarget(event) {
        return event.composedPath()[0];
    }
    _deepActiveElement(document) {
        let activeElement = document.activeElement;
        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
            activeElement = activeElement.shadowRoot.activeElement;
        return activeElement;
    }
}
exports.Recorder = Recorder;
function modifiersForEvent(event) {
    return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);
}
function buttonForEvent(event) {
    switch (event.which) {
        case 1: return 'left';
        case 2: return 'middle';
        case 3: return 'right';
    }
    return 'left';
}
function consumeEvent(e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
}
function asCheckbox(node) {
    if (!node || node.nodeName !== 'INPUT')
        return null;
    const inputElement = node;
    return inputElement.type === 'checkbox' ? inputElement : null;
}
function addEventListener(target, eventName, listener, useCapture) {
    target.addEventListener(eventName, listener, useCapture);
    const remove = () => {
        target.removeEventListener(eventName, listener, useCapture);
    };
    return remove;
}
function removeEventListeners(listeners) {
    for (const listener of listeners)
        listener();
    listeners.splice(0, listeners.length);
}
exports.default = Recorder;


/***/ }),

/***/ "./src/server/supplements/injected/selectorGenerator.ts":
/*!**************************************************************!*\\
  !*** ./src/server/supplements/injected/selectorGenerator.ts ***!
  \\**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSelector = exports.querySelector = void 0;
const selectorEvaluator_1 = __webpack_require__(/*! ../../injected/selectorEvaluator */ "./src/server/injected/selectorEvaluator.ts");
const cacheAllowText = new Map();
const cacheDisallowText = new Map();
function querySelector(injectedScript, selector, ownerDocument) {
    try {
        const parsedSelector = injectedScript.parseSelector(selector);
        return {
            selector,
            elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)
        };
    }
    catch (e) {
        return {
            selector,
            elements: [],
        };
    }
}
exports.querySelector = querySelector;
function generateSelector(injectedScript, targetElement) {
    injectedScript._evaluator.begin();
    try {
        targetElement = targetElement.closest('button,select,input,[role=button],[role=checkbox],[role=radio]') || targetElement;
        const targetTokens = generateSelectorFor(injectedScript, targetElement);
        const bestTokens = targetTokens || [cssFallback(injectedScript, targetElement)];
        const selector = joinTokens(bestTokens);
        const parsedSelector = injectedScript.parseSelector(selector);
        return {
            selector,
            elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)
        };
    }
    finally {
        cacheAllowText.clear();
        cacheDisallowText.clear();
        injectedScript._evaluator.end();
    }
}
exports.generateSelector = generateSelector;
function filterRegexTokens(textCandidates) {
    // Filter out regex-based selectors for better performance.
    return textCandidates.filter(c => c[0].selector[0] !== '/');
}
function generateSelectorFor(injectedScript, targetElement) {
    if (targetElement.ownerDocument.documentElement === targetElement)
        return [{ engine: 'css', selector: 'html', score: 1 }];
    const calculate = (element, allowText) => {
        const allowNthMatch = element === targetElement;
        let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map(token => [token]) : [];
        if (element !== targetElement) {
            // Do not use regex for parent elements (for performance).
            textCandidates = filterRegexTokens(textCandidates);
        }
        const noTextCandidates = buildCandidates(injectedScript, element).map(token => [token]);
        // First check all text and non-text candidates for the element.
        let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);
        // Do not use regex for chained selectors (for performance).
        textCandidates = filterRegexTokens(textCandidates);
        const checkWithText = (textCandidatesToUse) => {
            // Use the deepest possible text selector - works pretty good and saves on compute time.
            const allowParentText = allowText && !textCandidatesToUse.length;
            const candidates = [...textCandidatesToUse, ...noTextCandidates].filter(c => {
                if (!result)
                    return true;
                return combineScores(c) < combineScores(result);
            });
            // This is best theoretically possible candidate from the current parent.
            // We use the fact that widening the scope to grand-parent makes any selector
            // even less likely to match.
            let bestPossibleInParent = candidates[0];
            if (!bestPossibleInParent)
                return;
            for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {
                const parentTokens = calculateCached(parent, allowParentText);
                if (!parentTokens)
                    continue;
                // Even the best selector won't be too good - skip this parent.
                if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))
                    continue;
                // Update the best candidate that finds "element" in the "parent".
                bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);
                if (!bestPossibleInParent)
                    return;
                const combined = [...parentTokens, ...bestPossibleInParent];
                if (!result || combineScores(combined) < combineScores(result))
                    result = combined;
            }
        };
        checkWithText(textCandidates);
        // Allow skipping text on the target element, and using text on one of the parents.
        if (element === targetElement && textCandidates.length)
            checkWithText([]);
        return result;
    };
    const calculateCached = (element, allowText) => {
        const cache = allowText ? cacheAllowText : cacheDisallowText;
        let value = cache.get(element);
        if (value === undefined) {
            value = calculate(element, allowText);
            cache.set(element, value);
        }
        return value;
    };
    return calculateCached(targetElement, true);
}
function buildCandidates(injectedScript, element) {
    const candidates = [];
    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {
        if (element.hasAttribute(attribute))
            candidates.push({ engine: 'css', selector: \`[\${attribute}=\${quoteString(element.getAttribute(attribute))}]\`, score: 1 });
    }
    if (element.nodeName === 'INPUT') {
        const input = element;
        if (input.placeholder)
            candidates.push({ engine: 'css', selector: \`[placeholder=\${quoteString(input.placeholder)}]\`, score: 10 });
    }
    if (element.hasAttribute('aria-label'))
        candidates.push({ engine: 'css', selector: \`[aria-label=\${quoteString(element.getAttribute('aria-label'))}]\`, score: 10 });
    if (element.getAttribute('alt') && ['APPLET', 'AREA', 'IMG', 'INPUT'].includes(element.nodeName))
        candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLowerCase()}[alt=\${quoteString(element.getAttribute('alt'))}]\`, score: 10 });
    if (element.hasAttribute('role'))
        candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLocaleLowerCase()}[role=\${quoteString(element.getAttribute('role'))}]\`, score: 50 });
    if (element.getAttribute('name') && ['BUTTON', 'FORM', 'FIELDSET', 'IFRAME', 'INPUT', 'KEYGEN', 'OBJECT', 'OUTPUT', 'SELECT', 'TEXTAREA', 'MAP', 'META', 'PARAM'].includes(element.nodeName))
        candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLowerCase()}[name=\${quoteString(element.getAttribute('name'))}]\`, score: 50 });
    if (['INPUT', 'TEXTAREA'].includes(element.nodeName) && element.getAttribute('type') !== 'hidden') {
        if (element.getAttribute('type'))
            candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLowerCase()}[type=\${quoteString(element.getAttribute('type'))}]\`, score: 50 });
    }
    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName))
        candidates.push({ engine: 'css', selector: element.nodeName.toLowerCase(), score: 50 });
    const idAttr = element.getAttribute('id');
    if (idAttr && !isGuidLike(idAttr))
        candidates.push({ engine: 'css', selector: makeSelectorForId(idAttr), score: 100 });
    candidates.push({ engine: 'css', selector: element.nodeName.toLocaleLowerCase(), score: 200 });
    return candidates;
}
function buildTextCandidates(injectedScript, element, allowHasText) {
    if (element.nodeName === 'SELECT')
        return [];
    const text = selectorEvaluator_1.elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, ' ').substring(0, 80);
    if (!text)
        return [];
    const candidates = [];
    let escaped = text;
    if (text.includes('"') || text.includes('>>') || text[0] === '/')
        escaped = \`/.*\${escapeForRegex(text)}.*/\`;
    candidates.push({ engine: 'text', selector: escaped, score: 10 });
    if (allowHasText && escaped === text) {
        let prefix = element.nodeName.toLocaleLowerCase();
        if (element.hasAttribute('role'))
            prefix += \`[role=\${quoteString(element.getAttribute('role'))}]\`;
        candidates.push({ engine: 'css', selector: \`\${prefix}:has-text("\${text}")\`, score: 30 });
    }
    return candidates;
}
function parentElementOrShadowHost(element) {
    if (element.parentElement)
        return element.parentElement;
    if (!element.parentNode)
        return null;
    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)
        return element.parentNode.host;
    return null;
}
function makeSelectorForId(id) {
    return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? '#' + id : \`[id="\${id}"]\`;
}
function cssFallback(injectedScript, targetElement) {
    const kFallbackScore = 10000000;
    const root = targetElement.ownerDocument;
    const tokens = [];
    function uniqueCSSSelector(prefix) {
        const path = tokens.slice();
        if (prefix)
            path.unshift(prefix);
        const selector = path.join(' ');
        const parsedSelector = injectedScript.parseSelector(selector);
        const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);
        return node === targetElement ? selector : undefined;
    }
    for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {
        const nodeName = element.nodeName.toLowerCase();
        // Element ID is the strongest signal, use it.
        let bestTokenForLevel = '';
        if (element.id) {
            const token = makeSelectorForId(element.id);
            const selector = uniqueCSSSelector(token);
            if (selector)
                return { engine: 'css', selector, score: kFallbackScore };
            bestTokenForLevel = token;
        }
        const parent = element.parentNode;
        // Combine class names until unique.
        const classes = Array.from(element.classList);
        for (let i = 0; i < classes.length; ++i) {
            const token = '.' + classes.slice(0, i + 1).join('.');
            const selector = uniqueCSSSelector(token);
            if (selector)
                return { engine: 'css', selector, score: kFallbackScore };
            // Even if not unique, does this subset of classes uniquely identify node as a child?
            if (!bestTokenForLevel && parent) {
                const sameClassSiblings = parent.querySelectorAll(token);
                if (sameClassSiblings.length === 1)
                    bestTokenForLevel = token;
            }
        }
        // Ordinal is the weakest signal.
        if (parent) {
            const siblings = Array.from(parent.children);
            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);
            const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : \`\${nodeName}:nth-child(\${1 + siblings.indexOf(element)})\`;
            const selector = uniqueCSSSelector(token);
            if (selector)
                return { engine: 'css', selector, score: kFallbackScore };
            if (!bestTokenForLevel)
                bestTokenForLevel = token;
        }
        else if (!bestTokenForLevel) {
            bestTokenForLevel = nodeName;
        }
        tokens.unshift(bestTokenForLevel);
    }
    return { engine: 'css', selector: uniqueCSSSelector(), score: kFallbackScore };
}
function escapeForRegex(text) {
    return text.replace(/[.*+?^>\${}()|[\\]\\\\]/g, '\\\\$&');
}
function quoteString(text) {
    return \`"\${text.replaceAll(/"/g, '\\\\"').replaceAll(/\\n/g, '\\\\n')}"\`;
}
function joinTokens(tokens) {
    const parts = [];
    let lastEngine = '';
    for (const { engine, selector } of tokens) {
        if (parts.length && (lastEngine !== 'css' || engine !== 'css' || selector.startsWith(':nth-match(')))
            parts.push('>>');
        lastEngine = engine;
        if (engine === 'css')
            parts.push(selector);
        else
            parts.push(\`\${engine}=\${selector}\`);
    }
    return parts.join(' ');
}
function combineScores(tokens) {
    let score = 0;
    for (let i = 0; i < tokens.length; i++)
        score += tokens[i].score * (tokens.length - i);
    return score;
}
function chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {
    const joined = selectors.map(tokens => ({ tokens, score: combineScores(tokens) }));
    joined.sort((a, b) => a.score - b.score);
    let bestWithIndex = null;
    for (const { tokens } of joined) {
        const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));
        const result = injectedScript.querySelectorAll(parsedSelector, scope);
        const index = result.indexOf(targetElement);
        if (index === 0) {
            // We are the first match - found the best selector.
            return tokens;
        }
        // Otherwise, perhaps we can get nth-match?
        if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)
            continue;
        // To use nth-match, we must convert everything to css.
        const allCss = tokens.map(token => {
            if (token.engine !== 'text')
                return token;
            if (token.selector.startsWith('/') && token.selector.endsWith('/'))
                return { engine: 'css', selector: \`:text-matches("\${token.selector.substring(1, token.selector.length - 1)}")\`, score: token.score };
            return { engine: 'css', selector: \`:text("\${token.selector}")\`, score: token.score };
        });
        const combined = joinTokens(allCss);
        bestWithIndex = [{ engine: 'css', selector: \`:nth-match(\${combined}, \${index + 1})\`, score: combineScores(allCss) + 1000 }];
    }
    return bestWithIndex;
}
function isGuidLike(id) {
    let lastCharacterType;
    let transitionCount = 0;
    for (let i = 0; i < id.length; ++i) {
        const c = id[i];
        let characterType;
        if (c === '-' || c === '_')
            continue;
        if (c >= 'a' && c <= 'z')
            characterType = 'lower';
        else if (c >= 'A' && c <= 'Z')
            characterType = 'upper';
        else if (c >= '0' && c <= '9')
            characterType = 'digit';
        else
            characterType = 'other';
        if (characterType === 'lower' && lastCharacterType === 'upper') {
            lastCharacterType = characterType;
            continue;
        }
        if (lastCharacterType && lastCharacterType !== characterType)
            ++transitionCount;
        lastCharacterType = characterType;
    }
    return transitionCount >= id.length / 4;
}


/***/ })

/******/ })["default"];`;
  }
});

// node_modules/playwright/lib/generated/consoleApiSource.js
var require_consoleApiSource = __commonJS({
  "node_modules/playwright/lib/generated/consoleApiSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.source = void 0;
    exports2.source = `var pwExport =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/supplements/injected/consoleApi.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/server/common/cssParser.ts":
/*!****************************************!*\\
  !*** ./src/server/common/cssParser.ts ***!
  \\****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeSelector = exports.parseCSS = void 0;
const css = __importStar(__webpack_require__(/*! ./cssTokenizer */ "./src/server/common/cssTokenizer.js"));
function parseCSS(selector, customNames) {
    let tokens;
    try {
        tokens = css.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))
            tokens.push(new css.EOFToken());
    }
    catch (e) {
        const newMessage = e.message + \` while parsing selector "\${selector}"\`;
        const index = (e.stack || '').indexOf(e.message);
        if (index !== -1)
            e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
    }
    const unsupportedToken = tokens.find(token => {
        return (token instanceof css.AtKeywordToken) ||
            (token instanceof css.BadStringToken) ||
            (token instanceof css.BadURLToken) ||
            (token instanceof css.ColumnToken) ||
            (token instanceof css.CDOToken) ||
            (token instanceof css.CDCToken) ||
            (token instanceof css.SemicolonToken) ||
            // TODO: Consider using these for something, e.g. to escape complex strings.
            // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }
            // Or this way :xpath( {complex-xpath-goes-here("hello")} )
            (token instanceof css.OpenCurlyToken) ||
            (token instanceof css.CloseCurlyToken) ||
            // TODO: Consider treating these as strings?
            (token instanceof css.URLToken) ||
            (token instanceof css.PercentageToken);
    });
    if (unsupportedToken)
        throw new Error(\`Unsupported token "\${unsupportedToken.toSource()}" while parsing selector "\${selector}"\`);
    let pos = 0;
    const names = new Set();
    function unexpected() {
        return new Error(\`Unexpected token "\${tokens[pos].toSource()}" while parsing selector "\${selector}"\`);
    }
    function skipWhitespace() {
        while (tokens[pos] instanceof css.WhitespaceToken)
            pos++;
    }
    function isIdent(p = pos) {
        return tokens[p] instanceof css.IdentToken;
    }
    function isString(p = pos) {
        return tokens[p] instanceof css.StringToken;
    }
    function isNumber(p = pos) {
        return tokens[p] instanceof css.NumberToken;
    }
    function isComma(p = pos) {
        return tokens[p] instanceof css.CommaToken;
    }
    function isCloseParen(p = pos) {
        return tokens[p] instanceof css.CloseParenToken;
    }
    function isStar(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && tokens[p].value === '*';
    }
    function isEOF(p = pos) {
        return tokens[p] instanceof css.EOFToken;
    }
    function isClauseCombinator(p = pos) {
        return (tokens[p] instanceof css.DelimToken) && (['>', '+', '~'].includes(tokens[p].value));
    }
    function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || (tokens[p] instanceof css.WhitespaceToken);
    }
    function consumeFunctionArguments() {
        const result = [consumeArgument()];
        while (true) {
            skipWhitespace();
            if (!isComma())
                break;
            pos++;
            result.push(consumeArgument());
        }
        return result;
    }
    function consumeArgument() {
        skipWhitespace();
        if (isNumber())
            return tokens[pos++].value;
        if (isString())
            return tokens[pos++].value;
        return consumeComplexSelector();
    }
    function consumeComplexSelector() {
        skipWhitespace();
        const result = { simples: [{ selector: consumeSimpleSelector(), combinator: '' }] };
        while (true) {
            skipWhitespace();
            if (isClauseCombinator()) {
                result.simples[result.simples.length - 1].combinator = tokens[pos++].value;
                skipWhitespace();
            }
            else if (isSelectorClauseEnd()) {
                break;
            }
            result.simples.push({ combinator: '', selector: consumeSimpleSelector() });
        }
        return result;
    }
    function consumeSimpleSelector() {
        let rawCSSString = '';
        const functions = [];
        while (!isSelectorClauseEnd()) {
            if (isIdent() || isStar()) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if (tokens[pos] instanceof css.HashToken) {
                rawCSSString += tokens[pos++].toSource();
            }
            else if ((tokens[pos] instanceof css.DelimToken) && tokens[pos].value === '.') {
                pos++;
                if (isIdent())
                    rawCSSString += '.' + tokens[pos++].toSource();
                else
                    throw unexpected();
            }
            else if (tokens[pos] instanceof css.ColonToken) {
                pos++;
                if (isIdent()) {
                    if (!customNames.has(tokens[pos].value.toLowerCase())) {
                        rawCSSString += ':' + tokens[pos++].toSource();
                    }
                    else {
                        const name = tokens[pos++].value.toLowerCase();
                        functions.push({ name, args: [] });
                        names.add(name);
                    }
                }
                else if (tokens[pos] instanceof css.FunctionToken) {
                    const name = tokens[pos++].value.toLowerCase();
                    if (!customNames.has(name)) {
                        rawCSSString += \`:\${name}(\${consumeBuiltinFunctionArguments()})\`;
                    }
                    else {
                        functions.push({ name, args: consumeFunctionArguments() });
                        names.add(name);
                    }
                    skipWhitespace();
                    if (!isCloseParen())
                        throw unexpected();
                    pos++;
                }
                else {
                    throw unexpected();
                }
            }
            else if (tokens[pos] instanceof css.OpenSquareToken) {
                rawCSSString += '[';
                pos++;
                while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())
                    rawCSSString += tokens[pos++].toSource();
                if (!(tokens[pos] instanceof css.CloseSquareToken))
                    throw unexpected();
                rawCSSString += ']';
                pos++;
            }
            else {
                throw unexpected();
            }
        }
        if (!rawCSSString && !functions.length)
            throw unexpected();
        return { css: rawCSSString || undefined, functions };
    }
    function consumeBuiltinFunctionArguments() {
        let s = '';
        while (!isCloseParen() && !isEOF())
            s += tokens[pos++].toSource();
        return s;
    }
    const result = consumeFunctionArguments();
    if (!isEOF())
        throw new Error(\`Error while parsing selector "\${selector}"\`);
    if (result.some(arg => typeof arg !== 'object' || !('simples' in arg)))
        throw new Error(\`Error while parsing selector "\${selector}"\`);
    return { selector: result, names: Array.from(names) };
}
exports.parseCSS = parseCSS;
function serializeSelector(args) {
    return args.map(arg => {
        if (typeof arg === 'string')
            return \`"\${arg}"\`;
        if (typeof arg === 'number')
            return String(arg);
        return arg.simples.map(({ selector, combinator }) => {
            let s = selector.css || '';
            s = s + selector.functions.map(func => \`:\${func.name}(\${serializeSelector(func.args)})\`).join('');
            if (combinator)
                s += ' ' + combinator;
            return s;
        }).join(' ');
    }).join(', ');
}
exports.serializeSelector = serializeSelector;


/***/ }),

/***/ "./src/server/common/cssTokenizer.js":
/*!*******************************************!*\\
  !*** ./src/server/common/cssTokenizer.js ***!
  \\*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
/*
 * Original at https://github.com/tabatkins/parse-css
 * licensed under http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Changes from https://github.com/tabatkins/parse-css
//   - Tabs are replaced with two spaces.
//   - Everything not related to tokenizing - below the first exports block - is removed.
// @ts-nocheck
(function (root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else {}
}(this, function (exports) {
    var between = function (num, first, last) { return num >= first && num <= last; };
    function digit(code) { return between(code, 0x30, 0x39); }
    function hexdigit(code) { return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66); }
    function uppercaseletter(code) { return between(code, 0x41, 0x5a); }
    function lowercaseletter(code) { return between(code, 0x61, 0x7a); }
    function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
    function nonascii(code) { return code >= 0x80; }
    function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
    function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
    function nonprintable(code) { return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f; }
    function newline(code) { return code == 0xa; }
    function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
    function badescape(code) { return newline(code) || isNaN(code); }
    var maximumallowedcodepoint = 0x10ffff;
    var InvalidCharacterError = function (message) {
        this.message = message;
    };
    InvalidCharacterError.prototype = new Error;
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';
    function preprocess(str) {
        // Turn a string into an array of code points,
        // following the preprocessing cleanup rules.
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
            var code = str.charCodeAt(i);
            if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {
                code = 0xa;
                i++;
            }
            if (code == 0xd || code == 0xc)
                code = 0xa;
            if (code == 0x0)
                code = 0xfffd;
            if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {
                // Decode a surrogate pair into an astral codepoint.
                var lead = code - 0xd800;
                var trail = str.charCodeAt(i + 1) - 0xdc00;
                code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
                i++;
            }
            codepoints.push(code);
        }
        return codepoints;
    }
    function stringFromCode(code) {
        if (code <= 0xffff)
            return String.fromCharCode(code);
        // Otherwise, encode astral char as surrogate pair.
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;
        var trail = code % Math.pow(2, 10) + 0xdc00;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
    }
    function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        // Line number information.
        var line = 0;
        var column = 0;
        // The only use of lastLineLength is in reconsume().
        var lastLineLength = 0;
        var incrLineno = function () {
            line += 1;
            lastLineLength = column;
            column = 0;
        };
        var locStart = { line: line, column: column };
        var codepoint = function (i) {
            if (i >= str.length) {
                return -1;
            }
            return str[i];
        };
        var next = function (num) {
            if (num === undefined)
                num = 1;
            if (num > 3)
                throw "Spec Error: no more than three codepoints of lookahead.";
            return codepoint(i + num);
        };
        var consume = function (num) {
            if (num === undefined)
                num = 1;
            i += num;
            code = codepoint(i);
            if (newline(code))
                incrLineno();
            else
                column += num;
            //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
            return true;
        };
        var reconsume = function () {
            i -= 1;
            if (newline(code)) {
                line -= 1;
                column = lastLineLength;
            }
            else {
                column -= 1;
            }
            locStart.line = line;
            locStart.column = column;
            return true;
        };
        var eof = function (codepoint) {
            if (codepoint === undefined)
                codepoint = code;
            return codepoint == -1;
        };
        var donothing = function () { };
        var parseerror = function () { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + "."); return true; };
        var consumeAToken = function () {
            consumeComments();
            consume();
            if (whitespace(code)) {
                while (whitespace(next()))
                    consume();
                return new WhitespaceToken;
            }
            else if (code == 0x22)
                return consumeAStringToken();
            else if (code == 0x23) {
                if (namechar(next()) || areAValidEscape(next(1), next(2))) {
                    var token = new HashToken();
                    if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                        token.type = "id";
                    token.value = consumeAName();
                    return token;
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x24) {
                if (next() == 0x3d) {
                    consume();
                    return new SuffixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x27)
                return consumeAStringToken();
            else if (code == 0x28)
                return new OpenParenToken();
            else if (code == 0x29)
                return new CloseParenToken();
            else if (code == 0x2a) {
                if (next() == 0x3d) {
                    consume();
                    return new SubstringMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2b) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2c)
                return new CommaToken();
            else if (code == 0x2d) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else if (next(1) == 0x2d && next(2) == 0x3e) {
                    consume(2);
                    return new CDCToken();
                }
                else if (startsWithAnIdentifier()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x2e) {
                if (startsWithANumber()) {
                    reconsume();
                    return consumeANumericToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x3a)
                return new ColonToken;
            else if (code == 0x3b)
                return new SemicolonToken;
            else if (code == 0x3c) {
                if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
                    consume(3);
                    return new CDOToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x40) {
                if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                    return new AtKeywordToken(consumeAName());
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5b)
                return new OpenSquareToken();
            else if (code == 0x5c) {
                if (startsWithAValidEscape()) {
                    reconsume();
                    return consumeAnIdentlikeToken();
                }
                else {
                    parseerror();
                    return new DelimToken(code);
                }
            }
            else if (code == 0x5d)
                return new CloseSquareToken();
            else if (code == 0x5e) {
                if (next() == 0x3d) {
                    consume();
                    return new PrefixMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7b)
                return new OpenCurlyToken();
            else if (code == 0x7c) {
                if (next() == 0x3d) {
                    consume();
                    return new DashMatchToken();
                }
                else if (next() == 0x7c) {
                    consume();
                    return new ColumnToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (code == 0x7d)
                return new CloseCurlyToken();
            else if (code == 0x7e) {
                if (next() == 0x3d) {
                    consume();
                    return new IncludeMatchToken();
                }
                else {
                    return new DelimToken(code);
                }
            }
            else if (digit(code)) {
                reconsume();
                return consumeANumericToken();
            }
            else if (namestartchar(code)) {
                reconsume();
                return consumeAnIdentlikeToken();
            }
            else if (eof())
                return new EOFToken();
            else
                return new DelimToken(code);
        };
        var consumeComments = function () {
            while (next(1) == 0x2f && next(2) == 0x2a) {
                consume(2);
                while (true) {
                    consume();
                    if (code == 0x2a && next() == 0x2f) {
                        consume();
                        break;
                    }
                    else if (eof()) {
                        parseerror();
                        return;
                    }
                }
            }
        };
        var consumeANumericToken = function () {
            var num = consumeANumber();
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
                var token = new DimensionToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                token.unit = consumeAName();
                return token;
            }
            else if (next() == 0x25) {
                consume();
                var token = new PercentageToken();
                token.value = num.value;
                token.repr = num.repr;
                return token;
            }
            else {
                var token = new NumberToken();
                token.value = num.value;
                token.repr = num.repr;
                token.type = num.type;
                return token;
            }
        };
        var consumeAnIdentlikeToken = function () {
            var str = consumeAName();
            if (str.toLowerCase() == "url" && next() == 0x28) {
                consume();
                while (whitespace(next(1)) && whitespace(next(2)))
                    consume();
                if (next() == 0x22 || next() == 0x27) {
                    return new FunctionToken(str);
                }
                else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
                    return new FunctionToken(str);
                }
                else {
                    return consumeAURLToken();
                }
            }
            else if (next() == 0x28) {
                consume();
                return new FunctionToken(str);
            }
            else {
                return new IdentToken(str);
            }
        };
        var consumeAStringToken = function (endingCodePoint) {
            if (endingCodePoint === undefined)
                endingCodePoint = code;
            var string = "";
            while (consume()) {
                if (code == endingCodePoint || eof()) {
                    return new StringToken(string);
                }
                else if (newline(code)) {
                    parseerror();
                    reconsume();
                    return new BadStringToken();
                }
                else if (code == 0x5c) {
                    if (eof(next())) {
                        donothing();
                    }
                    else if (newline(next())) {
                        consume();
                    }
                    else {
                        string += stringFromCode(consumeEscape());
                    }
                }
                else {
                    string += stringFromCode(code);
                }
            }
        };
        var consumeAURLToken = function () {
            var token = new URLToken("");
            while (whitespace(next()))
                consume();
            if (eof(next()))
                return token;
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return token;
                }
                else if (whitespace(code)) {
                    while (whitespace(next()))
                        consume();
                    if (next() == 0x29 || eof(next())) {
                        consume();
                        return token;
                    }
                    else {
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
                    parseerror();
                    consumeTheRemnantsOfABadURL();
                    return new BadURLToken();
                }
                else if (code == 0x5c) {
                    if (startsWithAValidEscape()) {
                        token.value += stringFromCode(consumeEscape());
                    }
                    else {
                        parseerror();
                        consumeTheRemnantsOfABadURL();
                        return new BadURLToken();
                    }
                }
                else {
                    token.value += stringFromCode(code);
                }
            }
        };
        var consumeEscape = function () {
            // Assume the the current character is the \\
            // and the next code point is not a newline.
            consume();
            if (hexdigit(code)) {
                // Consume 1-6 hex digits
                var digits = [code];
                for (var total = 0; total < 5; total++) {
                    if (hexdigit(next())) {
                        consume();
                        digits.push(code);
                    }
                    else {
                        break;
                    }
                }
                if (whitespace(next()))
                    consume();
                var value = parseInt(digits.map(function (x) { return String.fromCharCode(x); }).join(''), 16);
                if (value > maximumallowedcodepoint)
                    value = 0xfffd;
                return value;
            }
            else if (eof()) {
                return 0xfffd;
            }
            else {
                return code;
            }
        };
        var areAValidEscape = function (c1, c2) {
            if (c1 != 0x5c)
                return false;
            if (newline(c2))
                return false;
            return true;
        };
        var startsWithAValidEscape = function () {
            return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function (c1, c2, c3) {
            if (c1 == 0x2d) {
                return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
            }
            else if (namestartchar(c1)) {
                return true;
            }
            else if (c1 == 0x5c) {
                return areAValidEscape(c1, c2);
            }
            else {
                return false;
            }
        };
        var startsWithAnIdentifier = function () {
            return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function (c1, c2, c3) {
            if (c1 == 0x2b || c1 == 0x2d) {
                if (digit(c2))
                    return true;
                if (c2 == 0x2e && digit(c3))
                    return true;
                return false;
            }
            else if (c1 == 0x2e) {
                if (digit(c2))
                    return true;
                return false;
            }
            else if (digit(c1)) {
                return true;
            }
            else {
                return false;
            }
        };
        var startsWithANumber = function () {
            return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function () {
            var result = "";
            while (consume()) {
                if (namechar(code)) {
                    result += stringFromCode(code);
                }
                else if (startsWithAValidEscape()) {
                    result += stringFromCode(consumeEscape());
                }
                else {
                    reconsume();
                    return result;
                }
            }
        };
        var consumeANumber = function () {
            var repr = [];
            var type = "integer";
            if (next() == 0x2b || next() == 0x2d) {
                consume();
                repr += stringFromCode(code);
            }
            while (digit(next())) {
                consume();
                repr += stringFromCode(code);
            }
            if (next(1) == 0x2e && digit(next(2))) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var c1 = next(1), c2 = next(2), c3 = next(3);
            if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                consume();
                repr += stringFromCode(code);
                type = "number";
                while (digit(next())) {
                    consume();
                    repr += stringFromCode(code);
                }
            }
            var value = convertAStringToANumber(repr);
            return { type: type, value: value, repr: repr };
        };
        var convertAStringToANumber = function (string) {
            // CSS's number rules are identical to JS, afaik.
            return +string;
        };
        var consumeTheRemnantsOfABadURL = function () {
            while (consume()) {
                if (code == 0x29 || eof()) {
                    return;
                }
                else if (startsWithAValidEscape()) {
                    consumeEscape();
                    donothing();
                }
                else {
                    donothing();
                }
            }
        };
        var iterationCount = 0;
        while (!eof(next())) {
            tokens.push(consumeAToken());
            iterationCount++;
            if (iterationCount > str.length * 2)
                return "I'm infinite-looping!";
        }
        return tokens;
    }
    function CSSParserToken() { throw "Abstract Base Class"; }
    CSSParserToken.prototype.toJSON = function () {
        return { token: this.tokenType };
    };
    CSSParserToken.prototype.toString = function () { return this.tokenType; };
    CSSParserToken.prototype.toSource = function () { return '' + this; };
    function BadStringToken() { return this; }
    BadStringToken.prototype = Object.create(CSSParserToken.prototype);
    BadStringToken.prototype.tokenType = "BADSTRING";
    function BadURLToken() { return this; }
    BadURLToken.prototype = Object.create(CSSParserToken.prototype);
    BadURLToken.prototype.tokenType = "BADURL";
    function WhitespaceToken() { return this; }
    WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
    WhitespaceToken.prototype.tokenType = "WHITESPACE";
    WhitespaceToken.prototype.toString = function () { return "WS"; };
    WhitespaceToken.prototype.toSource = function () { return " "; };
    function CDOToken() { return this; }
    CDOToken.prototype = Object.create(CSSParserToken.prototype);
    CDOToken.prototype.tokenType = "CDO";
    CDOToken.prototype.toSource = function () { return "<!--"; };
    function CDCToken() { return this; }
    CDCToken.prototype = Object.create(CSSParserToken.prototype);
    CDCToken.prototype.tokenType = "CDC";
    CDCToken.prototype.toSource = function () { return "-->"; };
    function ColonToken() { return this; }
    ColonToken.prototype = Object.create(CSSParserToken.prototype);
    ColonToken.prototype.tokenType = ":";
    function SemicolonToken() { return this; }
    SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
    SemicolonToken.prototype.tokenType = ";";
    function CommaToken() { return this; }
    CommaToken.prototype = Object.create(CSSParserToken.prototype);
    CommaToken.prototype.tokenType = ",";
    function GroupingToken() { throw "Abstract Base Class"; }
    GroupingToken.prototype = Object.create(CSSParserToken.prototype);
    function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
    OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
    OpenCurlyToken.prototype.tokenType = "{";
    function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
    CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
    CloseCurlyToken.prototype.tokenType = "}";
    function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
    OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
    OpenSquareToken.prototype.tokenType = "[";
    function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
    CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
    CloseSquareToken.prototype.tokenType = "]";
    function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
    OpenParenToken.prototype = Object.create(GroupingToken.prototype);
    OpenParenToken.prototype.tokenType = "(";
    function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
    CloseParenToken.prototype = Object.create(GroupingToken.prototype);
    CloseParenToken.prototype.tokenType = ")";
    function IncludeMatchToken() { return this; }
    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
    IncludeMatchToken.prototype.tokenType = "~=";
    function DashMatchToken() { return this; }
    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
    DashMatchToken.prototype.tokenType = "|=";
    function PrefixMatchToken() { return this; }
    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    PrefixMatchToken.prototype.tokenType = "^=";
    function SuffixMatchToken() { return this; }
    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SuffixMatchToken.prototype.tokenType = "$=";
    function SubstringMatchToken() { return this; }
    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
    SubstringMatchToken.prototype.tokenType = "*=";
    function ColumnToken() { return this; }
    ColumnToken.prototype = Object.create(CSSParserToken.prototype);
    ColumnToken.prototype.tokenType = "||";
    function EOFToken() { return this; }
    EOFToken.prototype = Object.create(CSSParserToken.prototype);
    EOFToken.prototype.tokenType = "EOF";
    EOFToken.prototype.toSource = function () { return ""; };
    function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
    }
    DelimToken.prototype = Object.create(CSSParserToken.prototype);
    DelimToken.prototype.tokenType = "DELIM";
    DelimToken.prototype.toString = function () { return "DELIM(" + this.value + ")"; };
    DelimToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    DelimToken.prototype.toSource = function () {
        if (this.value == "\\\\")
            return "\\\\\\n";
        else
            return this.value;
    };
    function StringValuedToken() { throw "Abstract Base Class"; }
    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
    StringValuedToken.prototype.ASCIIMatch = function (str) {
        return this.value.toLowerCase() == str.toLowerCase();
    };
    StringValuedToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
    };
    function IdentToken(val) {
        this.value = val;
    }
    IdentToken.prototype = Object.create(StringValuedToken.prototype);
    IdentToken.prototype.tokenType = "IDENT";
    IdentToken.prototype.toString = function () { return "IDENT(" + this.value + ")"; };
    IdentToken.prototype.toSource = function () {
        return escapeIdent(this.value);
    };
    function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
    }
    FunctionToken.prototype = Object.create(StringValuedToken.prototype);
    FunctionToken.prototype.tokenType = "FUNCTION";
    FunctionToken.prototype.toString = function () { return "FUNCTION(" + this.value + ")"; };
    FunctionToken.prototype.toSource = function () {
        return escapeIdent(this.value) + "(";
    };
    function AtKeywordToken(val) {
        this.value = val;
    }
    AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
    AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
    AtKeywordToken.prototype.toString = function () { return "AT(" + this.value + ")"; };
    AtKeywordToken.prototype.toSource = function () {
        return "@" + escapeIdent(this.value);
    };
    function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
    }
    HashToken.prototype = Object.create(StringValuedToken.prototype);
    HashToken.prototype.tokenType = "HASH";
    HashToken.prototype.toString = function () { return "HASH(" + this.value + ")"; };
    HashToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
    };
    HashToken.prototype.toSource = function () {
        if (this.type == "id") {
            return "#" + escapeIdent(this.value);
        }
        else {
            return "#" + escapeHash(this.value);
        }
    };
    function StringToken(val) {
        this.value = val;
    }
    StringToken.prototype = Object.create(StringValuedToken.prototype);
    StringToken.prototype.tokenType = "STRING";
    StringToken.prototype.toString = function () {
        return '"' + escapeString(this.value) + '"';
    };
    function URLToken(val) {
        this.value = val;
    }
    URLToken.prototype = Object.create(StringValuedToken.prototype);
    URLToken.prototype.tokenType = "URL";
    URLToken.prototype.toString = function () { return "URL(" + this.value + ")"; };
    URLToken.prototype.toSource = function () {
        return 'url("' + escapeString(this.value) + '")';
    };
    function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
    }
    NumberToken.prototype = Object.create(CSSParserToken.prototype);
    NumberToken.prototype.tokenType = "NUMBER";
    NumberToken.prototype.toString = function () {
        if (this.type == "integer")
            return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
    };
    NumberToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
    };
    NumberToken.prototype.toSource = function () { return this.repr; };
    function PercentageToken() {
        this.value = null;
        this.repr = "";
    }
    PercentageToken.prototype = Object.create(CSSParserToken.prototype);
    PercentageToken.prototype.tokenType = "PERCENTAGE";
    PercentageToken.prototype.toString = function () { return "PERCENTAGE(" + this.value + ")"; };
    PercentageToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
    };
    PercentageToken.prototype.toSource = function () { return this.repr + "%"; };
    function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
    }
    DimensionToken.prototype = Object.create(CSSParserToken.prototype);
    DimensionToken.prototype.tokenType = "DIMENSION";
    DimensionToken.prototype.toString = function () { return "DIM(" + this.value + "," + this.unit + ")"; };
    DimensionToken.prototype.toJSON = function () {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
    };
    DimensionToken.prototype.toSource = function () {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
            // Unit is ambiguous with scinot
            // Remove the leading "e", replace with escape.
            unit = "\\\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
    };
    function escapeIdent(string) {
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f ||
                (i == 0 && between(code, 0x30, 0x39)) ||
                (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)) {
                result += '\\\\' + code.toString(16) + ' ';
            }
            else if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\\\' + string[i];
            }
        }
        return result;
    }
    function escapeHash(string) {
        // Escapes the contents of "unrestricted"-type hash tokens.
        // Won't preserve the ID-ness of "id"-type hash tokens;
        // use escapeIdent() for that.
        string = '' + string;
        var result = '';
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (code >= 0x80 ||
                code == 0x2d ||
                code == 0x5f ||
                between(code, 0x30, 0x39) ||
                between(code, 0x41, 0x5a) ||
                between(code, 0x61, 0x7a)) {
                result += string[i];
            }
            else {
                result += '\\\\' + code.toString(16) + ' ';
            }
        }
        return result;
    }
    function escapeString(string) {
        string = '' + string;
        var result = '';
        for (var i = 0; i < string.length; i++) {
            var code = string.charCodeAt(i);
            if (code == 0x0) {
                throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
            }
            if (between(code, 0x1, 0x1f) || code == 0x7f) {
                result += '\\\\' + code.toString(16) + ' ';
            }
            else if (code == 0x22 || code == 0x5c) {
                result += '\\\\' + string[i];
            }
            else {
                result += string[i];
            }
        }
        return result;
    }
    // Exportation.
    exports.tokenize = tokenize;
    exports.IdentToken = IdentToken;
    exports.FunctionToken = FunctionToken;
    exports.AtKeywordToken = AtKeywordToken;
    exports.HashToken = HashToken;
    exports.StringToken = StringToken;
    exports.BadStringToken = BadStringToken;
    exports.URLToken = URLToken;
    exports.BadURLToken = BadURLToken;
    exports.DelimToken = DelimToken;
    exports.NumberToken = NumberToken;
    exports.PercentageToken = PercentageToken;
    exports.DimensionToken = DimensionToken;
    exports.IncludeMatchToken = IncludeMatchToken;
    exports.DashMatchToken = DashMatchToken;
    exports.PrefixMatchToken = PrefixMatchToken;
    exports.SuffixMatchToken = SuffixMatchToken;
    exports.SubstringMatchToken = SubstringMatchToken;
    exports.ColumnToken = ColumnToken;
    exports.WhitespaceToken = WhitespaceToken;
    exports.CDOToken = CDOToken;
    exports.CDCToken = CDCToken;
    exports.ColonToken = ColonToken;
    exports.SemicolonToken = SemicolonToken;
    exports.CommaToken = CommaToken;
    exports.OpenParenToken = OpenParenToken;
    exports.CloseParenToken = CloseParenToken;
    exports.OpenSquareToken = OpenSquareToken;
    exports.CloseSquareToken = CloseSquareToken;
    exports.OpenCurlyToken = OpenCurlyToken;
    exports.CloseCurlyToken = CloseCurlyToken;
    exports.EOFToken = EOFToken;
    exports.CSSParserToken = CSSParserToken;
    exports.GroupingToken = GroupingToken;
}));


/***/ }),

/***/ "./src/server/common/selectorParser.ts":
/*!*********************************************!*\\
  !*** ./src/server/common/selectorParser.ts ***!
  \\*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSelector = exports.customCSSNames = void 0;
const cssParser_1 = __webpack_require__(/*! ./cssParser */ "./src/server/common/cssParser.ts");
exports.customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);
function parseSelector(selector) {
    const result = parseSelectorV1(selector);
    result.parts = result.parts.map(part => {
        if (Array.isArray(part))
            return part;
        if (part.name === 'css' || part.name === 'css:light') {
            if (part.name === 'css:light')
                part.body = ':light(' + part.body + ')';
            const parsedCSS = cssParser_1.parseCSS(part.body, exports.customCSSNames);
            return parsedCSS.selector;
        }
        return part;
    });
    return {
        parts: result.parts,
        capture: result.capture,
    };
}
exports.parseSelector = parseSelector;
function parseSelectorV1(selector) {
    let index = 0;
    let quote;
    let start = 0;
    const result = { parts: [] };
    const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf('=');
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
            name = part.substring(0, eqIndex).trim();
            body = part.substring(eqIndex + 1);
        }
        else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
            name = 'text';
            body = part;
        }
        else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
            name = 'text';
            body = part;
        }
        else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {
            // If selector starts with '//' or '//' prefixed with multiple opening
            // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
            // If selector starts with '..', consider xpath as well.
            name = 'xpath';
            body = part;
        }
        else {
            name = 'css';
            body = part;
        }
        let capture = false;
        if (name[0] === '*') {
            capture = true;
            name = name.substring(1);
        }
        result.parts.push({ name, body });
        if (capture) {
            if (result.capture !== undefined)
                throw new Error(\`Only one of the selectors can capture using * modifier\`);
            result.capture = result.parts.length - 1;
        }
    };
    if (!selector.includes('>>')) {
        index = selector.length;
        append();
        return result;
    }
    while (index < selector.length) {
        const c = selector[index];
        if (c === '\\\\' && index + 1 < selector.length) {
            index += 2;
        }
        else if (c === quote) {
            quote = undefined;
            index++;
        }
        else if (!quote && (c === '"' || c === '\\'' || c === '\`')) {
            quote = c;
            index++;
        }
        else if (!quote && c === '>' && selector[index + 1] === '>') {
            append();
            index += 2;
            start = index;
        }
        else {
            index++;
        }
    }
    append();
    return result;
}


/***/ }),

/***/ "./src/server/injected/selectorEvaluator.ts":
/*!**************************************************!*\\
  !*** ./src/server/injected/selectorEvaluator.ts ***!
  \\**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVisible = exports.parentElementOrShadowHost = exports.elementMatchesText = exports.elementText = exports.createRegexTextMatcher = exports.createStrictTextMatcher = exports.createLaxTextMatcher = exports.SelectorEvaluatorImpl = void 0;
const selectorParser_1 = __webpack_require__(/*! ../common/selectorParser */ "./src/server/common/selectorParser.ts");
class SelectorEvaluatorImpl {
    constructor(extraEngines) {
        this._engines = new Map();
        this._cacheQueryCSS = new Map();
        this._cacheMatches = new Map();
        this._cacheQuery = new Map();
        this._cacheMatchesSimple = new Map();
        this._cacheMatchesParents = new Map();
        this._cacheCallMatches = new Map();
        this._cacheCallQuery = new Map();
        this._cacheQuerySimple = new Map();
        this._cacheText = new Map();
        this._retainCacheCounter = 0;
        for (const [name, engine] of extraEngines)
            this._engines.set(name, engine);
        this._engines.set('not', notEngine);
        this._engines.set('is', isEngine);
        this._engines.set('where', isEngine);
        this._engines.set('has', hasEngine);
        this._engines.set('scope', scopeEngine);
        this._engines.set('light', lightEngine);
        this._engines.set('visible', visibleEngine);
        this._engines.set('text', textEngine);
        this._engines.set('text-is', textIsEngine);
        this._engines.set('text-matches', textMatchesEngine);
        this._engines.set('has-text', hasTextEngine);
        this._engines.set('right-of', createPositionEngine('right-of', boxRightOf));
        this._engines.set('left-of', createPositionEngine('left-of', boxLeftOf));
        this._engines.set('above', createPositionEngine('above', boxAbove));
        this._engines.set('below', createPositionEngine('below', boxBelow));
        this._engines.set('near', createPositionEngine('near', boxNear));
        this._engines.set('nth-match', nthMatchEngine);
        const allNames = Array.from(this._engines.keys());
        allNames.sort();
        const parserNames = Array.from(selectorParser_1.customCSSNames).slice();
        parserNames.sort();
        if (allNames.join('|') !== parserNames.join('|'))
            throw new Error(\`Please keep customCSSNames in sync with evaluator engines: \${allNames.join('|')} vs \${parserNames.join('|')}\`);
    }
    begin() {
        ++this._retainCacheCounter;
    }
    end() {
        --this._retainCacheCounter;
        if (!this._retainCacheCounter) {
            this._cacheQueryCSS.clear();
            this._cacheMatches.clear();
            this._cacheQuery.clear();
            this._cacheMatchesSimple.clear();
            this._cacheMatchesParents.clear();
            this._cacheCallMatches.clear();
            this._cacheCallQuery.clear();
            this._cacheQuerySimple.clear();
            this._cacheText.clear();
        }
    }
    _cached(cache, main, rest, cb) {
        if (!cache.has(main))
            cache.set(main, []);
        const entries = cache.get(main);
        const entry = entries.find(e => rest.every((value, index) => e.rest[index] === value));
        if (entry)
            return entry.result;
        const result = cb();
        entries.push({ rest, result });
        return result;
    }
    _checkSelector(s) {
        const wellFormed = typeof s === 'object' && s &&
            (Array.isArray(s) || ('simples' in s) && (s.simples.length));
        if (!wellFormed)
            throw new Error(\`Malformed selector "\${s}"\`);
        return s;
    }
    matches(element, s, context) {
        const selector = this._checkSelector(s);
        this.begin();
        try {
            return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {
                if (Array.isArray(selector))
                    return this._matchesEngine(isEngine, element, selector, context);
                if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))
                    return false;
                return this._matchesParents(element, selector, selector.simples.length - 2, context);
            });
        }
        finally {
            this.end();
        }
    }
    query(context, s) {
        const selector = this._checkSelector(s);
        this.begin();
        try {
            return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {
                if (Array.isArray(selector))
                    return this._queryEngine(isEngine, context, selector);
                // query() recursively calls itself, so we set up a new map for this particular query() call.
                const previousScoreMap = this._scoreMap;
                this._scoreMap = new Map();
                let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);
                elements = elements.filter(element => this._matchesParents(element, selector, selector.simples.length - 2, context));
                if (this._scoreMap.size) {
                    elements.sort((a, b) => {
                        const aScore = this._scoreMap.get(a);
                        const bScore = this._scoreMap.get(b);
                        if (aScore === bScore)
                            return 0;
                        if (aScore === undefined)
                            return 1;
                        if (bScore === undefined)
                            return -1;
                        return aScore - bScore;
                    });
                }
                this._scoreMap = previousScoreMap;
                return elements;
            });
        }
        finally {
            this.end();
        }
    }
    _markScore(element, score) {
        // HACK ALERT: temporary marks an element with a score, to be used
        // for sorting at the end of the query().
        if (this._scoreMap)
            this._scoreMap.set(element, score);
    }
    _matchesSimple(element, simple, context) {
        return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {
            const isPossiblyScopeClause = simple.functions.some(f => f.name === 'scope' || f.name === 'is');
            if (!isPossiblyScopeClause && element === context.scope)
                return false;
            if (simple.css && !this._matchesCSS(element, simple.css))
                return false;
            for (const func of simple.functions) {
                if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))
                    return false;
            }
            return true;
        });
    }
    _querySimple(context, simple) {
        if (!simple.functions.length)
            return this._queryCSS(context, simple.css || '*');
        return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {
            let css = simple.css;
            const funcs = simple.functions;
            if (css === '*' && funcs.length)
                css = undefined;
            let elements;
            let firstIndex = -1;
            if (css !== undefined) {
                elements = this._queryCSS(context, css);
            }
            else {
                firstIndex = funcs.findIndex(func => this._getEngine(func.name).query !== undefined);
                if (firstIndex === -1)
                    firstIndex = 0;
                elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);
            }
            for (let i = 0; i < funcs.length; i++) {
                if (i === firstIndex)
                    continue;
                const engine = this._getEngine(funcs[i].name);
                if (engine.matches !== undefined)
                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));
            }
            for (let i = 0; i < funcs.length; i++) {
                if (i === firstIndex)
                    continue;
                const engine = this._getEngine(funcs[i].name);
                if (engine.matches === undefined)
                    elements = elements.filter(e => this._matchesEngine(engine, e, funcs[i].args, context));
            }
            return elements;
        });
    }
    _matchesParents(element, complex, index, context) {
        if (index < 0)
            return true;
        return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {
            const { selector: simple, combinator } = complex.simples[index];
            if (combinator === '>') {
                const parent = parentElementOrShadowHostInContext(element, context);
                if (!parent || !this._matchesSimple(parent, simple, context))
                    return false;
                return this._matchesParents(parent, complex, index - 1, context);
            }
            if (combinator === '+') {
                const previousSibling = previousSiblingInContext(element, context);
                if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))
                    return false;
                return this._matchesParents(previousSibling, complex, index - 1, context);
            }
            if (combinator === '') {
                let parent = parentElementOrShadowHostInContext(element, context);
                while (parent) {
                    if (this._matchesSimple(parent, simple, context)) {
                        if (this._matchesParents(parent, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '')
                            break;
                    }
                    parent = parentElementOrShadowHostInContext(parent, context);
                }
                return false;
            }
            if (combinator === '~') {
                let previousSibling = previousSiblingInContext(element, context);
                while (previousSibling) {
                    if (this._matchesSimple(previousSibling, simple, context)) {
                        if (this._matchesParents(previousSibling, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '~')
                            break;
                    }
                    previousSibling = previousSiblingInContext(previousSibling, context);
                }
                return false;
            }
            if (combinator === '>=') {
                let parent = element;
                while (parent) {
                    if (this._matchesSimple(parent, simple, context)) {
                        if (this._matchesParents(parent, complex, index - 1, context))
                            return true;
                        if (complex.simples[index - 1].combinator === '')
                            break;
                    }
                    parent = parentElementOrShadowHostInContext(parent, context);
                }
                return false;
            }
            throw new Error(\`Unsupported combinator "\${combinator}"\`);
        });
    }
    _matchesEngine(engine, element, args, context) {
        if (engine.matches)
            return this._callMatches(engine, element, args, context);
        if (engine.query)
            return this._callQuery(engine, args, context).includes(element);
        throw new Error(\`Selector engine should implement "matches" or "query"\`);
    }
    _queryEngine(engine, context, args) {
        if (engine.query)
            return this._callQuery(engine, args, context);
        if (engine.matches)
            return this._queryCSS(context, '*').filter(element => this._callMatches(engine, element, args, context));
        throw new Error(\`Selector engine should implement "matches" or "query"\`);
    }
    _callMatches(engine, element, args, context) {
        return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {
            return engine.matches(element, args, context, this);
        });
    }
    _callQuery(engine, args, context) {
        return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {
            return engine.query(context, args, this);
        });
    }
    _matchesCSS(element, css) {
        return element.matches(css);
    }
    _queryCSS(context, css) {
        return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow], () => {
            let result = [];
            function query(root) {
                result = result.concat([...root.querySelectorAll(css)]);
                if (!context.pierceShadow)
                    return;
                if (root.shadowRoot)
                    query(root.shadowRoot);
                for (const element of root.querySelectorAll('*')) {
                    if (element.shadowRoot)
                        query(element.shadowRoot);
                }
            }
            query(context.scope);
            return result;
        });
    }
    _getEngine(name) {
        const engine = this._engines.get(name);
        if (!engine)
            throw new Error(\`Unknown selector engine "\${name}"\`);
        return engine;
    }
}
exports.SelectorEvaluatorImpl = SelectorEvaluatorImpl;
const isEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"is" engine expects non-empty selector list\`);
        return args.some(selector => evaluator.matches(element, selector, context));
    },
    query(context, args, evaluator) {
        if (args.length === 0)
            throw new Error(\`"is" engine expects non-empty selector list\`);
        let elements = [];
        for (const arg of args)
            elements = elements.concat(evaluator.query(context, arg));
        return args.length === 1 ? elements : sortInDOMOrder(elements);
    },
};
const hasEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"has" engine expects non-empty selector list\`);
        return evaluator.query({ ...context, scope: element }, args).length > 0;
    },
};
const scopeEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 0)
            throw new Error(\`"scope" engine expects no arguments\`);
        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */)
            return element === context.scope.documentElement;
        return element === context.scope;
    },
    query(context, args, evaluator) {
        if (args.length !== 0)
            throw new Error(\`"scope" engine expects no arguments\`);
        if (context.scope.nodeType === 9 /* Node.DOCUMENT_NODE */) {
            const root = context.scope.documentElement;
            return root ? [root] : [];
        }
        if (context.scope.nodeType === 1 /* Node.ELEMENT_NODE */)
            return [context.scope];
        return [];
    },
};
const notEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0)
            throw new Error(\`"not" engine expects non-empty selector list\`);
        return !evaluator.matches(element, args, context);
    },
};
const lightEngine = {
    query(context, args, evaluator) {
        return evaluator.query({ ...context, pierceShadow: false }, args);
    },
    matches(element, args, context, evaluator) {
        return evaluator.matches(element, args, { ...context, pierceShadow: false });
    }
};
const visibleEngine = {
    matches(element, args, context, evaluator) {
        if (args.length)
            throw new Error(\`"visible" engine expects no arguments\`);
        return isVisible(element);
    }
};
const textEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"text" engine expects a single string\`);
        const matcher = createLaxTextMatcher(args[0]);
        return elementMatchesText(evaluator, element, matcher) === 'self';
    },
};
const textIsEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"text-is" engine expects a single string\`);
        const matcher = createStrictTextMatcher(args[0]);
        return elementMatchesText(evaluator, element, matcher) !== 'none';
    },
};
const textMatchesEngine = {
    matches(element, args, context, evaluator) {
        if (args.length === 0 || typeof args[0] !== 'string' || args.length > 2 || (args.length === 2 && typeof args[1] !== 'string'))
            throw new Error(\`"text-matches" engine expects a regexp body and optional regexp flags\`);
        const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : undefined);
        return elementMatchesText(evaluator, element, matcher) === 'self';
    },
};
const hasTextEngine = {
    matches(element, args, context, evaluator) {
        if (args.length !== 1 || typeof args[0] !== 'string')
            throw new Error(\`"has-text" engine expects a single string\`);
        if (shouldSkipForTextMatching(element))
            return false;
        const matcher = createLaxTextMatcher(args[0]);
        return matcher(elementText(evaluator, element));
    },
};
function createLaxTextMatcher(text) {
    text = text.trim().replace(/\\s+/g, ' ').toLowerCase();
    return (elementText) => {
        const s = elementText.full.trim().replace(/\\s+/g, ' ').toLowerCase();
        return s.includes(text);
    };
}
exports.createLaxTextMatcher = createLaxTextMatcher;
function createStrictTextMatcher(text) {
    text = text.trim().replace(/\\s+/g, ' ');
    return (elementText) => {
        return elementText.immediate.some(s => s.trim().replace(/\\s+/g, ' ') === text);
    };
}
exports.createStrictTextMatcher = createStrictTextMatcher;
function createRegexTextMatcher(source, flags) {
    const re = new RegExp(source, flags);
    return (elementText) => {
        return re.test(elementText.full);
    };
}
exports.createRegexTextMatcher = createRegexTextMatcher;
function shouldSkipForTextMatching(element) {
    return element.nodeName === 'SCRIPT' || element.nodeName === 'STYLE' || document.head && document.head.contains(element);
}
function elementText(evaluator, root) {
    let value = evaluator._cacheText.get(root);
    if (value === undefined) {
        value = { full: '', immediate: [] };
        if (!shouldSkipForTextMatching(root)) {
            let currentImmediate = '';
            if ((root instanceof HTMLInputElement) && (root.type === 'submit' || root.type === 'button')) {
                value = { full: root.value, immediate: [root.value] };
            }
            else {
                for (let child = root.firstChild; child; child = child.nextSibling) {
                    if (child.nodeType === Node.TEXT_NODE) {
                        value.full += child.nodeValue || '';
                        currentImmediate += child.nodeValue || '';
                    }
                    else {
                        if (currentImmediate)
                            value.immediate.push(currentImmediate);
                        currentImmediate = '';
                        if (child.nodeType === Node.ELEMENT_NODE)
                            value.full += elementText(evaluator, child).full;
                    }
                }
                if (currentImmediate)
                    value.immediate.push(currentImmediate);
                if (root.shadowRoot)
                    value.full += elementText(evaluator, root.shadowRoot).full;
            }
        }
        evaluator._cacheText.set(root, value);
    }
    return value;
}
exports.elementText = elementText;
function elementMatchesText(evaluator, element, matcher) {
    if (shouldSkipForTextMatching(element))
        return 'none';
    if (!matcher(elementText(evaluator, element)))
        return 'none';
    for (let child = element.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))
            return 'selfAndChildren';
    }
    if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))
        return 'selfAndChildren';
    return 'self';
}
exports.elementMatchesText = elementMatchesText;
function boxRightOf(box1, box2, maxDistance) {
    const distance = box1.left - box2.right;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);
}
function boxLeftOf(box1, box2, maxDistance) {
    const distance = box2.left - box1.right;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);
}
function boxAbove(box1, box2, maxDistance) {
    const distance = box2.top - box1.bottom;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);
}
function boxBelow(box1, box2, maxDistance) {
    const distance = box1.top - box2.bottom;
    if (distance < 0 || (maxDistance !== undefined && distance > maxDistance))
        return;
    return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);
}
function boxNear(box1, box2, maxDistance) {
    const kThreshold = maxDistance === undefined ? 50 : maxDistance;
    let score = 0;
    if (box1.left - box2.right >= 0)
        score += box1.left - box2.right;
    if (box2.left - box1.right >= 0)
        score += box2.left - box1.right;
    if (box2.top - box1.bottom >= 0)
        score += box2.top - box1.bottom;
    if (box1.top - box2.bottom >= 0)
        score += box1.top - box2.bottom;
    return score > kThreshold ? undefined : score;
}
function createPositionEngine(name, scorer) {
    return {
        matches(element, args, context, evaluator) {
            const maxDistance = args.length && typeof args[args.length - 1] === 'number' ? args[args.length - 1] : undefined;
            const queryArgs = maxDistance === undefined ? args : args.slice(0, args.length - 1);
            if (args.length < 1 + (maxDistance === undefined ? 0 : 1))
                throw new Error(\`"\${name}" engine expects a selector list and optional maximum distance in pixels\`);
            const box = element.getBoundingClientRect();
            let bestScore;
            for (const e of evaluator.query(context, queryArgs)) {
                if (e === element)
                    continue;
                const score = scorer(box, e.getBoundingClientRect(), maxDistance);
                if (score === undefined)
                    continue;
                if (bestScore === undefined || score < bestScore)
                    bestScore = score;
            }
            if (bestScore === undefined)
                return false;
            evaluator._markScore(element, bestScore);
            return true;
        }
    };
}
const nthMatchEngine = {
    query(context, args, evaluator) {
        let index = args[args.length - 1];
        if (args.length < 2)
            throw new Error(\`"nth-match" engine expects non-empty selector list and an index argument\`);
        if (typeof index !== 'number' || index < 1)
            throw new Error(\`"nth-match" engine expects a one-based index as the last argument\`);
        const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);
        index--; // one-based
        return index < elements.length ? [elements[index]] : [];
    },
};
function parentElementOrShadowHost(element) {
    if (element.parentElement)
        return element.parentElement;
    if (!element.parentNode)
        return;
    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)
        return element.parentNode.host;
}
exports.parentElementOrShadowHost = parentElementOrShadowHost;
function parentElementOrShadowHostInContext(element, context) {
    if (element === context.scope)
        return;
    if (!context.pierceShadow)
        return element.parentElement || undefined;
    return parentElementOrShadowHost(element);
}
function previousSiblingInContext(element, context) {
    if (element === context.scope)
        return;
    return element.previousElementSibling || undefined;
}
function isVisible(element) {
    // Note: this logic should be similar to waitForDisplayedAtStablePosition() to avoid surprises.
    if (!element.ownerDocument || !element.ownerDocument.defaultView)
        return true;
    const style = element.ownerDocument.defaultView.getComputedStyle(element);
    if (!style || style.visibility === 'hidden')
        return false;
    const rect = element.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0;
}
exports.isVisible = isVisible;
function sortInDOMOrder(elements) {
    const elementToEntry = new Map();
    const roots = [];
    const result = [];
    function append(element) {
        let entry = elementToEntry.get(element);
        if (entry)
            return entry;
        const parent = parentElementOrShadowHost(element);
        if (parent) {
            const parentEntry = append(parent);
            parentEntry.children.push(element);
        }
        else {
            roots.push(element);
        }
        entry = { children: [], taken: false };
        elementToEntry.set(element, entry);
        return entry;
    }
    elements.forEach(e => append(e).taken = true);
    function visit(element) {
        const entry = elementToEntry.get(element);
        if (entry.taken)
            result.push(element);
        if (entry.children.length > 1) {
            const set = new Set(entry.children);
            entry.children = [];
            let child = element.firstElementChild;
            while (child && entry.children.length < set.size) {
                if (set.has(child))
                    entry.children.push(child);
                child = child.nextElementSibling;
            }
            child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;
            while (child && entry.children.length < set.size) {
                if (set.has(child))
                    entry.children.push(child);
                child = child.nextElementSibling;
            }
        }
        entry.children.forEach(visit);
    }
    roots.forEach(visit);
    return result;
}


/***/ }),

/***/ "./src/server/supplements/injected/consoleApi.ts":
/*!*******************************************************!*\\
  !*** ./src/server/supplements/injected/consoleApi.ts ***!
  \\*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleAPI = void 0;
const selectorGenerator_1 = __webpack_require__(/*! ./selectorGenerator */ "./src/server/supplements/injected/selectorGenerator.ts");
class ConsoleAPI {
    constructor(injectedScript) {
        this._injectedScript = injectedScript;
        if (window.playwright)
            return;
        window.playwright = {
            $: (selector) => this._querySelector(selector),
            $$: (selector) => this._querySelectorAll(selector),
            inspect: (selector) => this._inspect(selector),
            selector: (element) => this._selector(element),
            resume: () => this._resume(),
        };
    }
    _querySelector(selector) {
        if (typeof selector !== 'string')
            throw new Error(\`Usage: playwright.query('Playwright >> selector').\`);
        const parsed = this._injectedScript.parseSelector(selector);
        return this._injectedScript.querySelector(parsed, document);
    }
    _querySelectorAll(selector) {
        if (typeof selector !== 'string')
            throw new Error(\`Usage: playwright.$$('Playwright >> selector').\`);
        const parsed = this._injectedScript.parseSelector(selector);
        return this._injectedScript.querySelectorAll(parsed, document);
    }
    _inspect(selector) {
        if (typeof selector !== 'string')
            throw new Error(\`Usage: playwright.inspect('Playwright >> selector').\`);
        window.inspect(this._querySelector(selector));
    }
    _selector(element) {
        if (!(element instanceof Element))
            throw new Error(\`Usage: playwright.selector(element).\`);
        return selectorGenerator_1.generateSelector(this._injectedScript, element).selector;
    }
    _resume() {
        window._playwrightResume().catch(() => { });
    }
}
exports.ConsoleAPI = ConsoleAPI;
exports.default = ConsoleAPI;


/***/ }),

/***/ "./src/server/supplements/injected/selectorGenerator.ts":
/*!**************************************************************!*\\
  !*** ./src/server/supplements/injected/selectorGenerator.ts ***!
  \\**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSelector = exports.querySelector = void 0;
const selectorEvaluator_1 = __webpack_require__(/*! ../../injected/selectorEvaluator */ "./src/server/injected/selectorEvaluator.ts");
const cacheAllowText = new Map();
const cacheDisallowText = new Map();
function querySelector(injectedScript, selector, ownerDocument) {
    try {
        const parsedSelector = injectedScript.parseSelector(selector);
        return {
            selector,
            elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)
        };
    }
    catch (e) {
        return {
            selector,
            elements: [],
        };
    }
}
exports.querySelector = querySelector;
function generateSelector(injectedScript, targetElement) {
    injectedScript._evaluator.begin();
    try {
        targetElement = targetElement.closest('button,select,input,[role=button],[role=checkbox],[role=radio]') || targetElement;
        const targetTokens = generateSelectorFor(injectedScript, targetElement);
        const bestTokens = targetTokens || [cssFallback(injectedScript, targetElement)];
        const selector = joinTokens(bestTokens);
        const parsedSelector = injectedScript.parseSelector(selector);
        return {
            selector,
            elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)
        };
    }
    finally {
        cacheAllowText.clear();
        cacheDisallowText.clear();
        injectedScript._evaluator.end();
    }
}
exports.generateSelector = generateSelector;
function filterRegexTokens(textCandidates) {
    // Filter out regex-based selectors for better performance.
    return textCandidates.filter(c => c[0].selector[0] !== '/');
}
function generateSelectorFor(injectedScript, targetElement) {
    if (targetElement.ownerDocument.documentElement === targetElement)
        return [{ engine: 'css', selector: 'html', score: 1 }];
    const calculate = (element, allowText) => {
        const allowNthMatch = element === targetElement;
        let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map(token => [token]) : [];
        if (element !== targetElement) {
            // Do not use regex for parent elements (for performance).
            textCandidates = filterRegexTokens(textCandidates);
        }
        const noTextCandidates = buildCandidates(injectedScript, element).map(token => [token]);
        // First check all text and non-text candidates for the element.
        let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);
        // Do not use regex for chained selectors (for performance).
        textCandidates = filterRegexTokens(textCandidates);
        const checkWithText = (textCandidatesToUse) => {
            // Use the deepest possible text selector - works pretty good and saves on compute time.
            const allowParentText = allowText && !textCandidatesToUse.length;
            const candidates = [...textCandidatesToUse, ...noTextCandidates].filter(c => {
                if (!result)
                    return true;
                return combineScores(c) < combineScores(result);
            });
            // This is best theoretically possible candidate from the current parent.
            // We use the fact that widening the scope to grand-parent makes any selector
            // even less likely to match.
            let bestPossibleInParent = candidates[0];
            if (!bestPossibleInParent)
                return;
            for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {
                const parentTokens = calculateCached(parent, allowParentText);
                if (!parentTokens)
                    continue;
                // Even the best selector won't be too good - skip this parent.
                if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))
                    continue;
                // Update the best candidate that finds "element" in the "parent".
                bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);
                if (!bestPossibleInParent)
                    return;
                const combined = [...parentTokens, ...bestPossibleInParent];
                if (!result || combineScores(combined) < combineScores(result))
                    result = combined;
            }
        };
        checkWithText(textCandidates);
        // Allow skipping text on the target element, and using text on one of the parents.
        if (element === targetElement && textCandidates.length)
            checkWithText([]);
        return result;
    };
    const calculateCached = (element, allowText) => {
        const cache = allowText ? cacheAllowText : cacheDisallowText;
        let value = cache.get(element);
        if (value === undefined) {
            value = calculate(element, allowText);
            cache.set(element, value);
        }
        return value;
    };
    return calculateCached(targetElement, true);
}
function buildCandidates(injectedScript, element) {
    const candidates = [];
    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {
        if (element.hasAttribute(attribute))
            candidates.push({ engine: 'css', selector: \`[\${attribute}=\${quoteString(element.getAttribute(attribute))}]\`, score: 1 });
    }
    if (element.nodeName === 'INPUT') {
        const input = element;
        if (input.placeholder)
            candidates.push({ engine: 'css', selector: \`[placeholder=\${quoteString(input.placeholder)}]\`, score: 10 });
    }
    if (element.hasAttribute('aria-label'))
        candidates.push({ engine: 'css', selector: \`[aria-label=\${quoteString(element.getAttribute('aria-label'))}]\`, score: 10 });
    if (element.getAttribute('alt') && ['APPLET', 'AREA', 'IMG', 'INPUT'].includes(element.nodeName))
        candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLowerCase()}[alt=\${quoteString(element.getAttribute('alt'))}]\`, score: 10 });
    if (element.hasAttribute('role'))
        candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLocaleLowerCase()}[role=\${quoteString(element.getAttribute('role'))}]\`, score: 50 });
    if (element.getAttribute('name') && ['BUTTON', 'FORM', 'FIELDSET', 'IFRAME', 'INPUT', 'KEYGEN', 'OBJECT', 'OUTPUT', 'SELECT', 'TEXTAREA', 'MAP', 'META', 'PARAM'].includes(element.nodeName))
        candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLowerCase()}[name=\${quoteString(element.getAttribute('name'))}]\`, score: 50 });
    if (['INPUT', 'TEXTAREA'].includes(element.nodeName) && element.getAttribute('type') !== 'hidden') {
        if (element.getAttribute('type'))
            candidates.push({ engine: 'css', selector: \`\${element.nodeName.toLowerCase()}[type=\${quoteString(element.getAttribute('type'))}]\`, score: 50 });
    }
    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(element.nodeName))
        candidates.push({ engine: 'css', selector: element.nodeName.toLowerCase(), score: 50 });
    const idAttr = element.getAttribute('id');
    if (idAttr && !isGuidLike(idAttr))
        candidates.push({ engine: 'css', selector: makeSelectorForId(idAttr), score: 100 });
    candidates.push({ engine: 'css', selector: element.nodeName.toLocaleLowerCase(), score: 200 });
    return candidates;
}
function buildTextCandidates(injectedScript, element, allowHasText) {
    if (element.nodeName === 'SELECT')
        return [];
    const text = selectorEvaluator_1.elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, ' ').substring(0, 80);
    if (!text)
        return [];
    const candidates = [];
    let escaped = text;
    if (text.includes('"') || text.includes('>>') || text[0] === '/')
        escaped = \`/.*\${escapeForRegex(text)}.*/\`;
    candidates.push({ engine: 'text', selector: escaped, score: 10 });
    if (allowHasText && escaped === text) {
        let prefix = element.nodeName.toLocaleLowerCase();
        if (element.hasAttribute('role'))
            prefix += \`[role=\${quoteString(element.getAttribute('role'))}]\`;
        candidates.push({ engine: 'css', selector: \`\${prefix}:has-text("\${text}")\`, score: 30 });
    }
    return candidates;
}
function parentElementOrShadowHost(element) {
    if (element.parentElement)
        return element.parentElement;
    if (!element.parentNode)
        return null;
    if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)
        return element.parentNode.host;
    return null;
}
function makeSelectorForId(id) {
    return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? '#' + id : \`[id="\${id}"]\`;
}
function cssFallback(injectedScript, targetElement) {
    const kFallbackScore = 10000000;
    const root = targetElement.ownerDocument;
    const tokens = [];
    function uniqueCSSSelector(prefix) {
        const path = tokens.slice();
        if (prefix)
            path.unshift(prefix);
        const selector = path.join(' ');
        const parsedSelector = injectedScript.parseSelector(selector);
        const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument);
        return node === targetElement ? selector : undefined;
    }
    for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {
        const nodeName = element.nodeName.toLowerCase();
        // Element ID is the strongest signal, use it.
        let bestTokenForLevel = '';
        if (element.id) {
            const token = makeSelectorForId(element.id);
            const selector = uniqueCSSSelector(token);
            if (selector)
                return { engine: 'css', selector, score: kFallbackScore };
            bestTokenForLevel = token;
        }
        const parent = element.parentNode;
        // Combine class names until unique.
        const classes = Array.from(element.classList);
        for (let i = 0; i < classes.length; ++i) {
            const token = '.' + classes.slice(0, i + 1).join('.');
            const selector = uniqueCSSSelector(token);
            if (selector)
                return { engine: 'css', selector, score: kFallbackScore };
            // Even if not unique, does this subset of classes uniquely identify node as a child?
            if (!bestTokenForLevel && parent) {
                const sameClassSiblings = parent.querySelectorAll(token);
                if (sameClassSiblings.length === 1)
                    bestTokenForLevel = token;
            }
        }
        // Ordinal is the weakest signal.
        if (parent) {
            const siblings = Array.from(parent.children);
            const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);
            const token = sameTagSiblings.indexOf(element) === 0 ? nodeName : \`\${nodeName}:nth-child(\${1 + siblings.indexOf(element)})\`;
            const selector = uniqueCSSSelector(token);
            if (selector)
                return { engine: 'css', selector, score: kFallbackScore };
            if (!bestTokenForLevel)
                bestTokenForLevel = token;
        }
        else if (!bestTokenForLevel) {
            bestTokenForLevel = nodeName;
        }
        tokens.unshift(bestTokenForLevel);
    }
    return { engine: 'css', selector: uniqueCSSSelector(), score: kFallbackScore };
}
function escapeForRegex(text) {
    return text.replace(/[.*+?^>\${}()|[\\]\\\\]/g, '\\\\$&');
}
function quoteString(text) {
    return \`"\${text.replaceAll(/"/g, '\\\\"').replaceAll(/\\n/g, '\\\\n')}"\`;
}
function joinTokens(tokens) {
    const parts = [];
    let lastEngine = '';
    for (const { engine, selector } of tokens) {
        if (parts.length && (lastEngine !== 'css' || engine !== 'css' || selector.startsWith(':nth-match(')))
            parts.push('>>');
        lastEngine = engine;
        if (engine === 'css')
            parts.push(selector);
        else
            parts.push(\`\${engine}=\${selector}\`);
    }
    return parts.join(' ');
}
function combineScores(tokens) {
    let score = 0;
    for (let i = 0; i < tokens.length; i++)
        score += tokens[i].score * (tokens.length - i);
    return score;
}
function chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {
    const joined = selectors.map(tokens => ({ tokens, score: combineScores(tokens) }));
    joined.sort((a, b) => a.score - b.score);
    let bestWithIndex = null;
    for (const { tokens } of joined) {
        const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));
        const result = injectedScript.querySelectorAll(parsedSelector, scope);
        const index = result.indexOf(targetElement);
        if (index === 0) {
            // We are the first match - found the best selector.
            return tokens;
        }
        // Otherwise, perhaps we can get nth-match?
        if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)
            continue;
        // To use nth-match, we must convert everything to css.
        const allCss = tokens.map(token => {
            if (token.engine !== 'text')
                return token;
            if (token.selector.startsWith('/') && token.selector.endsWith('/'))
                return { engine: 'css', selector: \`:text-matches("\${token.selector.substring(1, token.selector.length - 1)}")\`, score: token.score };
            return { engine: 'css', selector: \`:text("\${token.selector}")\`, score: token.score };
        });
        const combined = joinTokens(allCss);
        bestWithIndex = [{ engine: 'css', selector: \`:nth-match(\${combined}, \${index + 1})\`, score: combineScores(allCss) + 1000 }];
    }
    return bestWithIndex;
}
function isGuidLike(id) {
    let lastCharacterType;
    let transitionCount = 0;
    for (let i = 0; i < id.length; ++i) {
        const c = id[i];
        let characterType;
        if (c === '-' || c === '_')
            continue;
        if (c >= 'a' && c <= 'z')
            characterType = 'lower';
        else if (c >= 'A' && c <= 'Z')
            characterType = 'upper';
        else if (c >= '0' && c <= '9')
            characterType = 'digit';
        else
            characterType = 'other';
        if (characterType === 'lower' && lastCharacterType === 'upper') {
            lastCharacterType = characterType;
            continue;
        }
        if (lastCharacterType && lastCharacterType !== characterType)
            ++transitionCount;
        lastCharacterType = characterType;
    }
    return transitionCount >= id.length / 4;
}


/***/ })

/******/ })["default"];`;
  }
});

// node_modules/playwright/lib/server/supplements/recorder/recorderApp.js
var require_recorderApp = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/recorderApp.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.RecorderApp = void 0;
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var util = __importStar(require("util"));
    var progress_1 = require_progress();
    var events_1 = require("events");
    var instrumentation_1 = require_instrumentation();
    var utils_1 = require_utils();
    var readFileAsync = util.promisify(fs_1.default.readFile);
    var existsAsync = (path) => new Promise((resolve2) => fs_1.default.stat(path, (err) => resolve2(!err)));
    var RecorderApp = class extends events_1.EventEmitter {
      constructor(page, wsEndpoint) {
        super();
        this.setMaxListeners(0);
        this._page = page;
        this.wsEndpoint = wsEndpoint;
      }
      async close() {
        await this._page.context().close(instrumentation_1.internalCallMetadata());
      }
      async _init() {
        const icon = await readFileAsync(require.resolve("../../../web/recorder/app_icon.png"));
        const crPopup = this._page._delegate;
        await crPopup._mainFrameSession._client.send("Browser.setDockTile", {
          image: icon.toString("base64")
        });
        await this._page._setServerRequestInterceptor(async (route) => {
          if (route.request().url().startsWith("https://playwright/")) {
            const uri = route.request().url().substring("https://playwright/".length);
            const file = require.resolve("../../../web/recorder/" + uri);
            const buffer = await readFileAsync(file);
            await route.fulfill({
              status: 200,
              headers: [
                {name: "Content-Type", value: extensionToMime[path_1.default.extname(file)]}
              ],
              body: buffer.toString("base64"),
              isBase64: true
            });
            return;
          }
          await route.continue();
        });
        await this._page.exposeBinding("dispatch", false, (_, data) => this.emit("event", data));
        this._page.once("close", () => {
          this.emit("close");
          this._page.context().close(instrumentation_1.internalCallMetadata()).catch((e) => console.error(e));
        });
        const mainFrame = this._page.mainFrame();
        await mainFrame.goto(instrumentation_1.internalCallMetadata(), "https://playwright/index.html");
      }
      static async open(inspectedContext) {
        const recorderPlaywright = require_playwright().createPlaywright(true);
        const args = [
          "--app=data:text/html,",
          "--window-size=600,600",
          "--window-position=1280,10"
        ];
        if (process.env.PWTEST_RECORDER_PORT)
          args.push(`--remote-debugging-port=${process.env.PWTEST_RECORDER_PORT}`);
        let channel;
        let executablePath;
        if (inspectedContext._browser.options.isChromium) {
          channel = inspectedContext._browser.options.channel;
          const defaultExecutablePath = recorderPlaywright.chromium.executablePath(channel);
          if (!await existsAsync(defaultExecutablePath))
            executablePath = inspectedContext._browser.options.customExecutablePath;
        }
        const context = await recorderPlaywright.chromium.launchPersistentContext(instrumentation_1.internalCallMetadata(), "", {
          channel,
          executablePath,
          sdkLanguage: inspectedContext._options.sdkLanguage,
          args,
          noDefaultViewport: true,
          headless: !!process.env.PWTEST_CLI_HEADLESS || utils_1.isUnderTest() && !inspectedContext._browser.options.headful,
          useWebSocket: !!process.env.PWTEST_RECORDER_PORT
        });
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), context._browser);
        await controller.run(async (progress) => {
          await context._browser._defaultContext._loadDefaultContextAsIs(progress);
        });
        const [page] = context.pages();
        const result = new RecorderApp(page, context._browser.options.wsEndpoint);
        await result._init();
        return result;
      }
      async setMode(mode) {
        await this._page.mainFrame().evaluateExpression(((mode2) => {
          window.playwrightSetMode(mode2);
        }).toString(), true, mode, "main").catch(() => {
        });
      }
      async setFile(file) {
        await this._page.mainFrame().evaluateExpression(((file2) => {
          window.playwrightSetFile(file2);
        }).toString(), true, file, "main").catch(() => {
        });
      }
      async setPaused(paused) {
        await this._page.mainFrame().evaluateExpression(((paused2) => {
          window.playwrightSetPaused(paused2);
        }).toString(), true, paused, "main").catch(() => {
        });
      }
      async setSources(sources) {
        await this._page.mainFrame().evaluateExpression(((sources2) => {
          window.playwrightSetSources(sources2);
        }).toString(), true, sources, "main").catch(() => {
        });
        {
          if (process.env.PWTEST_CLI_EXIT && sources.length) {
            process.stdout.write("\n-------------8<-------------\n");
            process.stdout.write(sources[0].text);
            process.stdout.write("\n-------------8<-------------\n");
          }
        }
      }
      async setSelector(selector, focus) {
        await this._page.mainFrame().evaluateExpression(((arg) => {
          window.playwrightSetSelector(arg.selector, arg.focus);
        }).toString(), true, {selector, focus}, "main").catch(() => {
        });
      }
      async updateCallLogs(callLogs) {
        await this._page.mainFrame().evaluateExpression(((callLogs2) => {
          window.playwrightUpdateLogs(callLogs2);
        }).toString(), true, callLogs, "main").catch(() => {
        });
      }
      async bringToFront() {
        await this._page.bringToFront();
      }
    };
    exports2.RecorderApp = RecorderApp;
    var extensionToMime = {
      ".css": "text/css",
      ".html": "text/html",
      ".jpeg": "image/jpeg",
      ".js": "application/javascript",
      ".png": "image/png",
      ".ttf": "font/ttf",
      ".svg": "image/svg+xml",
      ".webp": "image/webp",
      ".woff": "font/woff",
      ".woff2": "font/woff2"
    };
  }
});

// node_modules/playwright/lib/utils/httpServer.js
var require_httpServer = __commonJS({
  "node_modules/playwright/lib/utils/httpServer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.HttpServer = void 0;
    var http2 = __importStar(require("http"));
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var HttpServer = class {
      constructor() {
        this._routes = [];
        this._urlPrefix = "";
      }
      routePrefix(prefix, handler2) {
        this._routes.push({prefix, handler: handler2});
      }
      routePath(path, handler2) {
        this._routes.push({exact: path, handler: handler2});
      }
      async start(port) {
        this._server = http2.createServer(this._onRequest.bind(this));
        this._server.listen(port);
        await new Promise((cb) => this._server.once("listening", cb));
        const address = this._server.address();
        this._urlPrefix = typeof address === "string" ? address : `http://127.0.0.1:${address.port}`;
        return this._urlPrefix;
      }
      async stop() {
        await new Promise((cb) => this._server.close(cb));
      }
      urlPrefix() {
        return this._urlPrefix;
      }
      serveFile(response, absoluteFilePath, headers) {
        try {
          const content = fs_1.default.readFileSync(absoluteFilePath);
          response.statusCode = 200;
          const contentType = extensionToMime[path_1.default.extname(absoluteFilePath).substring(1)] || "application/octet-stream";
          response.setHeader("Content-Type", contentType);
          response.setHeader("Content-Length", content.byteLength);
          for (const [name, value] of Object.entries(headers || {}))
            response.setHeader(name, value);
          response.end(content);
          return true;
        } catch (e) {
          return false;
        }
      }
      _onRequest(request, response) {
        request.on("error", () => response.end());
        try {
          if (!request.url) {
            response.end();
            return;
          }
          const url = new URL("http://localhost" + request.url);
          for (const route of this._routes) {
            if (route.exact && url.pathname === route.exact && route.handler(request, response))
              return;
            if (route.prefix && url.pathname.startsWith(route.prefix) && route.handler(request, response))
              return;
          }
          response.statusCode = 404;
          response.end();
        } catch (e) {
          response.end();
        }
      }
    };
    exports2.HttpServer = HttpServer;
    var extensionToMime = {
      "css": "text/css",
      "html": "text/html",
      "jpeg": "image/jpeg",
      "jpg": "image/jpeg",
      "js": "application/javascript",
      "png": "image/png",
      "ttf": "font/ttf",
      "svg": "image/svg+xml",
      "webp": "image/webp",
      "woff": "font/woff",
      "woff2": "font/woff2"
    };
  }
});

// node_modules/playwright/lib/server/snapshot/snapshotServer.js
var require_snapshotServer = __commonJS({
  "node_modules/playwright/lib/server/snapshot/snapshotServer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.SnapshotServer = void 0;
    var querystring_1 = __importDefault(require("querystring"));
    var SnapshotServer = class {
      constructor(server, snapshotStorage) {
        this._snapshotStorage = snapshotStorage;
        server.routePrefix("/snapshot/", this._serveSnapshot.bind(this));
        server.routePrefix("/resources/", this._serveResource.bind(this));
      }
      _serveSnapshotRoot(request, response) {
        response.statusCode = 200;
        response.setHeader("Cache-Control", "public, max-age=31536000");
        response.setHeader("Content-Type", "text/html");
        response.end(`
      <style>
        html, body {
          margin: 0;
          padding: 0;
        }
        iframe {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border: none;
        }
      </style>
      <body>
        <script>
        (${rootScript})();
        </script>
      </body>
    `);
        return true;
      }
      _serveServiceWorker(request, response) {
        function serviceWorkerMain(self2) {
          const snapshotResources = new Map();
          self2.addEventListener("install", function(event) {
          });
          self2.addEventListener("activate", function(event) {
            event.waitUntil(self2.clients.claim());
          });
          function respond404() {
            return new Response(null, {status: 404});
          }
          function respondNotAvailable() {
            return new Response('<body style="background: #ddd"></body>', {status: 200, headers: {"Content-Type": "text/html"}});
          }
          function removeHash(url) {
            try {
              const u = new URL(url);
              u.hash = "";
              return u.toString();
            } catch (e) {
              return url;
            }
          }
          async function doFetch(event) {
            const request2 = event.request;
            const pathname = new URL(request2.url).pathname;
            if (pathname === "/snapshot/service-worker.js" || pathname === "/snapshot/")
              return fetch(event.request);
            const snapshotUrl = request2.mode === "navigate" ? request2.url : (await self2.clients.get(event.clientId)).url;
            if (request2.mode === "navigate") {
              const htmlResponse = await fetch(event.request);
              const {html, resources: resources2} = await htmlResponse.json();
              if (!html)
                return respondNotAvailable();
              snapshotResources.set(snapshotUrl, resources2);
              const response3 = new Response(html, {status: 200, headers: {"Content-Type": "text/html"}});
              return response3;
            }
            const resources = snapshotResources.get(snapshotUrl);
            const urlWithoutHash = removeHash(request2.url);
            const resource = resources[urlWithoutHash];
            if (!resource)
              return respond404();
            const fetchUrl = resource.sha1 ? `/resources/${resource.resourceId}/override/${resource.sha1}` : `/resources/${resource.resourceId}`;
            const fetchedResponse = await fetch(fetchUrl);
            const headers = new Headers(fetchedResponse.headers);
            if (resource.sha1) {
              headers.set("Cache-Control", "no-cache");
            }
            const response2 = new Response(fetchedResponse.body, {
              status: fetchedResponse.status,
              statusText: fetchedResponse.statusText,
              headers
            });
            return response2;
          }
          self2.addEventListener("fetch", function(event) {
            event.respondWith(doFetch(event));
          });
        }
        response.statusCode = 200;
        response.setHeader("Cache-Control", "public, max-age=31536000");
        response.setHeader("Content-Type", "application/javascript");
        response.end(`(${serviceWorkerMain.toString()})(self)`);
        return true;
      }
      _serveSnapshot(request, response) {
        if (request.url.endsWith("/snapshot/"))
          return this._serveSnapshotRoot(request, response);
        if (request.url.endsWith("/snapshot/service-worker.js"))
          return this._serveServiceWorker(request, response);
        response.statusCode = 200;
        response.setHeader("Cache-Control", "public, max-age=31536000");
        response.setHeader("Content-Type", "application/json");
        const [pageOrFrameId, query] = request.url.substring("/snapshot/".length).split("?");
        const parsed = querystring_1.default.parse(query);
        const snapshot = this._snapshotStorage.snapshotByName(pageOrFrameId, parsed.name);
        const snapshotData = snapshot ? snapshot.render() : {html: ""};
        response.end(JSON.stringify(snapshotData));
        return true;
      }
      _serveResource(request, response) {
        const parts = request.url.split("/");
        if (!parts[0])
          parts.shift();
        if (!parts[parts.length - 1])
          parts.pop();
        if (parts[0] !== "resources")
          return false;
        let resourceId;
        let overrideSha1;
        if (parts.length === 2) {
          resourceId = parts[1];
        } else if (parts.length === 4 && parts[2] === "override") {
          resourceId = parts[1];
          overrideSha1 = parts[3];
        } else {
          return false;
        }
        const resource = this._snapshotStorage.resourceById(resourceId);
        if (!resource)
          return false;
        const sha1 = overrideSha1 || resource.responseSha1;
        try {
          const content = this._snapshotStorage.resourceContent(sha1);
          if (!content)
            return false;
          response.statusCode = 200;
          let contentType = resource.contentType;
          const isTextEncoding = /^text\/|^application\/(javascript|json)/.test(contentType);
          if (isTextEncoding && !contentType.includes("charset"))
            contentType = `${contentType}; charset=utf-8`;
          response.setHeader("Content-Type", contentType);
          for (const {name, value} of resource.responseHeaders)
            response.setHeader(name, value);
          response.removeHeader("Content-Encoding");
          response.removeHeader("Access-Control-Allow-Origin");
          response.setHeader("Access-Control-Allow-Origin", "*");
          response.removeHeader("Content-Length");
          response.setHeader("Content-Length", content.byteLength);
          response.setHeader("Cache-Control", "public, max-age=31536000");
          response.end(content);
          return true;
        } catch (e) {
          return false;
        }
      }
    };
    exports2.SnapshotServer = SnapshotServer;
    function rootScript() {
      if (!navigator.serviceWorker)
        return;
      navigator.serviceWorker.register("./service-worker.js");
      let showPromise = Promise.resolve();
      if (!navigator.serviceWorker.controller) {
        showPromise = new Promise((resolve2) => {
          navigator.serviceWorker.oncontrollerchange = () => resolve2();
        });
      }
      const pointElement = document.createElement("div");
      pointElement.style.position = "fixed";
      pointElement.style.backgroundColor = "red";
      pointElement.style.width = "20px";
      pointElement.style.height = "20px";
      pointElement.style.borderRadius = "10px";
      pointElement.style.margin = "-10px 0 0 -10px";
      pointElement.style.zIndex = "2147483647";
      let current = document.createElement("iframe");
      document.body.appendChild(current);
      let next = document.createElement("iframe");
      document.body.appendChild(next);
      next.style.visibility = "hidden";
      const onload = () => {
        const temp = current;
        current = next;
        next = temp;
        current.style.visibility = "visible";
        next.style.visibility = "hidden";
      };
      current.onload = onload;
      next.onload = onload;
      window.showSnapshot = async (url, options2 = {}) => {
        await showPromise;
        next.src = url;
        if (options2.point) {
          pointElement.style.left = options2.point.x + "px";
          pointElement.style.top = options2.point.y + "px";
          document.documentElement.appendChild(pointElement);
        } else {
          pointElement.remove();
        }
      };
      window.addEventListener("message", (event) => {
        window.showSnapshot(window.location.href + event.data.snapshotUrl);
      }, false);
    }
  }
});

// node_modules/playwright/lib/server/snapshot/snapshotRenderer.js
var require_snapshotRenderer = __commonJS({
  "node_modules/playwright/lib/server/snapshot/snapshotRenderer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.SnapshotRenderer = void 0;
    var SnapshotRenderer = class {
      constructor(contextResources, snapshots, index2) {
        this._contextResources = contextResources;
        this._snapshots = snapshots;
        this._index = index2;
        this.snapshotName = snapshots[index2].snapshotName;
      }
      snapshot() {
        return this._snapshots[this._index];
      }
      render() {
        const visit = (n, snapshotIndex) => {
          if (typeof n === "string")
            return escapeText(n);
          if (!n._string) {
            if (Array.isArray(n[0])) {
              const referenceIndex = snapshotIndex - n[0][0];
              if (referenceIndex >= 0 && referenceIndex < snapshotIndex) {
                const nodes = snapshotNodes(this._snapshots[referenceIndex]);
                const nodeIndex = n[0][1];
                if (nodeIndex >= 0 && nodeIndex < nodes.length)
                  n._string = visit(nodes[nodeIndex], referenceIndex);
              }
            } else if (typeof n[0] === "string") {
              const builder = [];
              builder.push("<", n[0]);
              for (const [attr, value] of Object.entries(n[1] || {}))
                builder.push(" ", attr, '="', escapeAttribute(value), '"');
              builder.push(">");
              for (let i = 2; i < n.length; i++)
                builder.push(visit(n[i], snapshotIndex));
              if (!autoClosing.has(n[0]))
                builder.push("</", n[0], ">");
              n._string = builder.join("");
            } else {
              n._string = "";
            }
          }
          return n._string;
        };
        const snapshot = this._snapshots[this._index];
        let html = visit(snapshot.html, this._index);
        if (!html)
          return {html: "", resources: {}};
        if (snapshot.doctype)
          html = `<!DOCTYPE ${snapshot.doctype}>` + html;
        html += `
      <style>*[__playwright_target__="${this.snapshotName}"] { background-color: #6fa8dc7f; }</style>
      <script>${snapshotScript()}</script>
    `;
        const resources = {};
        for (const [url, contextResources] of this._contextResources) {
          const contextResource = contextResources.find((r) => r.frameId === snapshot.frameId) || contextResources[0];
          if (contextResource)
            resources[url] = {resourceId: contextResource.resourceId};
        }
        for (const o of snapshot.resourceOverrides) {
          const resource = resources[o.url];
          resource.sha1 = o.sha1;
        }
        return {html, resources};
      }
    };
    exports2.SnapshotRenderer = SnapshotRenderer;
    var autoClosing = new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "MENUITEM", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);
    var escaped3 = {"&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"};
    function escapeAttribute(s2) {
      return s2.replace(/[&<>"']/ug, (char) => escaped3[char]);
    }
    function escapeText(s2) {
      return s2.replace(/[&<]/ug, (char) => escaped3[char]);
    }
    function snapshotNodes(snapshot) {
      if (!snapshot._nodes) {
        const nodes = [];
        const visit = (n) => {
          if (typeof n === "string") {
            nodes.push(n);
          } else if (typeof n[0] === "string") {
            for (let i = 2; i < n.length; i++)
              visit(n[i]);
            nodes.push(n);
          }
        };
        visit(snapshot.html);
        snapshot._nodes = nodes;
      }
      return snapshot._nodes;
    }
    function snapshotScript() {
      function applyPlaywrightAttributes(shadowAttribute, scrollTopAttribute, scrollLeftAttribute) {
        const scrollTops = [];
        const scrollLefts = [];
        const visit = (root) => {
          for (const e of root.querySelectorAll(`[${scrollTopAttribute}]`))
            scrollTops.push(e);
          for (const e of root.querySelectorAll(`[${scrollLeftAttribute}]`))
            scrollLefts.push(e);
          for (const iframe of root.querySelectorAll("iframe")) {
            const src2 = iframe.getAttribute("src");
            if (!src2) {
              iframe.setAttribute("src", 'data:text/html,<body style="background: #ddd"></body>');
            } else {
              iframe.setAttribute("src", window.location.origin + src2 + window.location.search);
            }
          }
          for (const element of root.querySelectorAll(`template[${shadowAttribute}]`)) {
            const template2 = element;
            const shadowRoot = template2.parentElement.attachShadow({mode: "open"});
            shadowRoot.appendChild(template2.content);
            template2.remove();
            visit(shadowRoot);
          }
        };
        visit(document);
        const onLoad = () => {
          window.removeEventListener("load", onLoad);
          for (const element of scrollTops) {
            element.scrollTop = +element.getAttribute(scrollTopAttribute);
            element.removeAttribute(scrollTopAttribute);
          }
          for (const element of scrollLefts) {
            element.scrollLeft = +element.getAttribute(scrollLeftAttribute);
            element.removeAttribute(scrollLeftAttribute);
          }
        };
        window.addEventListener("load", onLoad);
      }
      const kShadowAttribute = "__playwright_shadow_root_";
      const kScrollTopAttribute = "__playwright_scroll_top_";
      const kScrollLeftAttribute = "__playwright_scroll_left_";
      return `
(${applyPlaywrightAttributes.toString()})('${kShadowAttribute}', '${kScrollTopAttribute}', '${kScrollLeftAttribute}')`;
    }
  }
});

// node_modules/playwright/lib/server/snapshot/snapshotStorage.js
var require_snapshotStorage = __commonJS({
  "node_modules/playwright/lib/server/snapshot/snapshotStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BaseSnapshotStorage = void 0;
    var events_1 = require("events");
    var snapshotRenderer_1 = require_snapshotRenderer();
    var BaseSnapshotStorage = class extends events_1.EventEmitter {
      constructor() {
        super(...arguments);
        this._resources = [];
        this._resourceMap = new Map();
        this._frameSnapshots = new Map();
        this._contextResources = new Map();
      }
      clear() {
        this._resources = [];
        this._resourceMap.clear();
        this._frameSnapshots.clear();
        this._contextResources.clear();
      }
      addResource(resource) {
        this._resourceMap.set(resource.resourceId, resource);
        this._resources.push(resource);
        let resources = this._contextResources.get(resource.url);
        if (!resources) {
          resources = [];
          this._contextResources.set(resource.url, resources);
        }
        resources.push({frameId: resource.frameId, resourceId: resource.resourceId});
      }
      addFrameSnapshot(snapshot) {
        let frameSnapshots = this._frameSnapshots.get(snapshot.frameId);
        if (!frameSnapshots) {
          frameSnapshots = {
            raw: [],
            renderer: []
          };
          this._frameSnapshots.set(snapshot.frameId, frameSnapshots);
          if (snapshot.isMainFrame)
            this._frameSnapshots.set(snapshot.pageId, frameSnapshots);
        }
        frameSnapshots.raw.push(snapshot);
        const renderer = new snapshotRenderer_1.SnapshotRenderer(new Map(this._contextResources), frameSnapshots.raw, frameSnapshots.raw.length - 1);
        frameSnapshots.renderer.push(renderer);
        this.emit("snapshot", renderer);
      }
      resourceById(resourceId) {
        return this._resourceMap.get(resourceId);
      }
      resources() {
        return this._resources.slice();
      }
      snapshotByName(pageOrFrameId, snapshotName) {
        const snapshot = this._frameSnapshots.get(pageOrFrameId);
        return snapshot === null || snapshot === void 0 ? void 0 : snapshot.renderer.find((r) => r.snapshotName === snapshotName);
      }
    };
    exports2.BaseSnapshotStorage = BaseSnapshotStorage;
  }
});

// node_modules/playwright/lib/server/snapshot/inMemorySnapshotter.js
var require_inMemorySnapshotter = __commonJS({
  "node_modules/playwright/lib/server/snapshot/inMemorySnapshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.InMemorySnapshotter = void 0;
    var httpServer_1 = require_httpServer();
    var helper_1 = require_helper();
    var snapshotServer_1 = require_snapshotServer();
    var snapshotStorage_1 = require_snapshotStorage();
    var snapshotter_1 = require_snapshotter();
    var InMemorySnapshotter = class extends snapshotStorage_1.BaseSnapshotStorage {
      constructor(context) {
        super();
        this._blobs = new Map();
        this._server = new httpServer_1.HttpServer();
        new snapshotServer_1.SnapshotServer(this._server, this);
        this._snapshotter = new snapshotter_1.Snapshotter(context, this);
      }
      async initialize() {
        await this._snapshotter.start();
        return await this._server.start();
      }
      async dispose() {
        this._snapshotter.dispose();
        await this._server.stop();
      }
      async captureSnapshot(page, snapshotName, element) {
        if (this._frameSnapshots.has(snapshotName))
          throw new Error("Duplicate snapshot name: " + snapshotName);
        this._snapshotter.captureSnapshot(page, snapshotName, element).catch(() => {
        });
        return new Promise((fulfill) => {
          const listener = helper_1.helper.addEventListener(this, "snapshot", (renderer) => {
            if (renderer.snapshotName === snapshotName) {
              helper_1.helper.removeEventListeners([listener]);
              fulfill(renderer);
            }
          });
        });
      }
      onBlob(blob) {
        this._blobs.set(blob.sha1, blob.buffer);
      }
      onResourceSnapshot(resource) {
        this.addResource(resource);
      }
      onFrameSnapshot(snapshot) {
        this.addFrameSnapshot(snapshot);
      }
      resourceContent(sha1) {
        return this._blobs.get(sha1);
      }
    };
    exports2.InMemorySnapshotter = InMemorySnapshotter;
  }
});

// node_modules/playwright/lib/server/supplements/recorder/recorderUtils.js
var require_recorderUtils = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorder/recorderUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.metadataToCallLog = void 0;
    function metadataToCallLog(metadata, status, snapshots) {
      var _a, _b;
      const title = metadata.apiName || metadata.method;
      if (metadata.error)
        status = "error";
      const params = {
        url: (_a = metadata.params) === null || _a === void 0 ? void 0 : _a.url,
        selector: (_b = metadata.params) === null || _b === void 0 ? void 0 : _b.selector
      };
      let duration = metadata.endTime ? metadata.endTime - metadata.startTime : void 0;
      if (typeof duration === "number" && metadata.pauseStartTime && metadata.pauseEndTime) {
        duration -= metadata.pauseEndTime - metadata.pauseStartTime;
        duration = Math.max(duration, 0);
      }
      const callLog = {
        id: metadata.id,
        messages: metadata.log,
        title,
        status,
        error: metadata.error,
        params,
        duration,
        snapshots: {
          before: showBeforeSnapshot(metadata) && snapshots.has(`before@${metadata.id}`),
          action: showActionSnapshot(metadata) && snapshots.has(`action@${metadata.id}`),
          after: showAfterSnapshot(metadata) && snapshots.has(`after@${metadata.id}`)
        }
      };
      return callLog;
    }
    exports2.metadataToCallLog = metadataToCallLog;
    function showBeforeSnapshot(metadata) {
      return metadata.method === "close";
    }
    function showActionSnapshot(metadata) {
      return ["click", "dblclick", "check", "uncheck", "fill", "press"].includes(metadata.method);
    }
    function showAfterSnapshot(metadata) {
      return ["goto", "click", "dblclick", "dblclick", "check", "uncheck", "fill", "press"].includes(metadata.method);
    }
  }
});

// node_modules/playwright/lib/server/supplements/recorderSupplement.js
var require_recorderSupplement = __commonJS({
  "node_modules/playwright/lib/server/supplements/recorderSupplement.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.RecorderSupplement = void 0;
    var fs = __importStar(require("fs"));
    var codeGenerator_1 = require_codeGenerator();
    var utils_1 = require_utils2();
    var page_1 = require_page();
    var frames_1 = require_frames();
    var browserContext_1 = require_browserContext();
    var java_1 = require_java();
    var javascript_1 = require_javascript2();
    var csharp_1 = require_csharp();
    var python_1 = require_python();
    var recorderSource = __importStar(require_recorderSource());
    var consoleApiSource = __importStar(require_consoleApiSource());
    var recorderApp_1 = require_recorderApp();
    var instrumentation_1 = require_instrumentation();
    var utils_2 = require_utils();
    var inMemorySnapshotter_1 = require_inMemorySnapshotter();
    var recorderUtils_1 = require_recorderUtils();
    var debugger_1 = require_debugger();
    var symbol = Symbol("RecorderSupplement");
    var RecorderSupplement = class {
      constructor(context, params) {
        this._pageAliases = new Map();
        this._lastPopupOrdinal = 0;
        this._lastDialogOrdinal = 0;
        this._timers = new Set();
        this._highlightedSelector = "";
        this._recorderApp = null;
        this._currentCallsMetadata = new Map();
        this._userSources = new Map();
        this._snapshots = new Set();
        this._allMetadatas = new Map();
        this._context = context;
        this._debugger = debugger_1.Debugger.lookup(context);
        context.instrumentation.addListener(this);
        this._params = params;
        this._mode = params.startRecording ? "recording" : "none";
        const language = params.language || context._options.sdkLanguage;
        const languages = new Set([
          new java_1.JavaLanguageGenerator(),
          new javascript_1.JavaScriptLanguageGenerator(),
          new python_1.PythonLanguageGenerator(false),
          new python_1.PythonLanguageGenerator(true),
          new csharp_1.CSharpLanguageGenerator()
        ]);
        const primaryLanguage = [...languages].find((l) => l.id === language);
        if (!primaryLanguage)
          throw new Error(`
===============================
Unsupported language: '${language}'
===============================
`);
        languages.delete(primaryLanguage);
        const orderedLanguages = [primaryLanguage, ...languages];
        this._recorderSources = [];
        const generator = new codeGenerator_1.CodeGenerator(context._browser.options.name, !!params.startRecording, params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);
        let text = "";
        generator.on("change", () => {
          var _a;
          this._recorderSources = [];
          for (const languageGenerator of orderedLanguages) {
            const source = {
              file: languageGenerator.fileName,
              text: generator.generateText(languageGenerator),
              language: languageGenerator.highlighter,
              highlight: []
            };
            source.revealLine = source.text.split("\n").length - 1;
            this._recorderSources.push(source);
            if (languageGenerator === orderedLanguages[0])
              text = source.text;
          }
          this._pushAllSources();
          (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setFile(primaryLanguage.fileName);
        });
        if (params.outputFile) {
          context.on(browserContext_1.BrowserContext.Events.BeforeClose, () => {
            fs.writeFileSync(params.outputFile, text);
            text = "";
          });
          process.on("exit", () => {
            if (text)
              fs.writeFileSync(params.outputFile, text);
          });
        }
        this._generator = generator;
        this._snapshotter = new inMemorySnapshotter_1.InMemorySnapshotter(context);
      }
      static showInspector(context) {
        RecorderSupplement.show(context, {}).catch(() => {
        });
      }
      static show(context, params = {}) {
        let recorderPromise = context[symbol];
        if (!recorderPromise) {
          const recorder = new RecorderSupplement(context, params);
          recorderPromise = recorder.install().then(() => recorder);
          context[symbol] = recorderPromise;
        }
        return recorderPromise;
      }
      async install() {
        const recorderApp = await recorderApp_1.RecorderApp.open(this._context);
        this._recorderApp = recorderApp;
        recorderApp.once("close", () => {
          this._snapshotter.dispose().catch(() => {
          });
          this._recorderApp = null;
        });
        recorderApp.on("event", (data) => {
          if (data.event === "setMode") {
            this._setMode(data.params.mode);
            this._refreshOverlay();
            return;
          }
          if (data.event === "selectorUpdated") {
            this._highlightedSelector = data.params.selector;
            this._refreshOverlay();
            return;
          }
          if (data.event === "callLogHovered") {
            this._hoveredSnapshot = void 0;
            if (this._debugger.isPaused() && data.params.callLogId)
              this._hoveredSnapshot = data.params;
            this._refreshOverlay();
            return;
          }
          if (data.event === "step") {
            this._debugger.resume(true);
            return;
          }
          if (data.event === "resume") {
            this._debugger.resume(false);
            return;
          }
          if (data.event === "pause") {
            this._debugger.pauseOnNextStatement();
            return;
          }
          if (data.event === "clear") {
            this._clearScript();
            return;
          }
        });
        await Promise.all([
          recorderApp.setMode(this._mode),
          recorderApp.setPaused(this._debugger.isPaused()),
          this._pushAllSources()
        ]);
        this._context.on(browserContext_1.BrowserContext.Events.Page, (page) => this._onPage(page));
        for (const page of this._context.pages())
          this._onPage(page);
        this._context.once(browserContext_1.BrowserContext.Events.Close, () => {
          for (const timer of this._timers)
            clearTimeout(timer);
          this._timers.clear();
          recorderApp.close().catch(() => {
          });
        });
        await this._context.exposeBinding("_playwrightRecorderPerformAction", false, (source, action) => this._performAction(source.frame, action));
        await this._context.exposeBinding("_playwrightRecorderRecordAction", false, (source, action) => this._recordAction(source.frame, action));
        await this._context.exposeBinding("_playwrightRecorderState", false, (source) => {
          let snapshotUrl;
          let actionSelector = this._highlightedSelector;
          let actionPoint;
          if (this._hoveredSnapshot) {
            const metadata = this._allMetadatas.get(this._hoveredSnapshot.callLogId);
            snapshotUrl = `${metadata.pageId}?name=${this._hoveredSnapshot.phase}@${this._hoveredSnapshot.callLogId}`;
            actionPoint = this._hoveredSnapshot.phase === "action" ? metadata === null || metadata === void 0 ? void 0 : metadata.point : void 0;
          } else {
            for (const [metadata, sdkObject] of this._currentCallsMetadata) {
              if (source.page === sdkObject.attribution.page) {
                actionPoint = metadata.point || actionPoint;
                actionSelector = actionSelector || metadata.params.selector;
              }
            }
          }
          const uiState = {
            mode: this._mode,
            actionPoint,
            actionSelector,
            snapshotUrl
          };
          return uiState;
        });
        await this._context.exposeBinding("_playwrightRecorderSetSelector", false, async (_, selector) => {
          var _a, _b;
          this._setMode("none");
          await ((_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setSelector(selector, true));
          await ((_b = this._recorderApp) === null || _b === void 0 ? void 0 : _b.bringToFront());
        });
        await this._context.exposeBinding("_playwrightResume", false, () => {
          this._debugger.resume(false);
        });
        const snapshotBaseUrl = await this._snapshotter.initialize() + "/snapshot/";
        await this._context.extendInjectedScript(recorderSource.source, {isUnderTest: utils_2.isUnderTest(), snapshotBaseUrl});
        await this._context.extendInjectedScript(consoleApiSource.source);
        if (this._debugger.isPaused())
          this._pausedStateChanged();
        this._debugger.on(debugger_1.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
        this._context.recorderAppForTest = recorderApp;
      }
      _pausedStateChanged() {
        for (const {metadata, sdkObject} of this._debugger.pausedDetails()) {
          if (!this._currentCallsMetadata.has(metadata))
            this.onBeforeCall(sdkObject, metadata);
        }
        this._recorderApp.setPaused(this._debugger.isPaused());
        this._updateUserSources();
        this.updateCallLog([...this._currentCallsMetadata.keys()]);
      }
      _setMode(mode) {
        var _a;
        this._mode = mode;
        (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setMode(this._mode);
        this._generator.setEnabled(this._mode === "recording");
        if (this._mode !== "none")
          this._context.pages()[0].bringToFront().catch(() => {
          });
      }
      _refreshOverlay() {
        for (const page of this._context.pages())
          page.mainFrame().evaluateExpression("window._playwrightRefreshOverlay()", false, void 0, "main").catch(() => {
          });
      }
      async _onPage(page) {
        const frame = page.mainFrame();
        page.on("close", () => {
          this._pageAliases.delete(page);
          this._generator.addAction({
            pageAlias,
            ...utils_1.describeFrame(page.mainFrame()),
            committed: true,
            action: {
              name: "closePage",
              signals: []
            }
          });
        });
        frame.on(frames_1.Frame.Events.Navigation, () => this._onFrameNavigated(frame, page));
        page.on(page_1.Page.Events.Download, () => this._onDownload(page));
        page.on(page_1.Page.Events.Dialog, () => this._onDialog(page));
        const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
        const pageAlias = "page" + suffix;
        this._pageAliases.set(page, pageAlias);
        if (page.opener()) {
          this._onPopup(page.opener(), page);
        } else {
          this._generator.addAction({
            pageAlias,
            ...utils_1.describeFrame(page.mainFrame()),
            committed: true,
            action: {
              name: "openPage",
              url: page.mainFrame().url(),
              signals: []
            }
          });
        }
      }
      _clearScript() {
        this._generator.restart();
        if (!!this._params.startRecording) {
          for (const page of this._context.pages())
            this._onFrameNavigated(page.mainFrame(), page);
        }
      }
      async _performAction(frame, action) {
        this._generator.commitLastAction();
        const page = frame._page;
        const actionInContext = {
          pageAlias: this._pageAliases.get(page),
          ...utils_1.describeFrame(frame),
          action
        };
        this._generator.willPerformAction(actionInContext);
        const noCallMetadata = instrumentation_1.internalCallMetadata();
        try {
          const kActionTimeout = 5e3;
          if (action.name === "click") {
            const {options: options2} = utils_1.toClickOptions(action);
            await frame.click(noCallMetadata, action.selector, {...options2, timeout: kActionTimeout});
          }
          if (action.name === "press") {
            const modifiers = utils_1.toModifiers(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            await frame.press(noCallMetadata, action.selector, shortcut, {timeout: kActionTimeout});
          }
          if (action.name === "check")
            await frame.check(noCallMetadata, action.selector, {timeout: kActionTimeout});
          if (action.name === "uncheck")
            await frame.uncheck(noCallMetadata, action.selector, {timeout: kActionTimeout});
          if (action.name === "select")
            await frame.selectOption(noCallMetadata, action.selector, [], action.options.map((value) => ({value})), {timeout: kActionTimeout});
        } catch (e) {
          this._generator.performedActionFailed(actionInContext);
          return;
        }
        const timer = setTimeout(() => {
          actionInContext.committed = true;
          this._timers.delete(timer);
        }, 5e3);
        this._generator.didPerformAction(actionInContext);
        this._timers.add(timer);
      }
      async _recordAction(frame, action) {
        this._generator.commitLastAction();
        this._generator.addAction({
          pageAlias: this._pageAliases.get(frame._page),
          ...utils_1.describeFrame(frame),
          action
        });
      }
      _onFrameNavigated(frame, page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, frame, {name: "navigation", url: frame.url()});
      }
      _onPopup(page, popup) {
        const pageAlias = this._pageAliases.get(page);
        const popupAlias = this._pageAliases.get(popup);
        this._generator.signal(pageAlias, page.mainFrame(), {name: "popup", popupAlias});
      }
      _onDownload(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {name: "download"});
      }
      _onDialog(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {name: "dialog", dialogAlias: String(++this._lastDialogOrdinal)});
      }
      _captureSnapshot(sdkObject, metadata, phase) {
        if (sdkObject.attribution.page) {
          const snapshotName = `${phase}@${metadata.id}`;
          this._snapshots.add(snapshotName);
          this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName);
        }
      }
      async onBeforeCall(sdkObject, metadata) {
        var _a;
        if (this._mode === "recording")
          return;
        this._captureSnapshot(sdkObject, metadata, "before");
        this._currentCallsMetadata.set(metadata, sdkObject);
        this._allMetadatas.set(metadata.id, metadata);
        this._updateUserSources();
        this.updateCallLog([metadata]);
        if (metadata.params && metadata.params.selector) {
          this._highlightedSelector = metadata.params.selector;
          (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setSelector(this._highlightedSelector).catch(() => {
          });
        }
      }
      async onAfterCall(sdkObject, metadata) {
        if (this._mode === "recording")
          return;
        this._captureSnapshot(sdkObject, metadata, "after");
        if (!metadata.error)
          this._currentCallsMetadata.delete(metadata);
        this._updateUserSources();
        this.updateCallLog([metadata]);
      }
      _updateUserSources() {
        var _a;
        for (const source of this._userSources.values()) {
          source.highlight = [];
          source.revealLine = void 0;
        }
        let fileToSelect = void 0;
        for (const metadata of this._currentCallsMetadata.keys()) {
          if (!metadata.stack || !metadata.stack[0])
            continue;
          const {file, line} = metadata.stack[0];
          let source = this._userSources.get(file);
          if (!source) {
            source = {file, text: this._readSource(file), highlight: [], language: languageForFile(file)};
            this._userSources.set(file, source);
          }
          if (line) {
            const paused = this._debugger.isPaused(metadata);
            source.highlight.push({line, type: metadata.error ? "error" : paused ? "paused" : "running"});
            source.revealLine = line;
            fileToSelect = source.file;
          }
        }
        this._pushAllSources();
        if (fileToSelect)
          (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setFile(fileToSelect);
      }
      _pushAllSources() {
        var _a;
        (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.setSources([...this._recorderSources, ...this._userSources.values()]);
      }
      async onBeforeInputAction(sdkObject, metadata) {
        if (this._mode === "recording")
          return;
        this._captureSnapshot(sdkObject, metadata, "action");
      }
      async onCallLog(logName, message, sdkObject, metadata) {
        this.updateCallLog([metadata]);
      }
      updateCallLog(metadatas) {
        var _a;
        if (this._mode === "recording")
          return;
        const logs = [];
        for (const metadata of metadatas) {
          if (!metadata.method)
            continue;
          let status = "done";
          if (this._currentCallsMetadata.has(metadata))
            status = "in-progress";
          if (this._debugger.isPaused(metadata))
            status = "paused";
          logs.push(recorderUtils_1.metadataToCallLog(metadata, status, this._snapshots));
        }
        (_a = this._recorderApp) === null || _a === void 0 ? void 0 : _a.updateCallLogs(logs);
      }
      _readSource(fileName) {
        try {
          return fs.readFileSync(fileName, "utf-8");
        } catch (e) {
          return "// No source available";
        }
      }
    };
    exports2.RecorderSupplement = RecorderSupplement;
    function languageForFile(file) {
      if (file.endsWith(".py"))
        return "python";
      if (file.endsWith(".java"))
        return "java";
      if (file.endsWith(".cs"))
        return "csharp";
      return "javascript";
    }
  }
});

// node_modules/playwright/lib/server/browserContext.js
var require_browserContext = __commonJS({
  "node_modules/playwright/lib/server/browserContext.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.normalizeProxySettings = exports2.verifyGeolocation = exports2.validateBrowserContextOptions = exports2.assertBrowserContextIsNotOwned = exports2.BrowserContext = void 0;
    var os = __importStar(require("os"));
    var timeoutSettings_1 = require_timeoutSettings();
    var utils_1 = require_utils();
    var helper_1 = require_helper();
    var network = __importStar(require_network());
    var page_1 = require_page();
    var selectors_1 = require_selectors();
    var path_1 = __importDefault(require("path"));
    var instrumentation_1 = require_instrumentation();
    var debugger_1 = require_debugger();
    var tracing_1 = require_tracing();
    var harTracer_1 = require_harTracer();
    var recorderSupplement_1 = require_recorderSupplement();
    var consoleApiSource = __importStar(require_consoleApiSource());
    var BrowserContext = class extends instrumentation_1.SdkObject {
      constructor(browser, options2, browserContextId) {
        super(browser, "browser-context");
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._pageBindings = new Map();
        this._closedStatus = "open";
        this._permissions = new Map();
        this._downloads = new Set();
        this._origins = new Set();
        this.attribution.context = this;
        this._browser = browser;
        this._options = options2;
        this._browserContextId = browserContextId;
        this._isPersistentContext = !browserContextId;
        this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
        if (this._options.recordHar)
          this._harTracer = new harTracer_1.HarTracer(this, this._options.recordHar);
        this.tracing = new tracing_1.Tracing(this);
      }
      _setSelectors(selectors2) {
        this._selectors = selectors2;
      }
      selectors() {
        return this._selectors || selectors_1.serverSelectors;
      }
      async _initialize() {
        if (this.attribution.isInternal)
          return;
        this.instrumentation = instrumentation_1.createInstrumentation();
        const contextDebugger = new debugger_1.Debugger(this);
        this.instrumentation.addListener(contextDebugger);
        if (utils_1.debugMode() === "inspector")
          await recorderSupplement_1.RecorderSupplement.show(this, {pauseOnNextStatement: true});
        if (contextDebugger.isPaused())
          recorderSupplement_1.RecorderSupplement.showInspector(this);
        contextDebugger.on(debugger_1.Debugger.Events.PausedStateChanged, () => {
          recorderSupplement_1.RecorderSupplement.showInspector(this);
        });
        if (utils_1.debugMode() === "console")
          await this.extendInjectedScript(consoleApiSource.source);
      }
      async _ensureVideosPath() {
        if (this._options.recordVideo)
          await utils_1.mkdirIfNeeded(path_1.default.join(this._options.recordVideo.dir, "dummy"));
      }
      _browserClosed() {
        for (const page of this.pages())
          page._didClose();
        this._didCloseInternal();
      }
      _didCloseInternal() {
        if (this._closedStatus === "closed") {
          return;
        }
        this._closedStatus = "closed";
        this._deleteAllDownloads();
        this._downloads.clear();
        this._closePromiseFulfill(new Error("Context closed"));
        this.emit(BrowserContext.Events.Close);
      }
      async cookies(urls = []) {
        if (urls && !Array.isArray(urls))
          urls = [urls];
        return await this._doCookies(urls);
      }
      setHTTPCredentials(httpCredentials) {
        return this._doSetHTTPCredentials(httpCredentials);
      }
      async exposeBinding(name, needsHandle, playwrightBinding) {
        const identifier = page_1.PageBinding.identifier(name, "main");
        if (this._pageBindings.has(identifier))
          throw new Error(`Function "${name}" has been already registered`);
        for (const page of this.pages()) {
          if (page.getBinding(name, "main"))
            throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        const binding = new page_1.PageBinding(name, playwrightBinding, needsHandle, "main");
        this._pageBindings.set(identifier, binding);
        await this._doExposeBinding(binding);
      }
      async grantPermissions(permissions, origin) {
        let resolvedOrigin = "*";
        if (origin) {
          const url = new URL(origin);
          resolvedOrigin = url.origin;
        }
        const existing = new Set(this._permissions.get(resolvedOrigin) || []);
        permissions.forEach((p) => existing.add(p));
        const list = [...existing.values()];
        this._permissions.set(resolvedOrigin, list);
        await this._doGrantPermissions(resolvedOrigin, list);
      }
      async clearPermissions() {
        this._permissions.clear();
        await this._doClearPermissions();
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async _loadDefaultContextAsIs(progress) {
        if (!this.pages().length) {
          const waitForEvent = helper_1.helper.waitForEvent(progress, this, BrowserContext.Events.Page);
          progress.cleanupWhenAborted(() => waitForEvent.dispose);
          const page = await waitForEvent.promise;
          if (page._pageIsError)
            throw page._pageIsError;
        }
        const pages = this.pages();
        if (pages[0]._pageIsError)
          throw pages[0]._pageIsError;
        await pages[0].mainFrame()._waitForLoadState(progress, "load");
        return pages;
      }
      async _loadDefaultContext(progress) {
        const pages = await this._loadDefaultContextAsIs(progress);
        if (this._options.isMobile || this._options.locale) {
          const oldPage = pages[0];
          await this.newPage(progress.metadata);
          await oldPage.close(progress.metadata);
        }
      }
      _authenticateProxyViaHeader() {
        const proxy = this._options.proxy || this._browser.options.proxy || {username: void 0, password: void 0};
        const {username, password} = proxy;
        if (username) {
          this._options.httpCredentials = {username, password};
          const token = Buffer.from(`${username}:${password}`).toString("base64");
          this._options.extraHTTPHeaders = network.mergeHeaders([
            this._options.extraHTTPHeaders,
            network.singleHeader("Proxy-Authorization", `Basic ${token}`)
          ]);
        }
      }
      _authenticateProxyViaCredentials() {
        const proxy = this._options.proxy || this._browser.options.proxy;
        if (!proxy)
          return;
        const {username, password} = proxy;
        if (username)
          this._options.httpCredentials = {username, password: password || ""};
      }
      async _setRequestInterceptor(handler2) {
        this._requestInterceptor = handler2;
        await this._doUpdateRequestInterception();
      }
      isClosingOrClosed() {
        return this._closedStatus !== "open";
      }
      async _deleteAllDownloads() {
        await Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
      }
      async close(metadata) {
        var _a;
        if (this._closedStatus === "open") {
          this.emit(BrowserContext.Events.BeforeClose);
          this._closedStatus = "closing";
          await ((_a = this._harTracer) === null || _a === void 0 ? void 0 : _a.flush());
          await this.tracing.dispose();
          const promises = [];
          for (const {context, artifact} of this._browser._idToVideo.values()) {
            if (context === this)
              promises.push(artifact.finishedPromise());
          }
          if (this._isPersistentContext) {
            await Promise.all(this.pages().map((page) => page.close(metadata)));
          } else {
            await this._doClose();
          }
          promises.push(this._deleteAllDownloads());
          await Promise.all(promises);
          if (this._isPersistentContext)
            await this._browser.close();
          this._didCloseInternal();
        }
        await this._closePromise;
      }
      async newPage(metadata) {
        const pageDelegate = await this.newPageDelegate();
        const pageOrError = await pageDelegate.pageOrError();
        if (pageOrError instanceof page_1.Page) {
          if (pageOrError.isClosed())
            throw new Error("Page has been closed.");
          return pageOrError;
        }
        throw pageOrError;
      }
      addVisitedOrigin(origin) {
        this._origins.add(origin);
      }
      async storageState(metadata) {
        const result = {
          cookies: (await this.cookies()).filter((c) => c.value !== ""),
          origins: []
        };
        if (this._origins.size) {
          const internalMetadata = instrumentation_1.internalCallMetadata();
          const page = await this.newPage(internalMetadata);
          await page._setServerRequestInterceptor((handler2) => {
            handler2.fulfill({body: "<html></html>"}).catch(() => {
            });
          });
          for (const origin of this._origins) {
            const originStorage = {origin, localStorage: []};
            const frame = page.mainFrame();
            await frame.goto(internalMetadata, origin);
            const storage = await frame.evaluateExpression(`({
          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),
        })`, false, void 0, "utility");
            originStorage.localStorage = storage.localStorage;
            if (storage.localStorage.length)
              result.origins.push(originStorage);
          }
          await page.close(internalMetadata);
        }
        return result;
      }
      async setStorageState(metadata, state) {
        if (state.cookies)
          await this.addCookies(state.cookies);
        if (state.origins && state.origins.length) {
          const internalMetadata = instrumentation_1.internalCallMetadata();
          const page = await this.newPage(internalMetadata);
          await page._setServerRequestInterceptor((handler2) => {
            handler2.fulfill({body: "<html></html>"}).catch(() => {
            });
          });
          for (const originState of state.origins) {
            const frame = page.mainFrame();
            await frame.goto(metadata, originState.origin);
            await frame.evaluateExpression(`
          originState => {
            for (const { name, value } of (originState.localStorage || []))
              localStorage.setItem(name, value);
          }`, true, originState, "utility");
          }
          await page.close(internalMetadata);
        }
      }
      async extendInjectedScript(source, arg) {
        const installInFrame = (frame) => frame.extendInjectedScript(source, arg).catch(() => {
        });
        const installInPage = (page) => {
          page.on(page_1.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
          return Promise.all(page.frames().map(installInFrame));
        };
        this.on(BrowserContext.Events.Page, installInPage);
        return Promise.all(this.pages().map(installInPage));
      }
    };
    exports2.BrowserContext = BrowserContext;
    BrowserContext.Events = {
      Close: "close",
      Page: "page",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted"
    };
    function assertBrowserContextIsNotOwned(context) {
      for (const page of context.pages()) {
        if (page._ownedContext)
          throw new Error("Please use browser.newContext() for multi-page scripts that share the context.");
      }
    }
    exports2.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
    function validateBrowserContextOptions(options2, browserOptions) {
      if (options2.noDefaultViewport && options2.deviceScaleFactor !== void 0)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
      if (options2.noDefaultViewport && options2.isMobile !== void 0)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
      if (!options2.viewport && !options2.noDefaultViewport)
        options2.viewport = {width: 1280, height: 720};
      if (options2.recordVideo) {
        if (!options2.recordVideo.size) {
          if (options2.noDefaultViewport) {
            options2.recordVideo.size = {width: 800, height: 600};
          } else {
            const size = options2.viewport;
            const scale = Math.min(1, 800 / Math.max(size.width, size.height));
            options2.recordVideo.size = {
              width: Math.floor(size.width * scale),
              height: Math.floor(size.height * scale)
            };
          }
        }
        options2.recordVideo.size.width &= ~1;
        options2.recordVideo.size.height &= ~1;
      }
      if (options2.proxy) {
        if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === "win32")
          throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example "launch({ proxy: { server: 'http://per-context' } })"`);
        options2.proxy = normalizeProxySettings(options2.proxy);
      }
      if (utils_1.debugMode() === "inspector")
        options2.bypassCSP = true;
      verifyGeolocation(options2.geolocation);
      if (!options2._debugName)
        options2._debugName = utils_1.createGuid();
    }
    exports2.validateBrowserContextOptions = validateBrowserContextOptions;
    function verifyGeolocation(geolocation) {
      if (!geolocation)
        return;
      geolocation.accuracy = geolocation.accuracy || 0;
      const {longitude, latitude, accuracy} = geolocation;
      if (longitude < -180 || longitude > 180)
        throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
      if (latitude < -90 || latitude > 90)
        throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
      if (accuracy < 0)
        throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
    }
    exports2.verifyGeolocation = verifyGeolocation;
    function normalizeProxySettings(proxy) {
      let {server, bypass} = proxy;
      let url;
      try {
        url = new URL(server);
        if (!url.host || !url.protocol)
          url = new URL("http://" + server);
      } catch (e) {
        url = new URL("http://" + server);
      }
      if (url.protocol === "socks4:" && (proxy.username || proxy.password))
        throw new Error(`Socks4 proxy protocol does not support authentication`);
      if (url.protocol === "socks5:" && (proxy.username || proxy.password))
        throw new Error(`Browser does not support socks5 proxy authentication`);
      server = url.protocol + "//" + url.host;
      if (bypass)
        bypass = bypass.split(",").map((t) => t.trim()).join(",");
      return {...proxy, server, bypass};
    }
    exports2.normalizeProxySettings = normalizeProxySettings;
  }
});

// node_modules/playwright/lib/server/download.js
var require_download = __commonJS({
  "node_modules/playwright/lib/server/download.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Download = void 0;
    var path_1 = __importDefault(require("path"));
    var page_1 = require_page();
    var utils_1 = require_utils();
    var artifact_1 = require_artifact();
    var Download = class {
      constructor(page, downloadsPath, uuid, url, suggestedFilename) {
        const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? "Pass { acceptDownloads: true } when you are creating your browser context." : void 0;
        this.artifact = new artifact_1.Artifact(page, path_1.default.join(downloadsPath, uuid), unaccessibleErrorMessage);
        this._page = page;
        this.url = url;
        this._suggestedFilename = suggestedFilename;
        page._browserContext._downloads.add(this);
        if (suggestedFilename !== void 0)
          this._page.emit(page_1.Page.Events.Download, this);
      }
      _filenameSuggested(suggestedFilename) {
        utils_1.assert(this._suggestedFilename === void 0);
        this._suggestedFilename = suggestedFilename;
        this._page.emit(page_1.Page.Events.Download, this);
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/playwright/lib/server/browser.js
var require_browser2 = __commonJS({
  "node_modules/playwright/lib/server/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Browser = void 0;
    var browserContext_1 = require_browserContext();
    var page_1 = require_page();
    var download_1 = require_download();
    var instrumentation_1 = require_instrumentation();
    var artifact_1 = require_artifact();
    var Browser = class extends instrumentation_1.SdkObject {
      constructor(options2) {
        super(options2.rootSdkObject, "browser");
        this._downloads = new Map();
        this._defaultContext = null;
        this._startedClosing = false;
        this._idToVideo = new Map();
        this.attribution.browser = this;
        this.options = options2;
      }
      _downloadCreated(page, uuid, url, suggestedFilename) {
        const download = new download_1.Download(page, this.options.downloadsPath || "", uuid, url, suggestedFilename);
        this._downloads.set(uuid, download);
      }
      _downloadFilenameSuggested(uuid, suggestedFilename) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download._filenameSuggested(suggestedFilename);
      }
      _downloadFinished(uuid, error3) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download.artifact.reportFinished(error3);
        this._downloads.delete(uuid);
      }
      _videoStarted(context, videoId, path, pageOrError) {
        const artifact = new artifact_1.Artifact(context, path);
        this._idToVideo.set(videoId, {context, artifact});
        context.emit(browserContext_1.BrowserContext.Events.VideoStarted, artifact);
        pageOrError.then((page) => {
          if (page instanceof page_1.Page) {
            page._video = artifact;
            page.emit(page_1.Page.Events.Video, artifact);
          }
        });
      }
      _takeVideo(videoId) {
        const video = this._idToVideo.get(videoId);
        this._idToVideo.delete(videoId);
        return video === null || video === void 0 ? void 0 : video.artifact;
      }
      _didClose() {
        for (const context of this.contexts())
          context._browserClosed();
        if (this._defaultContext)
          this._defaultContext._browserClosed();
        this.emit(Browser.Events.Disconnected);
      }
      async close() {
        if (!this._startedClosing) {
          this._startedClosing = true;
          await this.options.browserProcess.close();
        }
        if (this.isConnected())
          await new Promise((x) => this.once(Browser.Events.Disconnected, x));
      }
      async killForTests() {
        await this.options.browserProcess.kill();
      }
    };
    exports2.Browser = Browser;
    Browser.Events = {
      Disconnected: "disconnected"
    };
  }
});

// node_modules/playwright/lib/server/chromium/crConnection.js
var require_crConnection = __commonJS({
  "node_modules/playwright/lib/server/chromium/crConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRSession = exports2.CRSessionEvents = exports2.CRConnection = exports2.kBrowserCloseMessageId = exports2.ConnectionEvents = void 0;
    var utils_1 = require_utils();
    var events_1 = require("events");
    var stackTrace_1 = require_stackTrace();
    var debugLogger_1 = require_debugLogger();
    var helper_1 = require_helper();
    exports2.ConnectionEvents = {
      Disconnected: Symbol("ConnectionEvents.Disconnected")
    };
    exports2.kBrowserCloseMessageId = -9999;
    var CRConnection = class extends events_1.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = 0;
        this._sessions = new Map();
        this._closed = false;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this.rootSession = new CRSession(this, "", "browser", "");
        this._sessions.set("", this.rootSession);
      }
      static fromSession(session) {
        return session._connection;
      }
      session(sessionId) {
        return this._sessions.get(sessionId) || null;
      }
      _rawSend(sessionId, method, params) {
        const id = ++this._lastId;
        const message = {id, method, params};
        if (sessionId)
          message.sessionId = sessionId;
        this._protocolLogger("send", message);
        this._transport.send(message);
        return id;
      }
      async _onMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === exports2.kBrowserCloseMessageId)
          return;
        if (message.method === "Target.attachedToTarget") {
          const sessionId = message.params.sessionId;
          const rootSessionId = message.sessionId || "";
          const session2 = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);
          this._sessions.set(sessionId, session2);
        } else if (message.method === "Target.detachedFromTarget") {
          const session2 = this._sessions.get(message.params.sessionId);
          if (session2) {
            session2._onClosed(void 0);
            this._sessions.delete(message.params.sessionId);
          }
        }
        const session = this._sessions.get(message.sessionId || "");
        if (session)
          session._onMessage(message);
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const browserDisconnectedLogs = helper_1.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session._onClosed(browserDisconnectedLogs);
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(exports2.ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      async createSession(targetInfo) {
        const {sessionId} = await this.rootSession.send("Target.attachToTarget", {targetId: targetInfo.targetId, flatten: true});
        return this._sessions.get(sessionId);
      }
      async createBrowserSession() {
        const {sessionId} = await this.rootSession.send("Target.attachToBrowserTarget");
        return this._sessions.get(sessionId);
      }
    };
    exports2.CRConnection = CRConnection;
    exports2.CRSessionEvents = {
      Disconnected: Symbol("Events.CDPSession.Disconnected")
    };
    var CRSession = class extends events_1.EventEmitter {
      constructor(connection, rootSessionId, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._crashed = false;
        this.guid = `cdp-session@${sessionId}`;
        this.setMaxListeners(0);
        this._connection = connection;
        this._rootSessionId = rootSessionId;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      _markAsCrashed() {
        this._crashed = true;
      }
      async send(method, params) {
        if (this._crashed)
          throw new Error("Target crashed");
        if (this._browserDisconnectedLogs !== void 0)
          throw new Error(`Protocol error (${method}): Browser closed.` + this._browserDisconnectedLogs);
        if (!this._connection)
          throw new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`);
        const id = this._connection._rawSend(this._sessionId, method, params);
        return new Promise((resolve2, reject) => {
          this._callbacks.set(id, {resolve: resolve2, reject, error: new Error(), method});
        });
      }
      _sendMayFail(method, params) {
        return this.send(method, params).catch((error3) => debugLogger_1.debugLogger.log("error", error3));
      }
      _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          utils_1.assert(!object.id);
          Promise.resolve().then(() => {
            if (this._eventListener)
              this._eventListener(object.method, object.params);
            this.emit(object.method, object.params);
          });
        }
      }
      async detach() {
        if (!this._connection)
          throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        const rootSession = this._connection.session(this._rootSessionId);
        if (!rootSession)
          throw new Error("Root session has been closed");
        await rootSession.send("Target.detachFromTarget", {sessionId: this._sessionId});
      }
      _onClosed(browserDisconnectedLogs) {
        this._browserDisconnectedLogs = browserDisconnectedLogs;
        const errorMessage = browserDisconnectedLogs !== void 0 ? "Browser closed." + browserDisconnectedLogs : "Target closed.";
        for (const callback of this._callbacks.values())
          callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): ` + errorMessage));
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(exports2.CRSessionEvents.Disconnected));
      }
    };
    exports2.CRSession = CRSession;
    function createProtocolError(error3, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return stackTrace_1.rewriteErrorMessage(error3, message);
    }
  }
});

// node_modules/playwright/lib/server/chromium/crProtocolHelper.js
var require_crProtocolHelper = __commonJS({
  "node_modules/playwright/lib/server/chromium/crProtocolHelper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.exceptionToError = exports2.toConsoleMessageLocation = exports2.readProtocolStream = exports2.releaseObject = exports2.getExceptionMessage = void 0;
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var utils_1 = require_utils();
    var stackTrace_1 = require_stackTrace();
    function getExceptionMessage(exceptionDetails) {
      if (exceptionDetails.exception)
        return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
      let message = exceptionDetails.text;
      if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
          const location2 = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
          const functionName = callframe.functionName || "<anonymous>";
          message += `
    at ${functionName} (${location2})`;
        }
      }
      return message;
    }
    exports2.getExceptionMessage = getExceptionMessage;
    async function releaseObject(client, objectId) {
      await client.send("Runtime.releaseObject", {objectId}).catch((error3) => {
      });
    }
    exports2.releaseObject = releaseObject;
    async function readProtocolStream(client, handle, path) {
      let eof = false;
      let fd;
      if (path) {
        await utils_1.mkdirIfNeeded(path);
        fd = await util.promisify(fs_1.default.open)(path, "w");
      }
      const bufs = [];
      while (!eof) {
        const response = await client.send("IO.read", {handle});
        eof = response.eof;
        const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
        bufs.push(buf);
        if (path)
          await util.promisify(fs_1.default.write)(fd, buf);
      }
      if (path)
        await util.promisify(fs_1.default.close)(fd);
      await client.send("IO.close", {handle});
      return Buffer.concat(bufs);
    }
    exports2.readProtocolStream = readProtocolStream;
    function toConsoleMessageLocation(stackTrace) {
      return stackTrace && stackTrace.callFrames.length ? {
        url: stackTrace.callFrames[0].url,
        lineNumber: stackTrace.callFrames[0].lineNumber,
        columnNumber: stackTrace.callFrames[0].columnNumber
      } : {url: "", lineNumber: 0, columnNumber: 0};
    }
    exports2.toConsoleMessageLocation = toConsoleMessageLocation;
    function exceptionToError(exceptionDetails) {
      const messageWithStack = getExceptionMessage(exceptionDetails);
      const lines = messageWithStack.split("\n");
      const firstStackTraceLine = lines.findIndex((line) => line.startsWith("    at"));
      let messageWithName = "";
      let stack = "";
      if (firstStackTraceLine === -1) {
        messageWithName = messageWithStack;
      } else {
        messageWithName = lines.slice(0, firstStackTraceLine).join("\n");
        stack = messageWithStack;
      }
      const {name, message} = stackTrace_1.splitErrorMessage(messageWithName);
      const err = new Error(message);
      err.stack = stack;
      err.name = name;
      return err;
    }
    exports2.exceptionToError = exceptionToError;
  }
});

// node_modules/playwright/lib/server/chromium/crExecutionContext.js
var require_crExecutionContext = __commonJS({
  "node_modules/playwright/lib/server/chromium/crExecutionContext.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRExecutionContext = void 0;
    var crProtocolHelper_1 = require_crProtocolHelper();
    var js = __importStar(require_javascript());
    var stackTrace_1 = require_stackTrace();
    var utilityScriptSerializers_1 = require_utilityScriptSerializers();
    var CRExecutionContext = class {
      constructor(client, contextPayload) {
        this._client = client;
        this._contextId = contextPayload.id;
      }
      async rawEvaluateJSON(expression) {
        const {exceptionDetails, result: remoteObject} = await this._client.send("Runtime.evaluate", {
          expression,
          contextId: this._contextId,
          returnByValue: true
        }).catch(rewriteError);
        if (exceptionDetails)
          throw new Error("Evaluation failed: " + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
        return remoteObject.value;
      }
      async rawEvaluateHandle(expression) {
        const {exceptionDetails, result: remoteObject} = await this._client.send("Runtime.evaluate", {
          expression,
          contextId: this._contextId
        }).catch(rewriteError);
        if (exceptionDetails)
          throw new Error("Evaluation failed: " + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
        return remoteObject.objectId;
      }
      rawCallFunctionNoReply(func, ...args) {
        this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          arguments: args.map((a) => a instanceof js.JSHandle ? {objectId: a._objectId} : {value: a}),
          returnByValue: true,
          executionContextId: this._contextId,
          userGesture: true
        }).catch(() => {
        });
      }
      async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        const {exceptionDetails, result: remoteObject} = await this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: expression,
          objectId: utilityScript._objectId,
          arguments: [
            {objectId: utilityScript._objectId},
            ...values.map((value) => ({value})),
            ...objectIds.map((objectId) => ({objectId}))
          ],
          returnByValue,
          awaitPromise: true,
          userGesture: true
        }).catch(rewriteError);
        if (exceptionDetails)
          throw new Error("Evaluation failed: " + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
        return returnByValue ? utilityScriptSerializers_1.parseEvaluationResultValue(remoteObject.value) : utilityScript._context.createHandle(remoteObject);
      }
      async getProperties(context, objectId) {
        const response = await this._client.send("Runtime.getProperties", {
          objectId,
          ownProperties: true
        });
        const result = new Map();
        for (const property of response.result) {
          if (!property.enumerable || !property.value)
            continue;
          result.set(property.name, context.createHandle(property.value));
        }
        return result;
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      async releaseHandle(objectId) {
        await crProtocolHelper_1.releaseObject(this._client, objectId);
      }
    };
    exports2.CRExecutionContext = CRExecutionContext;
    function rewriteError(error3) {
      if (error3.message.includes("Object reference chain is too long"))
        return {result: {type: "undefined"}};
      if (error3.message.includes("Object couldn't be returned by value"))
        return {result: {type: "undefined"}};
      if (error3.message.endsWith("Cannot find context with specified id") || error3.message.endsWith("Inspected target navigated or closed") || error3.message.endsWith("Execution context was destroyed."))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      if (error3 instanceof TypeError && error3.message.startsWith("Converting circular structure to JSON"))
        stackTrace_1.rewriteErrorMessage(error3, error3.message + " Are you passing a nested JSHandle?");
      throw error3;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
  }
});

// node_modules/playwright/lib/server/chromium/crNetworkManager.js
var require_crNetworkManager = __commonJS({
  "node_modules/playwright/lib/server/chromium/crNetworkManager.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRNetworkManager = void 0;
    var helper_1 = require_helper();
    var network = __importStar(require_network());
    var utils_1 = require_utils();
    var CRNetworkManager = class {
      constructor(client, page, parentManager) {
        this._requestIdToRequest = new Map();
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._requestIdToRequestPausedEvent = new Map();
        this._requestIdToExtraInfo = new Map();
        this._client = client;
        this._page = page;
        this._parentManager = parentManager;
        this._eventListeners = this.instrumentNetworkEvents(client);
      }
      instrumentNetworkEvents(session, workerFrame) {
        return [
          helper_1.helper.addEventListener(session, "Fetch.requestPaused", this._onRequestPaused.bind(this, workerFrame)),
          helper_1.helper.addEventListener(session, "Fetch.authRequired", this._onAuthRequired.bind(this)),
          helper_1.helper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this, workerFrame)),
          helper_1.helper.addEventListener(session, "Network.requestWillBeSentExtraInfo", this._onRequestWillBeSentExtraInfo.bind(this)),
          helper_1.helper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)),
          helper_1.helper.addEventListener(session, "Network.loadingFinished", this._onLoadingFinished.bind(this)),
          helper_1.helper.addEventListener(session, "Network.loadingFailed", this._onLoadingFailed.bind(this)),
          helper_1.helper.addEventListener(session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)),
          helper_1.helper.addEventListener(session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)),
          helper_1.helper.addEventListener(session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
          helper_1.helper.addEventListener(session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
          helper_1.helper.addEventListener(session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
          helper_1.helper.addEventListener(session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)),
          helper_1.helper.addEventListener(session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))
        ];
      }
      async initialize() {
        await this._client.send("Network.enable");
      }
      dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
      }
      async authenticate(credentials) {
        this._credentials = credentials;
        await this._updateProtocolRequestInterception();
      }
      async setOffline(offline) {
        await this._client.send("Network.emulateNetworkConditions", {
          offline,
          latency: 0,
          downloadThroughput: -1,
          uploadThroughput: -1
        });
      }
      async setRequestInterception(value) {
        this._userRequestInterceptionEnabled = value;
        await this._updateProtocolRequestInterception();
      }
      async _updateProtocolRequestInterception() {
        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
        if (enabled === this._protocolRequestInterceptionEnabled)
          return;
        this._protocolRequestInterceptionEnabled = enabled;
        if (enabled) {
          await Promise.all([
            this._client.send("Network.setCacheDisabled", {cacheDisabled: true}),
            this._client.send("Fetch.enable", {
              handleAuthRequests: true,
              patterns: [{urlPattern: "*"}]
            })
          ]);
        } else {
          await Promise.all([
            this._client.send("Network.setCacheDisabled", {cacheDisabled: false}),
            this._client.send("Fetch.disable")
          ]);
        }
      }
      _onRequestWillBeSent(workerFrame, event) {
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
          const requestId = event.requestId;
          const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
          if (requestPausedEvent) {
            this._onRequest(workerFrame, event, requestPausedEvent);
            this._requestIdToRequestPausedEvent.delete(requestId);
          } else {
            this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
          }
        } else {
          this._onRequest(workerFrame, event, null);
        }
        const extraInfo = this._requestIdToExtraInfo.get(event.requestId);
        if (extraInfo)
          this._onRequestWillBeSentExtraInfo(extraInfo);
      }
      _onRequestWillBeSentExtraInfo(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request) {
          request.request.updateWithRawHeaders(utils_1.headersObjectToArray(event.headers));
          this._requestIdToExtraInfo.delete(event.requestId);
        } else {
          this._requestIdToExtraInfo.set(event.requestId, event);
        }
      }
      _onAuthRequired(event) {
        let response = "Default";
        if (this._attemptedAuthentications.has(event.requestId)) {
          response = "CancelAuth";
        } else if (this._credentials) {
          response = "ProvideCredentials";
          this._attemptedAuthentications.add(event.requestId);
        }
        const {username, password} = this._credentials || {username: void 0, password: void 0};
        this._client._sendMayFail("Fetch.continueWithAuth", {
          requestId: event.requestId,
          authChallengeResponse: {response, username, password}
        });
      }
      _onRequestPaused(workerFrame, event) {
        if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {
          this._client._sendMayFail("Fetch.continueRequest", {
            requestId: event.requestId
          });
        }
        if (!event.networkId) {
          this._client._sendMayFail("Fetch.failRequest", {
            requestId: event.requestId,
            errorReason: "Aborted"
          });
          return;
        }
        if (event.request.url.startsWith("data:"))
          return;
        const requestId = event.networkId;
        const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        if (requestWillBeSentEvent) {
          this._onRequest(workerFrame, requestWillBeSentEvent, event);
          this._requestIdToRequestWillBeSentEvent.delete(requestId);
        } else {
          this._requestIdToRequestPausedEvent.set(requestId, event);
        }
      }
      _onRequest(workerFrame, requestWillBeSentEvent, requestPausedEvent) {
        if (requestWillBeSentEvent.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (requestWillBeSentEvent.redirectResponse) {
          const request2 = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp);
            redirectedFrom = request2.request;
          }
        }
        let frame = requestWillBeSentEvent.frameId ? this._page._frameManager.frame(requestWillBeSentEvent.frameId) : workerFrame;
        if (!frame && requestPausedEvent && requestPausedEvent.frameId)
          frame = this._page._frameManager.frame(requestPausedEvent.frameId);
        if (!frame && requestPausedEvent && requestWillBeSentEvent.frameId === this._page._delegate._targetId) {
          frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
        }
        if (requestPausedEvent && requestPausedEvent.request.method === "OPTIONS" && this._page._needsRequestInterception()) {
          const requestHeaders = requestPausedEvent.request.headers;
          const responseHeaders = [
            {name: "Access-Control-Allow-Origin", value: requestHeaders["Origin"] || "*"},
            {name: "Access-Control-Allow-Methods", value: requestHeaders["Access-Control-Request-Method"] || "GET, POST, OPTIONS, DELETE"},
            {name: "Access-Control-Allow-Credentials", value: "true"}
          ];
          if (requestHeaders["Access-Control-Request-Headers"])
            responseHeaders.push({name: "Access-Control-Allow-Headers", value: requestHeaders["Access-Control-Request-Headers"]});
          this._client._sendMayFail("Fetch.fulfillRequest", {
            requestId: requestPausedEvent.requestId,
            responseCode: 204,
            responsePhrase: network.STATUS_TEXTS["204"],
            responseHeaders,
            body: ""
          });
          return;
        }
        if (!frame) {
          if (requestPausedEvent)
            this._client._sendMayFail("Fetch.continueRequest", {requestId: requestPausedEvent.requestId});
          return;
        }
        let allowInterception = this._userRequestInterceptionEnabled;
        if (redirectedFrom) {
          allowInterception = false;
          if (requestPausedEvent)
            this._client._sendMayFail("Fetch.continueRequest", {requestId: requestPausedEvent.requestId});
        }
        const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === "Document";
        const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : void 0;
        const request = new InterceptableRequest({
          client: this._client,
          frame,
          documentId,
          allowInterception,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        });
        this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);
        this._page._frameManager.requestStarted(request.request);
      }
      _createResponse(request, responsePayload) {
        const getResponseBody = async () => {
          const response = await this._client.send("Network.getResponseBody", {requestId: request._requestId});
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        };
        const timingPayload = responsePayload.timing;
        let timing;
        if (timingPayload) {
          timing = {
            startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1e3,
            domainLookupStart: timingPayload.dnsStart,
            domainLookupEnd: timingPayload.dnsEnd,
            connectStart: timingPayload.connectStart,
            secureConnectionStart: timingPayload.sslStart,
            connectEnd: timingPayload.connectEnd,
            requestStart: timingPayload.sendStart,
            responseStart: timingPayload.receiveHeadersEnd
          };
        } else {
          timing = {
            startTime: request._wallTime * 1e3,
            domainLookupStart: -1,
            domainLookupEnd: -1,
            connectStart: -1,
            secureConnectionStart: -1,
            connectEnd: -1,
            requestStart: -1,
            responseStart: -1
          };
        }
        return new network.Response(request.request, responsePayload.status, responsePayload.statusText, utils_1.headersObjectToArray(responsePayload.headers), timing, getResponseBody);
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = this._createResponse(request, responsePayload);
        response._requestFinished((timestamp - request._timestamp) * 1e3, "Response body is unavailable for redirect responses");
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.requestFinished(request.request);
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = this._createResponse(request, event.response);
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onLoadingFinished(event) {
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestFinished(request.request);
      }
      _onLoadingFailed(event) {
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, !!event.canceled);
      }
      _maybeAdoptMainRequest(requestId) {
        if (!this._parentManager)
          return;
        const request = this._parentManager._requestIdToRequest.get(requestId);
        if (!request || request._documentId !== requestId)
          return;
        this._requestIdToRequest.set(requestId, request);
        this._parentManager._requestIdToRequest.delete(requestId);
        if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {
          this._parentManager._attemptedAuthentications.delete(request._interceptionId);
          this._attemptedAuthentications.add(request._interceptionId);
        }
        return request;
      }
    };
    exports2.CRNetworkManager = CRNetworkManager;
    var InterceptableRequest = class {
      constructor(options2) {
        const {client, frame, documentId, allowInterception, requestWillBeSentEvent, requestPausedEvent, redirectedFrom} = options2;
        this._client = client;
        this._timestamp = requestWillBeSentEvent.timestamp;
        this._wallTime = requestWillBeSentEvent.wallTime;
        this._requestId = requestWillBeSentEvent.requestId;
        this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
        this._documentId = documentId;
        const {headers, method, url, postDataEntries = null} = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
        const type = (requestWillBeSentEvent.type || "").toLowerCase();
        let postDataBuffer = null;
        if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes)
          postDataBuffer = Buffer.from(postDataEntries[0].bytes, "base64");
        this.request = new network.Request(allowInterception ? this : null, frame, redirectedFrom, documentId, url, type, method, postDataBuffer, utils_1.headersObjectToArray(headers));
      }
      async continue(overrides) {
        await this._client._sendMayFail("Fetch.continueRequest", {
          requestId: this._interceptionId,
          url: overrides.url,
          headers: overrides.headers,
          method: overrides.method,
          postData: overrides.postData ? overrides.postData.toString("base64") : void 0
        });
      }
      async fulfill(response) {
        const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
        await this._client._sendMayFail("Fetch.fulfillRequest", {
          requestId: this._interceptionId,
          responseCode: response.status,
          responsePhrase: network.STATUS_TEXTS[String(response.status)],
          responseHeaders: response.headers,
          body
        });
      }
      async abort(errorCode = "failed") {
        const errorReason = errorReasons[errorCode];
        utils_1.assert(errorReason, "Unknown error code: " + errorCode);
        await this._client._sendMayFail("Fetch.failRequest", {
          requestId: this._interceptionId,
          errorReason
        });
      }
    };
    var errorReasons = {
      "aborted": "Aborted",
      "accessdenied": "AccessDenied",
      "addressunreachable": "AddressUnreachable",
      "blockedbyclient": "BlockedByClient",
      "blockedbyresponse": "BlockedByResponse",
      "connectionaborted": "ConnectionAborted",
      "connectionclosed": "ConnectionClosed",
      "connectionfailed": "ConnectionFailed",
      "connectionrefused": "ConnectionRefused",
      "connectionreset": "ConnectionReset",
      "internetdisconnected": "InternetDisconnected",
      "namenotresolved": "NameNotResolved",
      "timedout": "TimedOut",
      "failed": "Failed"
    };
  }
});

// node_modules/playwright/lib/server/dialog.js
var require_dialog = __commonJS({
  "node_modules/playwright/lib/server/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Dialog = void 0;
    var utils_1 = require_utils();
    var page_1 = require_page();
    var instrumentation_1 = require_instrumentation();
    var Dialog = class extends instrumentation_1.SdkObject {
      constructor(page, type, message, onHandle, defaultValue) {
        super(page, "dialog");
        this._handled = false;
        this._page = page;
        this._type = type;
        this._message = message;
        this._onHandle = onHandle;
        this._defaultValue = defaultValue || "";
      }
      type() {
        return this._type;
      }
      message() {
        return this._message;
      }
      defaultValue() {
        return this._defaultValue;
      }
      async accept(promptText) {
        utils_1.assert(!this._handled, "Cannot accept dialog which is already handled!");
        this._handled = true;
        await this._onHandle(true, promptText);
        this._page.emit(page_1.Page.Events.InternalDialogClosed, this);
      }
      async dismiss() {
        utils_1.assert(!this._handled, "Cannot dismiss dialog which is already handled!");
        this._handled = true;
        await this._onHandle(false);
        this._page.emit(page_1.Page.Events.InternalDialogClosed, this);
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright/lib/server/macEditingCommands.js
var require_macEditingCommands = __commonJS({
  "node_modules/playwright/lib/server/macEditingCommands.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.macEditingCommands = void 0;
    exports2.macEditingCommands = {
      "Backspace": "deleteBackward:",
      "Enter": "insertNewline:",
      "NumpadEnter": "insertNewline:",
      "Escape": "cancelOperation:",
      "ArrowUp": "moveUp:",
      "ArrowDown": "moveDown:",
      "ArrowLeft": "moveLeft:",
      "ArrowRight": "moveRight:",
      "F5": "complete:",
      "Delete": "deleteForward:",
      "Home": "scrollToBeginningOfDocument:",
      "End": "scrollToEndOfDocument:",
      "PageUp": "scrollPageUp:",
      "PageDown": "scrollPageDown:",
      "Shift+Backspace": "deleteBackward:",
      "Shift+Enter": "insertNewline:",
      "Shift+NumpadEnter": "insertNewline:",
      "Shift+Escape": "cancelOperation:",
      "Shift+ArrowUp": "moveUpAndModifySelection:",
      "Shift+ArrowDown": "moveDownAndModifySelection:",
      "Shift+ArrowLeft": "moveLeftAndModifySelection:",
      "Shift+ArrowRight": "moveRightAndModifySelection:",
      "Shift+F5": "complete:",
      "Shift+Delete": "deleteForward:",
      "Shift+Home": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+End": "moveToEndOfDocumentAndModifySelection:",
      "Shift+PageUp": "pageUpAndModifySelection:",
      "Shift+PageDown": "pageDownAndModifySelection:",
      "Shift+Numpad5": "delete:",
      "Control+Tab": "selectNextKeyView:",
      "Control+Enter": "insertLineBreak:",
      "Control+NumpadEnter": "insertLineBreak:",
      "Control+Quote": "insertSingleQuoteIgnoringSubstitution:",
      "Control+KeyA": "moveToBeginningOfParagraph:",
      "Control+KeyB": "moveBackward:",
      "Control+KeyD": "deleteForward:",
      "Control+KeyE": "moveToEndOfParagraph:",
      "Control+KeyF": "moveForward:",
      "Control+KeyH": "deleteBackward:",
      "Control+KeyK": "deleteToEndOfParagraph:",
      "Control+KeyL": "centerSelectionInVisibleArea:",
      "Control+KeyN": "moveDown:",
      "Control+KeyO": ["insertNewlineIgnoringFieldEditor:", "moveBackward:"],
      "Control+KeyP": "moveUp:",
      "Control+KeyT": "transpose:",
      "Control+KeyV": "pageDown:",
      "Control+KeyY": "yank:",
      "Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Control+ArrowUp": "scrollPageUp:",
      "Control+ArrowDown": "scrollPageDown:",
      "Control+ArrowLeft": "moveToLeftEndOfLine:",
      "Control+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Control+Enter": "insertLineBreak:",
      "Shift+Control+NumpadEnter": "insertLineBreak:",
      "Shift+Control+Tab": "selectPreviousKeyView:",
      "Shift+Control+Quote": "insertDoubleQuoteIgnoringSubstitution:",
      "Shift+Control+KeyA": "moveToBeginningOfParagraphAndModifySelection:",
      "Shift+Control+KeyB": "moveBackwardAndModifySelection:",
      "Shift+Control+KeyE": "moveToEndOfParagraphAndModifySelection:",
      "Shift+Control+KeyF": "moveForwardAndModifySelection:",
      "Shift+Control+KeyN": "moveDownAndModifySelection:",
      "Shift+Control+KeyP": "moveUpAndModifySelection:",
      "Shift+Control+KeyV": "pageDownAndModifySelection:",
      "Shift+Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Shift+Control+ArrowUp": "scrollPageUp:",
      "Shift+Control+ArrowDown": "scrollPageDown:",
      "Shift+Control+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Control+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Alt+Backspace": "deleteWordBackward:",
      "Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Alt+Escape": "complete:",
      "Alt+ArrowUp": ["moveBackward:", "moveToBeginningOfParagraph:"],
      "Alt+ArrowDown": ["moveForward:", "moveToEndOfParagraph:"],
      "Alt+ArrowLeft": "moveWordLeft:",
      "Alt+ArrowRight": "moveWordRight:",
      "Alt+Delete": "deleteWordForward:",
      "Alt+PageUp": "pageUp:",
      "Alt+PageDown": "pageDown:",
      "Shift+Alt+Backspace": "deleteWordBackward:",
      "Shift+Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+Escape": "complete:",
      "Shift+Alt+ArrowUp": "moveParagraphBackwardAndModifySelection:",
      "Shift+Alt+ArrowDown": "moveParagraphForwardAndModifySelection:",
      "Shift+Alt+ArrowLeft": "moveWordLeftAndModifySelection:",
      "Shift+Alt+ArrowRight": "moveWordRightAndModifySelection:",
      "Shift+Alt+Delete": "deleteWordForward:",
      "Shift+Alt+PageUp": "pageUp:",
      "Shift+Alt+PageDown": "pageDown:",
      "Control+Alt+KeyB": "moveWordBackward:",
      "Control+Alt+KeyF": "moveWordForward:",
      "Control+Alt+Backspace": "deleteWordBackward:",
      "Shift+Control+Alt+KeyB": "moveWordBackwardAndModifySelection:",
      "Shift+Control+Alt+KeyF": "moveWordForwardAndModifySelection:",
      "Shift+Control+Alt+Backspace": "deleteWordBackward:",
      "Meta+NumpadSubtract": "cancel:",
      "Meta+Backspace": "deleteToBeginningOfLine:",
      "Meta+ArrowUp": "moveToBeginningOfDocument:",
      "Meta+ArrowDown": "moveToEndOfDocument:",
      "Meta+ArrowLeft": "moveToLeftEndOfLine:",
      "Meta+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Meta+NumpadSubtract": "cancel:",
      "Shift+Meta+Backspace": "deleteToBeginningOfLine:",
      "Shift+Meta+ArrowUp": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowDown": "moveToEndOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Meta+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Meta+KeyA": "selectAll:"
    };
  }
});

// node_modules/playwright/lib/server/chromium/crInput.js
var require_crInput = __commonJS({
  "node_modules/playwright/lib/server/chromium/crInput.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = __importStar(require_input());
    var macEditingCommands_1 = require_macEditingCommands();
    var utils_1 = require_utils();
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Meta"))
        mask |= 4;
      if (modifiers.has("Shift"))
        mask |= 8;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(_client, _isMac) {
        this._client = _client;
        this._isMac = _isMac;
      }
      _commandsForCode(code, modifiers) {
        if (!this._isMac)
          return [];
        const parts = [];
        for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
          if (modifiers.has(modifier))
            parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join("+");
        let commands = macEditingCommands_1.macEditingCommands[shortcut] || [];
        if (utils_1.isString(commands))
          commands = [commands];
        commands = commands.filter((x) => !x.startsWith("insert"));
        return commands.map((c) => c.substring(0, c.length - 1));
      }
      async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        const commands = this._commandsForCode(code, modifiers);
        await this._client.send("Input.dispatchKeyEvent", {
          type: text ? "keyDown" : "rawKeyDown",
          modifiers: toModifiersMask(modifiers),
          windowsVirtualKeyCode: keyCodeWithoutLocation,
          code,
          commands,
          key,
          text,
          unmodifiedText: text,
          autoRepeat,
          location: location2,
          isKeypad: location2 === input.keypadLocation
        });
      }
      async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        await this._client.send("Input.dispatchKeyEvent", {
          type: "keyUp",
          modifiers: toModifiersMask(modifiers),
          key,
          windowsVirtualKeyCode: keyCodeWithoutLocation,
          code,
          location: location2
        });
      }
      async sendText(text) {
        await this._client.send("Input.insertText", {text});
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(client) {
        this._client = client;
      }
      async move(x, y, button, buttons, modifiers) {
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mouseMoved",
          button,
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
      async down(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mousePressed",
          button,
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
      async up(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          button,
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = client;
      }
      async tap(x, y, modifiers) {
        await Promise.all([
          this._client.send("Input.dispatchTouchEvent", {
            type: "touchStart",
            modifiers: toModifiersMask(modifiers),
            touchPoints: [{
              x,
              y
            }]
          }),
          this._client.send("Input.dispatchTouchEvent", {
            type: "touchEnd",
            modifiers: toModifiersMask(modifiers),
            touchPoints: []
          })
        ]);
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright/lib/server/chromium/crAccessibility.js
var require_crAccessibility = __commonJS({
  "node_modules/playwright/lib/server/chromium/crAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getAccessibilityTree = void 0;
    async function getAccessibilityTree(client, needle) {
      const {nodes} = await client.send("Accessibility.getFullAXTree");
      const tree = CRAXNode.createTree(client, nodes);
      return {
        tree,
        needle: needle ? await tree._findElement(needle) : null
      };
    }
    exports2.getAccessibilityTree = getAccessibilityTree;
    var CRAXNode = class {
      constructor(client, payload) {
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._hidden = false;
        this._client = client;
        this._payload = payload;
        this._name = this._payload.name ? this._payload.name.value : "";
        this._role = this._payload.role ? this._payload.role.value : "Unknown";
        for (const property of this._payload.properties || []) {
          if (property.name === "editable") {
            this._richlyEditable = property.value.value === "richtext";
            this._editable = true;
          }
          if (property.name === "focusable")
            this._focusable = property.value.value;
          if (property.name === "expanded")
            this._expanded = property.value.value;
          if (property.name === "hidden")
            this._hidden = property.value.value;
        }
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      async _findElement(element) {
        const objectId = element._objectId;
        const {node: {backendNodeId}} = await this._client.send("DOM.describeNode", {objectId});
        const needle = this.find((node) => node._payload.backendDOMNodeId === backendNodeId);
        return needle || null;
      }
      find(predicate) {
        if (predicate(this))
          return this;
        for (const child of this._children) {
          const result = child.find(predicate);
          if (result)
            return result;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "WebArea" && this._role !== "RootWebArea" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this._role;
        if (role === "Ignored" || this._hidden)
          return false;
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name;
      }
      normalizedRole() {
        switch (this._role) {
          case "RootWebArea":
            return "WebArea";
          case "StaticText":
            return "text";
          default:
            return this._role;
        }
      }
      serialize() {
        const properties = new Map();
        for (const property of this._payload.properties || [])
          properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.description)
          properties.set("description", this._payload.description.value);
        const node = {
          role: this.normalizedRole(),
          name: this._payload.name ? this._payload.name.value || "" : ""
        };
        const userStringProperties = [
          "description",
          "keyshortcuts",
          "roledescription",
          "valuetext"
        ];
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty))
            continue;
          node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = [
          "disabled",
          "expanded",
          "focused",
          "modal",
          "multiline",
          "multiselectable",
          "readonly",
          "required",
          "selected"
        ];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._role === "WebArea" || this._role === "RootWebArea"))
            continue;
          const value = properties.get(booleanProperty);
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = [
          "level",
          "valuemax",
          "valuemin"
        ];
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty))
            continue;
          node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = [
          "autocomplete",
          "haspopup",
          "invalid",
          "orientation"
        ];
        for (const tokenProperty of tokenProperties) {
          const value = properties.get(tokenProperty);
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        if (this._payload.value) {
          if (typeof this._payload.value.value === "string")
            axNode.valueString = this._payload.value.value;
          if (typeof this._payload.value.value === "number")
            axNode.valueNumber = this._payload.value.value;
        }
        if (properties.has("checked"))
          axNode.checked = properties.get("checked") === "true" ? "checked" : properties.get("checked") === "false" ? "unchecked" : "mixed";
        if (properties.has("pressed"))
          axNode.pressed = properties.get("pressed") === "true" ? "pressed" : properties.get("pressed") === "false" ? "released" : "mixed";
        return axNode;
      }
      static createTree(client, payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
          nodeById.set(payload.nodeId, new CRAXNode(client, payload));
        for (const node of nodeById.values()) {
          for (const childId of node._payload.childIds || [])
            node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
      }
    };
  }
});

// node_modules/playwright/lib/server/chromium/crCoverage.js
var require_crCoverage = __commonJS({
  "node_modules/playwright/lib/server/chromium/crCoverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRCoverage = void 0;
    var helper_1 = require_helper();
    var utils_1 = require_utils();
    var CRCoverage = class {
      constructor(client) {
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
      }
      async startJSCoverage(options2) {
        return await this._jsCoverage.start(options2);
      }
      async stopJSCoverage() {
        return await this._jsCoverage.stop();
      }
      async startCSSCoverage(options2) {
        return await this._cssCoverage.start(options2);
      }
      async stopCSSCoverage() {
        return await this._cssCoverage.stop();
      }
    };
    exports2.CRCoverage = CRCoverage;
    var JSCoverage = class {
      constructor(client) {
        this._reportAnonymousScripts = false;
        this._client = client;
        this._enabled = false;
        this._scriptIds = new Set();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      async start(options2 = {}) {
        utils_1.assert(!this._enabled, "JSCoverage is already enabled");
        const {resetOnNavigation = true, reportAnonymousScripts = false} = options2;
        this._resetOnNavigation = resetOnNavigation;
        this._reportAnonymousScripts = reportAnonymousScripts;
        this._enabled = true;
        this._scriptIds.clear();
        this._scriptSources.clear();
        this._eventListeners = [
          helper_1.helper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)),
          helper_1.helper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)),
          helper_1.helper.addEventListener(this._client, "Debugger.paused", this._onDebuggerPaused.bind(this))
        ];
        await Promise.all([
          this._client.send("Profiler.enable"),
          this._client.send("Profiler.startPreciseCoverage", {callCount: true, detailed: true}),
          this._client.send("Debugger.enable"),
          this._client.send("Debugger.setSkipAllPauses", {skip: true})
        ]);
      }
      _onDebuggerPaused() {
        this._client.send("Debugger.resume");
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._scriptIds.clear();
        this._scriptSources.clear();
      }
      async _onScriptParsed(event) {
        this._scriptIds.add(event.scriptId);
        if (!event.url && !this._reportAnonymousScripts)
          return;
        const response = await this._client._sendMayFail("Debugger.getScriptSource", {scriptId: event.scriptId});
        if (response)
          this._scriptSources.set(event.scriptId, response.scriptSource);
      }
      async stop() {
        utils_1.assert(this._enabled, "JSCoverage is not enabled");
        this._enabled = false;
        const [profileResponse] = await Promise.all([
          this._client.send("Profiler.takePreciseCoverage"),
          this._client.send("Profiler.stopPreciseCoverage"),
          this._client.send("Profiler.disable"),
          this._client.send("Debugger.disable")
        ]);
        helper_1.helper.removeEventListeners(this._eventListeners);
        const coverage = [];
        for (const entry of profileResponse.result) {
          if (!this._scriptIds.has(entry.scriptId))
            continue;
          if (!entry.url && !this._reportAnonymousScripts)
            continue;
          const source = this._scriptSources.get(entry.scriptId);
          if (source)
            coverage.push({...entry, source});
          else
            coverage.push(entry);
        }
        return coverage;
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      async start(options2 = {}) {
        utils_1.assert(!this._enabled, "CSSCoverage is already enabled");
        const {resetOnNavigation = true} = options2;
        this._resetOnNavigation = resetOnNavigation;
        this._enabled = true;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
        this._eventListeners = [
          helper_1.helper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)),
          helper_1.helper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))
        ];
        await Promise.all([
          this._client.send("DOM.enable"),
          this._client.send("CSS.enable"),
          this._client.send("CSS.startRuleUsageTracking")
        ]);
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
      }
      async _onStyleSheet(event) {
        const header = event.header;
        if (!header.sourceURL)
          return;
        const response = await this._client._sendMayFail("CSS.getStyleSheetText", {styleSheetId: header.styleSheetId});
        if (response) {
          this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
          this._stylesheetSources.set(header.styleSheetId, response.text);
        }
      }
      async stop() {
        utils_1.assert(this._enabled, "CSSCoverage is not enabled");
        this._enabled = false;
        const ruleTrackingResponse = await this._client.send("CSS.stopRuleUsageTracking");
        await Promise.all([
          this._client.send("CSS.disable"),
          this._client.send("DOM.disable")
        ]);
        helper_1.helper.removeEventListeners(this._eventListeners);
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
          let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
          if (!ranges) {
            ranges = [];
            styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
          }
          ranges.push({
            startOffset: entry.startOffset,
            endOffset: entry.endOffset,
            count: entry.used ? 1 : 0
          });
        }
        const coverage = [];
        for (const styleSheetId of this._stylesheetURLs.keys()) {
          const url = this._stylesheetURLs.get(styleSheetId);
          const text = this._stylesheetSources.get(styleSheetId);
          const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
          coverage.push({url, ranges, text});
        }
        return coverage;
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({offset: range.startOffset, type: 0, range});
        points.push({offset: range.endOffset, type: 1, range});
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset)
          return a.offset - b.offset;
        if (a.type !== b.type)
          return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0)
          return bLength - aLength;
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results.length ? results[results.length - 1] : null;
          if (lastResult && lastResult.end === lastOffset)
            lastResult.end = point.offset;
          else
            results.push({start: lastOffset, end: point.offset});
        }
        lastOffset = point.offset;
        if (point.type === 0)
          hitCountStack.push(point.range.count);
        else
          hitCountStack.pop();
      }
      return results.filter((range) => range.end - range.start > 1);
    }
  }
});

// node_modules/playwright/lib/server/chromium/crPdf.js
var require_crPdf = __commonJS({
  "node_modules/playwright/lib/server/chromium/crPdf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRPDF = void 0;
    var utils_1 = require_utils();
    var crProtocolHelper_1 = require_crProtocolHelper();
    var PagePaperFormats = {
      letter: {width: 8.5, height: 11},
      legal: {width: 8.5, height: 14},
      tabloid: {width: 11, height: 17},
      ledger: {width: 17, height: 11},
      a0: {width: 33.1, height: 46.8},
      a1: {width: 23.4, height: 33.1},
      a2: {width: 16.54, height: 23.4},
      a3: {width: 11.7, height: 16.54},
      a4: {width: 8.27, height: 11.7},
      a5: {width: 5.83, height: 8.27},
      a6: {width: 4.13, height: 5.83}
    };
    var unitToPixels = {
      "px": 1,
      "in": 96,
      "cm": 37.8,
      "mm": 3.78
    };
    function convertPrintParameterToInches(text) {
      if (text === void 0)
        return void 0;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unitToPixels.hasOwnProperty(unit)) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      utils_1.assert(!isNaN(value), "Failed to parse parameter value: " + text);
      const pixels = value * unitToPixels[unit];
      return pixels / 96;
    }
    var CRPDF = class {
      constructor(client) {
        this._client = client;
      }
      async generate(options2 = {}) {
        const {scale = 1, displayHeaderFooter = false, headerTemplate = "", footerTemplate = "", printBackground = false, landscape = false, pageRanges = "", preferCSSPageSize = false, margin = {}} = options2;
        let paperWidth = 8.5;
        let paperHeight = 11;
        if (options2.format) {
          const format2 = PagePaperFormats[options2.format.toLowerCase()];
          utils_1.assert(format2, "Unknown paper format: " + options2.format);
          paperWidth = format2.width;
          paperHeight = format2.height;
        } else {
          paperWidth = convertPrintParameterToInches(options2.width) || paperWidth;
          paperHeight = convertPrintParameterToInches(options2.height) || paperHeight;
        }
        const marginTop = convertPrintParameterToInches(margin.top) || 0;
        const marginLeft = convertPrintParameterToInches(margin.left) || 0;
        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
        const marginRight = convertPrintParameterToInches(margin.right) || 0;
        const result = await this._client.send("Page.printToPDF", {
          transferMode: "ReturnAsStream",
          landscape,
          displayHeaderFooter,
          headerTemplate,
          footerTemplate,
          printBackground,
          scale,
          paperWidth,
          paperHeight,
          marginTop,
          marginBottom,
          marginLeft,
          marginRight,
          pageRanges,
          preferCSSPageSize
        });
        return await crProtocolHelper_1.readProtocolStream(this._client, result.stream, null);
      }
    };
    exports2.CRPDF = CRPDF;
  }
});

// node_modules/playwright/lib/server/processLauncher.js
var require_processLauncher = __commonJS({
  "node_modules/playwright/lib/server/processLauncher.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.envArrayToObject = exports2.launchProcess = exports2.gracefullyCloseAll = void 0;
    var childProcess = __importStar(require("child_process"));
    var readline = __importStar(require("readline"));
    var helper_1 = require_helper();
    var utils_1 = require_utils();
    var gracefullyCloseSet = new Set();
    async function gracefullyCloseAll() {
      await Promise.all(Array.from(gracefullyCloseSet).map((gracefullyClose) => gracefullyClose().catch((e) => {
      })));
    }
    exports2.gracefullyCloseAll = gracefullyCloseAll;
    var maxListeners = process.getMaxListeners();
    if (maxListeners !== 0)
      process.setMaxListeners(Math.max(maxListeners || 0, 100));
    async function launchProcess(options2) {
      const cleanup = () => utils_1.removeFolders(options2.tempDirectories);
      const stdio = options2.stdio === "pipe" ? ["ignore", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
      options2.log(`<launching> ${options2.executablePath} ${options2.args.join(" ")}`);
      const spawnedProcess = childProcess.spawn(options2.executablePath, options2.args, {
        detached: process.platform !== "win32",
        env: options2.env,
        cwd: options2.cwd,
        stdio
      });
      spawnedProcess.on("error", () => {
      });
      if (!spawnedProcess.pid) {
        let failed;
        const failedPromise = new Promise((f, r) => failed = f);
        spawnedProcess.once("error", (error3) => {
          failed(new Error("Failed to launch: " + error3));
        });
        return cleanup().then(() => failedPromise).then((e) => Promise.reject(e));
      }
      options2.log(`<launched> pid=${spawnedProcess.pid}`);
      const stdout = readline.createInterface({input: spawnedProcess.stdout});
      stdout.on("line", (data) => {
        options2.log(`[pid=${spawnedProcess.pid}][out] ` + data);
      });
      const stderr = readline.createInterface({input: spawnedProcess.stderr});
      stderr.on("line", (data) => {
        options2.log(`[pid=${spawnedProcess.pid}][err] ` + data);
      });
      let processClosed = false;
      let fulfillClose = () => {
      };
      const waitForClose = new Promise((f) => fulfillClose = f);
      let fulfillCleanup = () => {
      };
      const waitForCleanup = new Promise((f) => fulfillCleanup = f);
      spawnedProcess.once("exit", (exitCode, signal) => {
        options2.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);
        processClosed = true;
        helper_1.helper.removeEventListeners(listeners);
        gracefullyCloseSet.delete(gracefullyClose);
        options2.onExit(exitCode, signal);
        fulfillClose();
        cleanup().then(fulfillCleanup);
      });
      const listeners = [helper_1.helper.addEventListener(process, "exit", killProcess)];
      if (options2.handleSIGINT) {
        listeners.push(helper_1.helper.addEventListener(process, "SIGINT", () => {
          gracefullyClose().then(() => {
            if (utils_1.isUnderTest())
              setTimeout(() => process.exit(130), 0);
            else
              process.exit(130);
          });
        }));
      }
      if (options2.handleSIGTERM)
        listeners.push(helper_1.helper.addEventListener(process, "SIGTERM", gracefullyClose));
      if (options2.handleSIGHUP)
        listeners.push(helper_1.helper.addEventListener(process, "SIGHUP", gracefullyClose));
      gracefullyCloseSet.add(gracefullyClose);
      let gracefullyClosing = false;
      async function gracefullyClose() {
        gracefullyCloseSet.delete(gracefullyClose);
        if (gracefullyClosing) {
          options2.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);
          killProcess();
          await waitForClose;
          return;
        }
        gracefullyClosing = true;
        options2.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
        await options2.attemptToGracefullyClose().catch(() => killProcess());
        await waitForCleanup;
        options2.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
      }
      function killProcess() {
        options2.log(`[pid=${spawnedProcess.pid}] <kill>`);
        helper_1.helper.removeEventListeners(listeners);
        if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
          options2.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
          try {
            if (process.platform === "win32") {
              const stdout2 = childProcess.execSync(`taskkill /pid ${spawnedProcess.pid} /T /F`);
              options2.log(`[pid=${spawnedProcess.pid}] taskkill output: ${stdout2.toString()}`);
            } else {
              process.kill(-spawnedProcess.pid, "SIGKILL");
            }
          } catch (e) {
            options2.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
          }
        } else {
          options2.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
        }
        cleanup();
      }
      function killAndWait() {
        killProcess();
        return waitForCleanup;
      }
      return {launchedProcess: spawnedProcess, gracefullyClose, kill: killAndWait};
    }
    exports2.launchProcess = launchProcess;
    function envArrayToObject(env2) {
      const result = {};
      for (const {name, value} of env2)
        result[name] = value;
      return result;
    }
    exports2.envArrayToObject = envArrayToObject;
  }
});

// node_modules/playwright/lib/server/chromium/videoRecorder.js
var require_videoRecorder = __commonJS({
  "node_modules/playwright/lib/server/chromium/videoRecorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.VideoRecorder = void 0;
    var utils_1 = require_utils();
    var page_1 = require_page();
    var processLauncher_1 = require_processLauncher();
    var progress_1 = require_progress();
    var instrumentation_1 = require_instrumentation();
    var fps = 25;
    var VideoRecorder = class {
      constructor(page, ffmpegPath, progress) {
        this._process = null;
        this._gracefullyClose = null;
        this._lastWritePromise = Promise.resolve();
        this._lastFrameTimestamp = 0;
        this._lastFrameBuffer = null;
        this._lastWriteTimestamp = 0;
        this._frameQueue = [];
        this._isStopped = false;
        this._progress = progress;
        this._ffmpegPath = ffmpegPath;
        page.on(page_1.Page.Events.ScreencastFrame, (frame) => this.writeFrame(frame.buffer, frame.timestamp));
      }
      static async launch(page, ffmpegPath, options2) {
        if (!options2.outputFile.endsWith(".webm"))
          throw new Error("File must have .webm extension");
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), page);
        controller.setLogName("browser");
        return await controller.run(async (progress) => {
          const recorder = new VideoRecorder(page, ffmpegPath, progress);
          await recorder._launch(options2);
          return recorder;
        });
      }
      async _launch(options2) {
        const w = options2.width;
        const h = options2.height;
        const args = `-loglevel error -f image2pipe -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -b:v 1M -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(" ");
        args.push(options2.outputFile);
        const progress = this._progress;
        const {launchedProcess, gracefullyClose} = await processLauncher_1.launchProcess({
          executablePath: this._ffmpegPath,
          args,
          stdio: "stdin",
          log: (message) => progress.log(message),
          tempDirectories: [],
          attemptToGracefullyClose: async () => {
            progress.log("Closing stdin...");
            launchedProcess.stdin.end();
          },
          onExit: (exitCode, signal) => {
            progress.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);
          }
        });
        launchedProcess.stdin.on("finish", () => {
          progress.log("ffmpeg finished input.");
        });
        launchedProcess.stdin.on("error", () => {
          progress.log("ffmpeg error.");
        });
        this._process = launchedProcess;
        this._gracefullyClose = gracefullyClose;
      }
      writeFrame(frame, timestamp) {
        utils_1.assert(this._process);
        if (this._isStopped)
          return;
        this._progress.log(`writing frame ` + timestamp);
        if (this._lastFrameBuffer) {
          const durationSec = timestamp - this._lastFrameTimestamp;
          const repeatCount = Math.max(1, Math.round(fps * durationSec));
          for (let i = 0; i < repeatCount; ++i)
            this._frameQueue.push(this._lastFrameBuffer);
          this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
        }
        this._lastFrameBuffer = frame;
        this._lastFrameTimestamp = timestamp;
        this._lastWriteTimestamp = utils_1.monotonicTime();
      }
      async _sendFrames() {
        while (this._frameQueue.length)
          await this._sendFrame(this._frameQueue.shift());
      }
      async _sendFrame(frame) {
        return new Promise((f) => this._process.stdin.write(frame, f)).then((error3) => {
          if (error3)
            this._progress.log(`ffmpeg failed to write: ${error3}`);
        });
      }
      async stop() {
        if (this._isStopped)
          return;
        this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + (utils_1.monotonicTime() - this._lastWriteTimestamp) / 1e3);
        this._isStopped = true;
        await this._lastWritePromise;
        await this._gracefullyClose();
      }
    };
    exports2.VideoRecorder = VideoRecorder;
  }
});

// node_modules/playwright/lib/server/chromium/crPage.js
var require_crPage = __commonJS({
  "node_modules/playwright/lib/server/chromium/crPage.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRPage = void 0;
    var dom = __importStar(require_dom());
    var helper_1 = require_helper();
    var network = __importStar(require_network());
    var crConnection_1 = require_crConnection();
    var crExecutionContext_1 = require_crExecutionContext();
    var crNetworkManager_1 = require_crNetworkManager();
    var page_1 = require_page();
    var crProtocolHelper_1 = require_crProtocolHelper();
    var dialog = __importStar(require_dialog());
    var path_1 = __importDefault(require("path"));
    var crInput_1 = require_crInput();
    var crAccessibility_1 = require_crAccessibility();
    var crCoverage_1 = require_crCoverage();
    var crPdf_1 = require_crPdf();
    var crBrowser_1 = require_crBrowser();
    var console_1 = require_console();
    var stackTrace_1 = require_stackTrace();
    var utils_1 = require_utils();
    var videoRecorder_1 = require_videoRecorder();
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var CRPage = class {
      constructor(client, targetId, browserContext, opener, hasUIWindow, isBackgroundPage) {
        this._sessions = new Map();
        this._initializedPage = null;
        this._nextWindowOpenPopupFeatures = [];
        this._targetId = targetId;
        this._opener = opener;
        this._isBackgroundPage = isBackgroundPage;
        this.rawKeyboard = new crInput_1.RawKeyboardImpl(client, browserContext._browser._isMac);
        this.rawMouse = new crInput_1.RawMouseImpl(client);
        this.rawTouchscreen = new crInput_1.RawTouchscreenImpl(client);
        this._pdf = new crPdf_1.CRPDF(client);
        this._coverage = new crCoverage_1.CRCoverage(client);
        this._browserContext = browserContext;
        this._page = new page_1.Page(this, browserContext);
        this._mainFrameSession = new FrameSession(this, client, targetId, null);
        this._sessions.set(targetId, this._mainFrameSession);
        client.once(crConnection_1.CRSessionEvents.Disconnected, () => this._page._didDisconnect());
        if (opener && !browserContext._options.noDefaultViewport) {
          const features = opener._nextWindowOpenPopupFeatures.shift() || [];
          const viewportSize = helper_1.helper.getViewportSizeFromWindowFeatures(features);
          if (viewportSize)
            this._page._state.emulatedSize = {viewport: viewportSize, screen: viewportSize};
        }
        this._pagePromise = this._mainFrameSession._initialize(hasUIWindow).then(async (r) => {
          await this._page.initOpener(this._opener);
          return r;
        }).catch(async (e) => {
          await this._page.initOpener(this._opener);
          throw e;
        }).then(() => {
          this._initializedPage = this._page;
          this._reportAsNew();
          return this._page;
        }).catch((e) => {
          this._reportAsNew(e);
          return e;
        });
      }
      static mainFrameSession(page) {
        const crPage = page._delegate;
        return crPage._mainFrameSession;
      }
      _reportAsNew(error3) {
        if (this._isBackgroundPage) {
          if (!error3)
            this._browserContext.emit(crBrowser_1.CRBrowserContext.CREvents.BackgroundPage, this._page);
        } else {
          this._page.reportAsNew(error3);
        }
      }
      async _forAllFrameSessions(cb) {
        const frameSessions = Array.from(this._sessions.values());
        await Promise.all(frameSessions.map((frameSession) => {
          if (frameSession._isMainFrame())
            return cb(frameSession);
          return cb(frameSession).catch((e) => {
            if (e.message && (e.message.includes("Target closed.") || e.message.includes("Session closed.")))
              return;
            throw e;
          });
        }));
      }
      _sessionForFrame(frame) {
        while (!this._sessions.has(frame._id)) {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error(`Frame has been detached.`);
          frame = parent;
        }
        return this._sessions.get(frame._id);
      }
      _sessionForHandle(handle) {
        const frame = handle._context.frame;
        return this._sessionForFrame(frame);
      }
      async pageOrError() {
        return this._pagePromise;
      }
      didClose() {
        for (const session of this._sessions.values())
          session.dispose();
        this._page._didClose();
      }
      async navigateFrame(frame, url, referrer) {
        return this._sessionForFrame(frame)._navigate(frame, url, referrer);
      }
      async exposeBinding(binding) {
        await this._forAllFrameSessions((frame) => frame._initBinding(binding));
        await Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(binding.source, false, {}, binding.world).catch((e) => {
        })));
      }
      async updateExtraHTTPHeaders() {
        await this._forAllFrameSessions((frame) => frame._updateExtraHTTPHeaders(false));
      }
      async updateGeolocation() {
        await this._forAllFrameSessions((frame) => frame._updateGeolocation(false));
      }
      async updateOffline() {
        await this._forAllFrameSessions((frame) => frame._updateOffline(false));
      }
      async updateHttpCredentials() {
        await this._forAllFrameSessions((frame) => frame._updateHttpCredentials(false));
      }
      async setEmulatedSize(emulatedSize) {
        utils_1.assert(this._page._state.emulatedSize === emulatedSize);
        await this._mainFrameSession._updateViewport();
      }
      async bringToFront() {
        await this._mainFrameSession._client.send("Page.bringToFront");
      }
      async updateEmulateMedia() {
        await this._forAllFrameSessions((frame) => frame._updateEmulateMedia(false));
      }
      async updateRequestInterception() {
        await this._forAllFrameSessions((frame) => frame._updateRequestInterception(false));
      }
      async setFileChooserIntercepted(enabled) {
        await this._forAllFrameSessions((frame) => frame._setFileChooserIntercepted(enabled));
      }
      async reload() {
        await this._mainFrameSession._client.send("Page.reload");
      }
      async _go(delta) {
        const history = await this._mainFrameSession._client.send("Page.getNavigationHistory");
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
          return false;
        await this._mainFrameSession._client.send("Page.navigateToHistoryEntry", {entryId: entry.id});
        return true;
      }
      goBack() {
        return this._go(-1);
      }
      goForward() {
        return this._go(1);
      }
      async evaluateOnNewDocument(source, world = "main") {
        await this._forAllFrameSessions((frame) => frame._evaluateOnNewDocument(source, world));
      }
      async closePage(runBeforeUnload) {
        if (runBeforeUnload)
          await this._mainFrameSession._client.send("Page.close");
        else
          await this._browserContext._browser._closePage(this);
      }
      canScreenshotOutsideViewport() {
        return false;
      }
      async setBackgroundColor(color) {
        await this._mainFrameSession._client.send("Emulation.setDefaultBackgroundColorOverride", {color});
      }
      async takeScreenshot(progress, format2, documentRect, viewportRect, quality) {
        const {visualViewport} = await this._mainFrameSession._client.send("Page.getLayoutMetrics");
        if (!documentRect) {
          documentRect = {
            x: visualViewport.pageX + viewportRect.x,
            y: visualViewport.pageY + viewportRect.y,
            ...helper_1.helper.enclosingIntSize({
              width: viewportRect.width / visualViewport.scale,
              height: viewportRect.height / visualViewport.scale
            })
          };
        }
        const clip = {...documentRect, scale: viewportRect ? visualViewport.scale : 1};
        progress.throwIfAborted();
        const result = await this._mainFrameSession._client.send("Page.captureScreenshot", {format: format2, quality, clip});
        return Buffer.from(result.data, "base64");
      }
      async resetViewport() {
        await this._mainFrameSession._client.send("Emulation.setDeviceMetricsOverride", {mobile: false, width: 0, height: 0, deviceScaleFactor: 0});
      }
      async getContentFrame(handle) {
        return this._sessionForHandle(handle)._getContentFrame(handle);
      }
      async getOwnerFrame(handle) {
        return this._sessionForHandle(handle)._getOwnerFrame(handle);
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      async getBoundingBox(handle) {
        return this._sessionForHandle(handle)._getBoundingBox(handle);
      }
      async scrollRectIntoViewIfNeeded(handle, rect) {
        return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
      }
      async setScreencastEnabled(enabled) {
        if (enabled) {
          await this._mainFrameSession._startScreencast(this, {
            format: "jpeg",
            quality: 90,
            maxWidth: 800,
            maxHeight: 600
          });
        } else {
          await this._mainFrameSession._stopScreencast(this);
        }
      }
      rafCountForStablePosition() {
        return 1;
      }
      async getContentQuads(handle) {
        return this._sessionForHandle(handle)._getContentQuads(handle);
      }
      async setInputFiles(handle, files) {
        await handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
      }
      async adoptElementHandle(handle, to) {
        return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
      }
      async getAccessibilityTree(needle) {
        return crAccessibility_1.getAccessibilityTree(this._mainFrameSession._client, needle);
      }
      async inputActionEpilogue() {
        await this._mainFrameSession._client.send("Page.enable").catch((e) => {
        });
      }
      async pdf(options2) {
        return this._pdf.generate(options2);
      }
      coverage() {
        return this._coverage;
      }
      async getFrameElement(frame) {
        let parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        const parentSession = this._sessionForFrame(parent);
        const {backendNodeId} = await parentSession._client.send("DOM.getFrameOwner", {frameId: frame._id}).catch((e) => {
          if (e instanceof Error && e.message.includes("Frame with the given id was not found."))
            stackTrace_1.rewriteErrorMessage(e, "Frame has been detached.");
          throw e;
        });
        parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        return parentSession._adoptBackendNodeId(backendNodeId, await parent._mainContext());
      }
    };
    exports2.CRPage = CRPage;
    var FrameSession = class {
      constructor(crPage, client, targetId, parentSession) {
        this._contextIdToContext = new Map();
        this._eventListeners = [];
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._swappedIn = false;
        this._videoRecorder = null;
        this._screencastId = null;
        this._screencastClients = new Set();
        this._client = client;
        this._crPage = crPage;
        this._page = crPage._page;
        this._targetId = targetId;
        this._networkManager = new crNetworkManager_1.CRNetworkManager(client, this._page, parentSession ? parentSession._networkManager : null);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        client.once(crConnection_1.CRSessionEvents.Disconnected, () => {
          this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
        });
      }
      _isMainFrame() {
        return this._targetId === this._crPage._targetId;
      }
      _addRendererListeners() {
        this._eventListeners.push(...[
          helper_1.helper.addEventListener(this._client, "Log.entryAdded", (event) => this._onLogEntryAdded(event)),
          helper_1.helper.addEventListener(this._client, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)),
          helper_1.helper.addEventListener(this._client, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)),
          helper_1.helper.addEventListener(this._client, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId, event.reason)),
          helper_1.helper.addEventListener(this._client, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)),
          helper_1.helper.addEventListener(this._client, "Page.frameRequestedNavigation", (event) => this._onFrameRequestedNavigation(event)),
          helper_1.helper.addEventListener(this._client, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)),
          helper_1.helper.addEventListener(this._client, "Page.javascriptDialogOpening", (event) => this._onDialog(event)),
          helper_1.helper.addEventListener(this._client, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
          helper_1.helper.addEventListener(this._client, "Runtime.bindingCalled", (event) => this._onBindingCalled(event)),
          helper_1.helper.addEventListener(this._client, "Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event)),
          helper_1.helper.addEventListener(this._client, "Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails)),
          helper_1.helper.addEventListener(this._client, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)),
          helper_1.helper.addEventListener(this._client, "Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId)),
          helper_1.helper.addEventListener(this._client, "Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared()),
          helper_1.helper.addEventListener(this._client, "Target.attachedToTarget", (event) => this._onAttachedToTarget(event)),
          helper_1.helper.addEventListener(this._client, "Target.detachedFromTarget", (event) => this._onDetachedFromTarget(event))
        ]);
      }
      _addBrowserListeners() {
        this._eventListeners.push(...[
          helper_1.helper.addEventListener(this._client, "Inspector.targetCrashed", (event) => this._onTargetCrashed()),
          helper_1.helper.addEventListener(this._client, "Page.downloadWillBegin", (event) => this._onDownloadWillBegin(event)),
          helper_1.helper.addEventListener(this._client, "Page.downloadProgress", (event) => this._onDownloadProgress(event)),
          helper_1.helper.addEventListener(this._client, "Page.screencastFrame", (event) => this._onScreencastFrame(event)),
          helper_1.helper.addEventListener(this._client, "Page.windowOpen", (event) => this._onWindowOpen(event))
        ]);
      }
      async _initialize(hasUIWindow) {
        if (hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
          const {windowId} = await this._client.send("Browser.getWindowForTarget");
          this._windowId = windowId;
        }
        let screencastOptions;
        if (this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
          const screencastId = utils_1.createGuid();
          const outputFile = path_1.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + ".webm");
          screencastOptions = {
            ...this._crPage._browserContext._options.recordVideo.size,
            outputFile
          };
          await this._crPage._browserContext._ensureVideosPath();
          await this._createVideoRecorder(screencastId, screencastOptions);
          this._crPage.pageOrError().then((p) => {
            if (p instanceof Error)
              this._stopVideoRecording().catch(() => {
              });
          });
        }
        let lifecycleEventsEnabled;
        if (!this._isMainFrame())
          this._addRendererListeners();
        this._addBrowserListeners();
        const promises = [
          this._client.send("Page.enable"),
          this._client.send("Page.getFrameTree").then(({frameTree}) => {
            if (this._isMainFrame()) {
              this._handleFrameTree(frameTree);
              this._addRendererListeners();
            }
            const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];
            for (const frame of localFrames) {
              this._client._sendMayFail("Page.createIsolatedWorld", {
                frameId: frame._id,
                grantUniveralAccess: true,
                worldName: UTILITY_WORLD_NAME
              });
              for (const binding of this._crPage._browserContext._pageBindings.values())
                frame.evaluateExpression(binding.source, false, void 0, binding.world).catch((e) => {
                });
              for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
                frame.evaluateExpression(source, false, void 0, "main").catch((e) => {
                });
            }
            const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ":";
            if (isInitialEmptyPage) {
              lifecycleEventsEnabled.then(() => {
                this._eventListeners.push(helper_1.helper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
              });
            } else {
              this._firstNonInitialNavigationCommittedFulfill();
              this._eventListeners.push(helper_1.helper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
            }
          }),
          this._client.send("Log.enable", {}),
          lifecycleEventsEnabled = this._client.send("Page.setLifecycleEventsEnabled", {enabled: true}),
          this._client.send("Runtime.enable", {}),
          this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: "",
            worldName: UTILITY_WORLD_NAME
          }),
          this._networkManager.initialize(),
          this._client.send("Target.setAutoAttach", {autoAttach: true, waitForDebuggerOnStart: true, flatten: true})
        ];
        if (this._isMainFrame())
          promises.push(this._client.send("Emulation.setFocusEmulationEnabled", {enabled: true}));
        const options2 = this._crPage._browserContext._options;
        if (options2.bypassCSP)
          promises.push(this._client.send("Page.setBypassCSP", {enabled: true}));
        if (options2.ignoreHTTPSErrors)
          promises.push(this._client.send("Security.setIgnoreCertificateErrors", {ignore: true}));
        if (this._isMainFrame())
          promises.push(this._updateViewport());
        if (options2.hasTouch)
          promises.push(this._client.send("Emulation.setTouchEmulationEnabled", {enabled: true}));
        if (options2.javaScriptEnabled === false)
          promises.push(this._client.send("Emulation.setScriptExecutionDisabled", {value: true}));
        if (options2.userAgent || options2.locale)
          promises.push(this._client.send("Emulation.setUserAgentOverride", {userAgent: options2.userAgent || "", acceptLanguage: options2.locale}));
        if (options2.locale)
          promises.push(emulateLocale(this._client, options2.locale));
        if (options2.timezoneId)
          promises.push(emulateTimezone(this._client, options2.timezoneId));
        promises.push(this._updateGeolocation(true));
        promises.push(this._updateExtraHTTPHeaders(true));
        promises.push(this._updateRequestInterception(true));
        promises.push(this._updateOffline(true));
        promises.push(this._updateHttpCredentials(true));
        promises.push(this._updateEmulateMedia(true));
        for (const binding of this._crPage._page.allBindings())
          promises.push(this._initBinding(binding));
        for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
          promises.push(this._evaluateOnNewDocument(source, "main"));
        for (const source of this._crPage._page._evaluateOnNewDocumentSources)
          promises.push(this._evaluateOnNewDocument(source, "main"));
        if (screencastOptions)
          promises.push(this._startVideoRecording(screencastOptions));
        promises.push(this._client.send("Runtime.runIfWaitingForDebugger"));
        promises.push(this._firstNonInitialNavigationCommittedPromise);
        await Promise.all(promises);
      }
      dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._crPage._sessions.delete(this._targetId);
      }
      async _navigate(frame, url, referrer) {
        const response = await this._client.send("Page.navigate", {url, referrer, frameId: frame._id});
        if (response.errorText)
          throw new Error(`${response.errorText} at ${url}`);
        return {newDocumentId: response.loaderId};
      }
      _onLifecycleEvent(event) {
        if (event.name === "load")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "load");
        else if (event.name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded");
      }
      _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _onFrameAttached(frameId, parentFrameId) {
        const frameSession = this._crPage._sessions.get(frameId);
        if (frameSession && frameId !== this._targetId) {
          frameSession._swappedIn = true;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
          return;
        }
        this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        if (!this._page._frameManager.frame(framePayload.id))
          return;
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ""), framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameRequestedNavigation(payload) {
        if (payload.disposition === "currentTab")
          this._page._frameManager.frameRequestedNavigation(payload.frameId);
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId, reason) {
        if (this._crPage._sessions.has(frameId)) {
          return;
        }
        if (reason === "swap") {
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        this._page._frameManager.frameDetached(frameId);
      }
      _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame)
          return;
        const delegate = new crExecutionContext_1.CRExecutionContext(this._client, contextPayload);
        let worldName = null;
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
          worldName = "main";
        else if (contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
          this._onExecutionContextDestroyed(contextId);
      }
      _onAttachedToTarget(event) {
        const session = crConnection_1.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type === "iframe") {
          const targetId = event.targetInfo.targetId;
          const frame = this._page._frameManager.frame(targetId);
          if (!frame)
            return;
          this._page._frameManager.removeChildFramesRecursively(frame);
          const frameSession = new FrameSession(this._crPage, session, targetId, this);
          this._crPage._sessions.set(targetId, frameSession);
          frameSession._initialize(false).catch((e) => e);
          return;
        }
        if (event.targetInfo.type !== "worker") {
          session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
            this._client._sendMayFail("Target.detachFromTarget", {sessionId: event.sessionId});
          });
          return;
        }
        const url = event.targetInfo.url;
        const worker = new page_1.Worker(this._page, url);
        this._page._addWorker(event.sessionId, worker);
        session.once("Runtime.executionContextCreated", async (event2) => {
          worker._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event2.context));
        });
        session._sendMayFail("Runtime.enable");
        session._sendMayFail("Network.enable");
        session._sendMayFail("Runtime.runIfWaitingForDebugger");
        session.on("Runtime.consoleAPICalled", (event2) => {
          const args = event2.args.map((o) => worker._existingExecutionContext.createHandle(o));
          this._page._addConsoleMessage(event2.type, args, crProtocolHelper_1.toConsoleMessageLocation(event2.stackTrace));
        });
        session.on("Runtime.exceptionThrown", (exception) => this._page.emit(page_1.Page.Events.PageError, crProtocolHelper_1.exceptionToError(exception.exceptionDetails)));
        this._networkManager.instrumentNetworkEvents(session, this._page._frameManager.frame(this._targetId));
      }
      _onDetachedFromTarget(event) {
        this._page._removeWorker(event.sessionId);
        const childFrameSession = this._crPage._sessions.get(event.targetId);
        if (!childFrameSession)
          return;
        if (childFrameSession._swappedIn) {
          childFrameSession.dispose();
          return;
        }
        this._client.send("Page.enable").catch((e) => null).then(() => {
          if (!childFrameSession._swappedIn)
            this._page._frameManager.frameDetached(event.targetId);
          childFrameSession.dispose();
        });
      }
      _onWindowOpen(event) {
        this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
      }
      async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
          return;
        }
        const context = this._contextIdToContext.get(event.executionContextId);
        const values = event.args.map((arg) => context.createHandle(arg));
        this._page._addConsoleMessage(event.type, values, crProtocolHelper_1.toConsoleMessageLocation(event.stackTrace));
      }
      async _initBinding(binding) {
        const worldName = binding.world === "utility" ? UTILITY_WORLD_NAME : void 0;
        await Promise.all([
          this._client.send("Runtime.addBinding", {name: binding.name, executionContextName: worldName}),
          this._client.send("Page.addScriptToEvaluateOnNewDocument", {source: binding.source, worldName})
        ]);
      }
      async _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        const pageOrError = await this._crPage.pageOrError();
        if (!(pageOrError instanceof Error))
          await this._page._onBindingCalled(event.payload, context);
      }
      _onDialog(event) {
        if (!this._page._frameManager.frame(this._targetId))
          return;
        this._page.emit(page_1.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
          await this._client.send("Page.handleJavaScriptDialog", {accept, promptText});
        }, event.defaultPrompt));
      }
      _handleException(exceptionDetails) {
        this._page.emit(page_1.Page.Events.PageError, crProtocolHelper_1.exceptionToError(exceptionDetails));
      }
      async _onTargetCrashed() {
        this._client._markAsCrashed();
        this._page._didCrash();
      }
      _onLogEntryAdded(event) {
        const {level, text, args, source, url, lineNumber} = event.entry;
        if (args)
          args.map((arg) => crProtocolHelper_1.releaseObject(this._client, arg.objectId));
        if (source !== "worker") {
          const location2 = {
            url: url || "",
            lineNumber: lineNumber || 0,
            columnNumber: 0
          };
          this._page.emit(page_1.Page.Events.Console, new console_1.ConsoleMessage(this._page, level, text, [], location2));
        }
      }
      async _onFileChooserOpened(event) {
        const frame = this._page._frameManager.frame(event.frameId);
        if (!frame)
          return;
        let handle;
        try {
          const utilityContext = await frame._utilityContext();
          handle = await this._adoptBackendNodeId(event.backendNodeId, utilityContext);
        } catch (e) {
          return;
        }
        await this._page._onFileChooserOpened(handle);
      }
      _onDownloadWillBegin(payload) {
        let originPage = this._crPage._initializedPage;
        if (!originPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
          if (this._crPage._opener)
            originPage = this._crPage._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._crPage._browserContext._browser._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
      }
      _onDownloadProgress(payload) {
        if (payload.state === "completed")
          this._crPage._browserContext._browser._downloadFinished(payload.guid, "");
        if (payload.state === "canceled")
          this._crPage._browserContext._browser._downloadFinished(payload.guid, "canceled");
      }
      _onScreencastFrame(payload) {
        this._client.send("Page.screencastFrameAck", {sessionId: payload.sessionId}).catch(() => {
        });
        const buffer = Buffer.from(payload.data, "base64");
        this._page.emit(page_1.Page.Events.ScreencastFrame, {
          buffer,
          timestamp: payload.metadata.timestamp,
          width: payload.metadata.deviceWidth,
          height: payload.metadata.deviceHeight
        });
      }
      async _createVideoRecorder(screencastId, options2) {
        utils_1.assert(!this._screencastId);
        const ffmpegPath = this._crPage._browserContext._browser.options.registry.executablePath("ffmpeg");
        if (!ffmpegPath)
          throw new Error("ffmpeg executable was not found");
        if (!utils_1.canAccessFile(ffmpegPath)) {
          let message = "";
          switch (this._page._browserContext._options.sdkLanguage) {
            case "python":
              message = "playwright install ffmpeg";
              break;
            case "python-async":
              message = "playwright install ffmpeg";
              break;
            case "javascript":
              message = "npx playwright install ffmpeg";
              break;
            case "java":
              message = 'mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="install ffmpeg"';
              break;
          }
          throw new Error(`
============================================================
  Please install ffmpeg in order to record video.

  $ ${message}
============================================================
      `);
        }
        this._videoRecorder = await videoRecorder_1.VideoRecorder.launch(this._crPage._page, ffmpegPath, options2);
        this._screencastId = screencastId;
      }
      async _startVideoRecording(options2) {
        const screencastId = this._screencastId;
        utils_1.assert(screencastId);
        this._page.once(page_1.Page.Events.Close, () => this._stopVideoRecording().catch(() => {
        }));
        const gotFirstFrame = new Promise((f) => this._client.once("Page.screencastFrame", f));
        await this._startScreencast(this._videoRecorder, {
          format: "jpeg",
          quality: 90,
          maxWidth: options2.width,
          maxHeight: options2.height
        });
        gotFirstFrame.then(() => {
          this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options2.outputFile, this._crPage.pageOrError());
        });
      }
      async _stopVideoRecording() {
        if (!this._screencastId)
          return;
        const screencastId = this._screencastId;
        this._screencastId = null;
        const recorder = this._videoRecorder;
        this._videoRecorder = null;
        await this._stopScreencast(recorder);
        await recorder.stop().catch(() => {
        });
        const video = this._crPage._browserContext._browser._takeVideo(screencastId);
        video === null || video === void 0 ? void 0 : video.reportFinished();
      }
      async _startScreencast(client, options2 = {}) {
        this._screencastClients.add(client);
        if (this._screencastClients.size === 1)
          await this._client.send("Page.startScreencast", options2);
      }
      async _stopScreencast(client) {
        this._screencastClients.delete(client);
        if (!this._screencastClients.size)
          await this._client._sendMayFail("Page.stopScreencast");
      }
      async _updateExtraHTTPHeaders(initial) {
        const headers = network.mergeHeaders([
          this._crPage._browserContext._options.extraHTTPHeaders,
          this._page._state.extraHTTPHeaders
        ]);
        if (!initial || headers.length)
          await this._client.send("Network.setExtraHTTPHeaders", {headers: utils_1.headersArrayToObject(headers, false)});
      }
      async _updateGeolocation(initial) {
        const geolocation = this._crPage._browserContext._options.geolocation;
        if (!initial || geolocation)
          await this._client.send("Emulation.setGeolocationOverride", geolocation || {});
      }
      async _updateOffline(initial) {
        const offline = !!this._crPage._browserContext._options.offline;
        if (!initial || offline)
          await this._networkManager.setOffline(offline);
      }
      async _updateHttpCredentials(initial) {
        const credentials = this._crPage._browserContext._options.httpCredentials || null;
        if (!initial || credentials)
          await this._networkManager.authenticate(credentials);
      }
      async _updateViewport() {
        if (this._crPage._browserContext._browser.isClank())
          return;
        utils_1.assert(this._isMainFrame());
        const options2 = this._crPage._browserContext._options;
        const emulatedSize = this._page._state.emulatedSize;
        if (emulatedSize === null)
          return;
        const viewportSize = emulatedSize.viewport;
        const screenSize = emulatedSize.screen;
        const isLandscape = viewportSize.width > viewportSize.height;
        const promises = [
          this._client.send("Emulation.setDeviceMetricsOverride", {
            mobile: !!options2.isMobile,
            width: viewportSize.width,
            height: viewportSize.height,
            screenWidth: screenSize.width,
            screenHeight: screenSize.height,
            deviceScaleFactor: options2.deviceScaleFactor || 1,
            screenOrientation: isLandscape ? {angle: 90, type: "landscapePrimary"} : {angle: 0, type: "portraitPrimary"}
          })
        ];
        if (this._windowId) {
          let insets = {width: 0, height: 0};
          if (this._crPage._browserContext._browser.options.headful) {
            insets = {width: 24, height: 88};
            if (process.platform === "win32")
              insets = {width: 16, height: 88};
            else if (process.platform === "linux")
              insets = {width: 8, height: 85};
            else if (process.platform === "darwin")
              insets = {width: 2, height: 80};
          }
          promises.push(this.setWindowBounds({
            width: viewportSize.width + insets.width,
            height: viewportSize.height + insets.height
          }));
        }
        await Promise.all(promises);
      }
      async windowBounds() {
        const {bounds} = await this._client.send("Browser.getWindowBounds", {
          windowId: this._windowId
        });
        return bounds;
      }
      async setWindowBounds(bounds) {
        return await this._client.send("Browser.setWindowBounds", {
          windowId: this._windowId,
          bounds
        });
      }
      async _updateEmulateMedia(initial) {
        if (this._crPage._browserContext._browser.isClank())
          return;
        const colorScheme = this._page._state.colorScheme || this._crPage._browserContext._options.colorScheme || "light";
        const features = colorScheme ? [{name: "prefers-color-scheme", value: colorScheme}] : [];
        await this._client.send("Emulation.setEmulatedMedia", {media: this._page._state.mediaType || "", features});
      }
      async _updateRequestInterception(initial) {
        await this._networkManager.setRequestInterception(this._page._needsRequestInterception());
      }
      async _setFileChooserIntercepted(enabled) {
        await this._client.send("Page.setInterceptFileChooserDialog", {enabled}).catch((e) => {
        });
      }
      async _evaluateOnNewDocument(source, world) {
        const worldName = world === "utility" ? UTILITY_WORLD_NAME : void 0;
        await this._client.send("Page.addScriptToEvaluateOnNewDocument", {source, worldName});
      }
      async _getContentFrame(handle) {
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        if (!nodeInfo || typeof nodeInfo.node.frameId !== "string")
          return null;
        return this._page._frameManager.frame(nodeInfo.node.frameId);
      }
      async _getOwnerFrame(handle) {
        const documentElement = await handle.evaluateHandle((node) => {
          const doc = node;
          if (doc.documentElement && doc.documentElement.ownerDocument === doc)
            return doc.documentElement;
          return node.ownerDocument ? node.ownerDocument.documentElement : null;
        });
        if (!documentElement)
          return null;
        if (!documentElement._objectId)
          return null;
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: documentElement._objectId
        });
        const frameId = nodeInfo && typeof nodeInfo.node.frameId === "string" ? nodeInfo.node.frameId : null;
        documentElement.dispose();
        return frameId;
      }
      async _getBoundingBox(handle) {
        const result = await this._client._sendMayFail("DOM.getBoxModel", {
          objectId: handle._objectId
        });
        if (!result)
          return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        const position = await this._framePosition();
        if (!position)
          return null;
        return {x: x + position.x, y: y + position.y, width, height};
      }
      async _framePosition() {
        const frame = this._page._frameManager.frame(this._targetId);
        if (!frame)
          return null;
        if (frame === this._page.mainFrame())
          return {x: 0, y: 0};
        const element = await frame.frameElement();
        const box = await element.boundingBox();
        return box;
      }
      async _scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._client.send("DOM.scrollIntoViewIfNeeded", {
          objectId: handle._objectId,
          rect
        }).then(() => "done").catch((e) => {
          if (e instanceof Error && e.message.includes("Node does not have a layout object"))
            return "error:notvisible";
          if (e instanceof Error && e.message.includes("Node is detached from document"))
            return "error:notconnected";
          throw e;
        });
      }
      async _getContentQuads(handle) {
        const result = await this._client._sendMayFail("DOM.getContentQuads", {
          objectId: handle._objectId
        });
        if (!result)
          return null;
        const position = await this._framePosition();
        if (!position)
          return null;
        return result.quads.map((quad) => [
          {x: quad[0] + position.x, y: quad[1] + position.y},
          {x: quad[2] + position.x, y: quad[3] + position.y},
          {x: quad[4] + position.x, y: quad[5] + position.y},
          {x: quad[6] + position.x, y: quad[7] + position.y}
        ]);
      }
      async _adoptElementHandle(handle, to) {
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
      }
      async _adoptBackendNodeId(backendNodeId, to) {
        const result = await this._client._sendMayFail("DOM.resolveNode", {
          backendNodeId,
          executionContextId: to._delegate._contextId
        });
        if (!result || result.object.subtype === "null")
          throw new Error("Unable to adopt element handle from a different document");
        return to.createHandle(result.object).asElement();
      }
    };
    async function emulateLocale(session, locale) {
      try {
        await session.send("Emulation.setLocaleOverride", {locale});
      } catch (exception) {
        if (exception.message.includes("Another locale override is already in effect"))
          return;
        throw exception;
      }
    }
    async function emulateTimezone(session, timezoneId) {
      try {
        await session.send("Emulation.setTimezoneOverride", {timezoneId});
      } catch (exception) {
        if (exception.message.includes("Timezone override is already in effect"))
          return;
        if (exception.message.includes("Invalid timezone"))
          throw new Error(`Invalid timezone ID: ${timezoneId}`);
        throw exception;
      }
    }
  }
});

// node_modules/playwright/lib/server/chromium/crBrowser.js
var require_crBrowser = __commonJS({
  "node_modules/playwright/lib/server/chromium/crBrowser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRBrowserContext = exports2.CRBrowser = void 0;
    var browser_1 = require_browser2();
    var browserContext_1 = require_browserContext();
    var utils_1 = require_utils();
    var network = __importStar(require_network());
    var page_1 = require_page();
    var crConnection_1 = require_crConnection();
    var crPage_1 = require_crPage();
    var crProtocolHelper_1 = require_crProtocolHelper();
    var crExecutionContext_1 = require_crExecutionContext();
    var CRBrowser = class extends browser_1.Browser {
      constructor(connection, options2) {
        super(options2);
        this._clientRootSessionPromise = null;
        this._contexts = new Map();
        this._crPages = new Map();
        this._backgroundPages = new Map();
        this._serviceWorkers = new Map();
        this._isMac = false;
        this._version = "";
        this._tracingRecording = false;
        this._tracingPath = "";
        this._connection = connection;
        this._session = this._connection.rootSession;
        this._connection.on(crConnection_1.ConnectionEvents.Disconnected, () => this._didClose());
        this._session.on("Target.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._session.on("Target.detachedFromTarget", this._onDetachedFromTarget.bind(this));
      }
      static async connect(transport, options2, devtools) {
        const connection = new crConnection_1.CRConnection(transport, options2.protocolLogger, options2.browserLogsCollector);
        const browser = new CRBrowser(connection, options2);
        browser._devtools = devtools;
        const session = connection.rootSession;
        if (options2.__testHookOnConnectToBrowser)
          await options2.__testHookOnConnectToBrowser();
        const version = await session.send("Browser.getVersion");
        browser._isMac = version.userAgent.includes("Macintosh");
        browser._version = version.product.substring(version.product.indexOf("/") + 1);
        if (!options2.persistent) {
          await session.send("Target.setAutoAttach", {autoAttach: true, waitForDebuggerOnStart: true, flatten: true});
          return browser;
        }
        browser._defaultContext = new CRBrowserContext(browser, void 0, options2.persistent);
        await Promise.all([
          session.send("Target.setAutoAttach", {autoAttach: true, waitForDebuggerOnStart: true, flatten: true}).then(async () => {
            await session.send("Target.getTargetInfo");
          }),
          browser._defaultContext._initialize()
        ]);
        await browser._waitForAllPagesToBeInitialized();
        return browser;
      }
      async newContext(options2) {
        browserContext_1.validateBrowserContextOptions(options2, this.options);
        const {browserContextId} = await this._session.send("Target.createBrowserContext", {
          disposeOnDetach: true,
          proxyServer: options2.proxy ? options2.proxy.server : void 0,
          proxyBypassList: options2.proxy ? options2.proxy.bypass : void 0
        });
        const context = new CRBrowserContext(this, browserContextId, options2);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      isClank() {
        return this.options.name === "clank";
      }
      async _waitForAllPagesToBeInitialized() {
        await Promise.all([...this._crPages.values()].map((page) => page.pageOrError()));
      }
      _onAttachedToTarget({targetInfo, sessionId, waitingForDebugger}) {
        if (targetInfo.type === "browser")
          return;
        const session = this._connection.session(sessionId);
        utils_1.assert(targetInfo.browserContextId, "targetInfo: " + JSON.stringify(targetInfo, null, 2));
        let context = this._contexts.get(targetInfo.browserContextId) || null;
        if (!context) {
          context = this._defaultContext;
        }
        if (targetInfo.type === "other" && targetInfo.url.startsWith("devtools://devtools") && this._devtools) {
          this._devtools.install(session);
          return;
        }
        if (targetInfo.type === "other" || !context) {
          if (waitingForDebugger) {
            session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
              this._session._sendMayFail("Target.detachFromTarget", {sessionId});
            });
          }
          return;
        }
        utils_1.assert(!this._crPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        utils_1.assert(!this._backgroundPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        utils_1.assert(!this._serviceWorkers.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        if (targetInfo.type === "background_page") {
          const backgroundPage = new crPage_1.CRPage(session, targetInfo.targetId, context, null, false, true);
          this._backgroundPages.set(targetInfo.targetId, backgroundPage);
          return;
        }
        if (targetInfo.type === "page") {
          const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
          const crPage = new crPage_1.CRPage(session, targetInfo.targetId, context, opener, true, false);
          this._crPages.set(targetInfo.targetId, crPage);
          return;
        }
        if (targetInfo.type === "service_worker") {
          const serviceWorker = new CRServiceWorker(context, session, targetInfo.url);
          this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
          context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
          return;
        }
        utils_1.assert(false, "Unknown target type: " + targetInfo.type);
      }
      _onDetachedFromTarget(payload) {
        const targetId = payload.targetId;
        const crPage = this._crPages.get(targetId);
        if (crPage) {
          this._crPages.delete(targetId);
          crPage.didClose();
          return;
        }
        const backgroundPage = this._backgroundPages.get(targetId);
        if (backgroundPage) {
          this._backgroundPages.delete(targetId);
          backgroundPage.didClose();
          return;
        }
        const serviceWorker = this._serviceWorkers.get(targetId);
        if (serviceWorker) {
          this._serviceWorkers.delete(targetId);
          serviceWorker.emit(page_1.Worker.Events.Close);
          return;
        }
      }
      async _closePage(crPage) {
        await this._session.send("Target.closeTarget", {targetId: crPage._targetId});
      }
      async newBrowserCDPSession() {
        return await this._connection.createBrowserSession();
      }
      async startTracing(page, options2 = {}) {
        utils_1.assert(!this._tracingRecording, "Cannot start recording trace while already recording trace.");
        this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
        const defaultCategories = [
          "-*",
          "devtools.timeline",
          "v8.execute",
          "disabled-by-default-devtools.timeline",
          "disabled-by-default-devtools.timeline.frame",
          "toplevel",
          "blink.console",
          "blink.user_timing",
          "latencyInfo",
          "disabled-by-default-devtools.timeline.stack",
          "disabled-by-default-v8.cpu_profiler",
          "disabled-by-default-v8.cpu_profiler.hires"
        ];
        const {path = null, screenshots = false, categories = defaultCategories} = options2;
        if (screenshots)
          categories.push("disabled-by-default-devtools.screenshot");
        this._tracingPath = path;
        this._tracingRecording = true;
        await this._tracingClient.send("Tracing.start", {
          transferMode: "ReturnAsStream",
          categories: categories.join(",")
        });
      }
      async stopTracing() {
        utils_1.assert(this._tracingClient, "Tracing was not started.");
        const [event] = await Promise.all([
          new Promise((f) => this._tracingClient.once("Tracing.tracingComplete", f)),
          this._tracingClient.send("Tracing.end")
        ]);
        const result = await crProtocolHelper_1.readProtocolStream(this._tracingClient, event.stream, this._tracingPath);
        this._tracingRecording = false;
        return result;
      }
      isConnected() {
        return !this._connection._closed;
      }
      async _clientRootSession() {
        if (!this._clientRootSessionPromise)
          this._clientRootSessionPromise = this._connection.createBrowserSession();
        return this._clientRootSessionPromise;
      }
    };
    exports2.CRBrowser = CRBrowser;
    var CRServiceWorker = class extends page_1.Worker {
      constructor(browserContext, session, url) {
        super(browserContext, url);
        this._browserContext = browserContext;
        session.once("Runtime.executionContextCreated", (event) => {
          this._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
        });
        session.send("Runtime.enable", {}).catch((e) => {
        });
        session.send("Runtime.runIfWaitingForDebugger").catch((e) => {
        });
      }
    };
    var CRBrowserContext = class extends browserContext_1.BrowserContext {
      constructor(browser, browserContextId, options2) {
        super(browser, options2, browserContextId);
        this._browser = browser;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaCredentials();
      }
      async _initialize() {
        utils_1.assert(!Array.from(this._browser._crPages.values()).some((page) => page._browserContext === this));
        const promises = [super._initialize()];
        if (this._browser.options.downloadsPath) {
          promises.push(this._browser._session.send("Browser.setDownloadBehavior", {
            behavior: this._options.acceptDownloads ? "allowAndName" : "deny",
            browserContextId: this._browserContextId,
            downloadPath: this._browser.options.downloadsPath
          }));
        }
        if (this._options.permissions)
          promises.push(this.grantPermissions(this._options.permissions));
        await Promise.all(promises);
      }
      pages() {
        const result = [];
        for (const crPage of this._browser._crPages.values()) {
          if (crPage._browserContext === this && crPage._initializedPage)
            result.push(crPage._initializedPage);
        }
        return result;
      }
      async newPageDelegate() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : void 0;
        let {targetId} = await this._browser._session.send("Target.createTarget", {url: "about:blank", browserContextId: this._browserContextId});
        if (oldKeys) {
          const newKeys = new Set(this._browser._crPages.keys());
          for (const key of oldKeys)
            newKeys.delete(key);
          for (const key of newKeys) {
            const page = this._browser._crPages.get(key);
            if (page._opener)
              newKeys.delete(key);
          }
          utils_1.assert(newKeys.size === 1);
          [targetId] = [...newKeys];
        }
        return this._browser._crPages.get(targetId);
      }
      async _doCookies(urls) {
        const {cookies} = await this._browser._session.send("Storage.getCookies", {browserContextId: this._browserContextId});
        return network.filterCookies(cookies.map((c) => {
          const copy = {sameSite: "None", ...c};
          delete copy.size;
          delete copy.priority;
          delete copy.session;
          delete copy.sameParty;
          delete copy.sourceScheme;
          delete copy.sourcePort;
          return copy;
        }), urls);
      }
      async addCookies(cookies) {
        await this._browser._session.send("Storage.setCookies", {cookies: network.rewriteCookies(cookies), browserContextId: this._browserContextId});
      }
      async clearCookies() {
        await this._browser._session.send("Storage.clearCookies", {browserContextId: this._browserContextId});
      }
      async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
          ["geolocation", "geolocation"],
          ["midi", "midi"],
          ["notifications", "notifications"],
          ["camera", "videoCapture"],
          ["microphone", "audioCapture"],
          ["background-sync", "backgroundSync"],
          ["ambient-light-sensor", "sensors"],
          ["accelerometer", "sensors"],
          ["gyroscope", "sensors"],
          ["magnetometer", "sensors"],
          ["accessibility-events", "accessibilityEvents"],
          ["clipboard-read", "clipboardReadWrite"],
          ["clipboard-write", "clipboardSanitizedWrite"],
          ["payment-handler", "paymentHandler"],
          ["midi-sysex", "midiSysex"]
        ]);
        const filtered = permissions.map((permission) => {
          const protocolPermission = webPermissionToProtocol.get(permission);
          if (!protocolPermission)
            throw new Error("Unknown permission: " + permission);
          return protocolPermission;
        });
        await this._browser._session.send("Browser.grantPermissions", {origin: origin === "*" ? void 0 : origin, browserContextId: this._browserContextId, permissions: filtered});
      }
      async _doClearPermissions() {
        await this._browser._session.send("Browser.resetPermissions", {browserContextId: this._browserContextId});
      }
      async setGeolocation(geolocation) {
        browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation;
        for (const page of this.pages())
          await page._delegate.updateGeolocation();
      }
      async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        for (const page of this.pages())
          await page._delegate.updateExtraHTTPHeaders();
      }
      async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
          await page._delegate.updateOffline();
      }
      async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        for (const page of this.pages())
          await page._delegate.updateHttpCredentials();
      }
      async _doAddInitScript(source) {
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
          await page._delegate.evaluateOnNewDocument(source);
      }
      async _doExposeBinding(binding) {
        for (const page of this.pages())
          await page._delegate.exposeBinding(binding);
      }
      async _doUpdateRequestInterception() {
        for (const page of this.pages())
          await page._delegate.updateRequestInterception();
      }
      async _doClose() {
        utils_1.assert(this._browserContextId);
        await this._browser._session.send("Target.disposeBrowserContext", {browserContextId: this._browserContextId});
        this._browser._contexts.delete(this._browserContextId);
        for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
          if (serviceWorker._browserContext !== this)
            continue;
          serviceWorker.emit(page_1.Worker.Events.Close);
          this._browser._serviceWorkers.delete(targetId);
        }
      }
      backgroundPages() {
        const result = [];
        for (const backgroundPage of this._browser._backgroundPages.values()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage)
            result.push(backgroundPage._initializedPage);
        }
        return result;
      }
      serviceWorkers() {
        return Array.from(this._browser._serviceWorkers.values()).filter((serviceWorker) => serviceWorker._browserContext === this);
      }
      async newCDPSession(page) {
        if (!(page instanceof page_1.Page))
          throw new Error("page: expected Page");
        const targetId = page._delegate._targetId;
        const rootSession = await this._browser._clientRootSession();
        const {sessionId} = await rootSession.send("Target.attachToTarget", {targetId, flatten: true});
        return this._browser._connection.session(sessionId);
      }
    };
    exports2.CRBrowserContext = CRBrowserContext;
    CRBrowserContext.CREvents = {
      BackgroundPage: "backgroundpage",
      ServiceWorker: "serviceworker"
    };
  }
});

// node_modules/playwright/lib/protocol/transport.js
var require_transport = __commonJS({
  "node_modules/playwright/lib/protocol/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Transport = void 0;
    var utils_1 = require_utils();
    var Transport = class {
      constructor(pipeWrite, pipeRead, closeable, endian = "le") {
        this._data = Buffer.from([]);
        this._waitForNextTask = utils_1.makeWaitForNextTask();
        this._closed = false;
        this._bytesLeft = 0;
        this._pipeWrite = pipeWrite;
        this._endian = endian;
        this._closeableStream = closeable;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose();
        });
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        const data = Buffer.from(message, "utf-8");
        const dataLength = Buffer.alloc(4);
        if (this._endian === "be")
          dataLength.writeUInt32BE(data.length, 0);
        else
          dataLength.writeUInt32LE(data.length, 0);
        this._pipeWrite.write(dataLength);
        this._pipeWrite.write(data);
      }
      close() {
        this._closeableStream.close();
      }
      _dispatch(buffer) {
        this._data = Buffer.concat([this._data, buffer]);
        while (true) {
          if (!this._bytesLeft && this._data.length < 4) {
            break;
          }
          if (!this._bytesLeft) {
            this._bytesLeft = this._endian === "be" ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
            this._data = this._data.slice(4);
          }
          if (!this._bytesLeft || this._data.length < this._bytesLeft) {
            break;
          }
          const message = this._data.slice(0, this._bytesLeft);
          this._data = this._data.slice(this._bytesLeft);
          this._bytesLeft = 0;
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(message.toString("utf-8"));
          });
        }
      }
    };
    exports2.Transport = Transport;
  }
});

// node_modules/playwright/lib/server/android/android.js
var require_android = __commonJS({
  "node_modules/playwright/lib/server/android/android.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.AndroidDevice = exports2.Android = void 0;
    var debug_1 = __importDefault(require_src());
    var events_1 = require("events");
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var ws = __importStar(require_ws());
    var utils_1 = require_utils();
    var browserContext_1 = require_browserContext();
    var progress_1 = require_progress();
    var crBrowser_1 = require_crBrowser();
    var helper_1 = require_helper();
    var transport_1 = require_transport();
    var debugLogger_1 = require_debugLogger();
    var timeoutSettings_1 = require_timeoutSettings();
    var instrumentation_1 = require_instrumentation();
    var readFileAsync = util.promisify(fs_1.default.readFile);
    var Android = class extends instrumentation_1.SdkObject {
      constructor(backend, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "android");
        this._devices = new Map();
        this._backend = backend;
        this._playwrightOptions = playwrightOptions;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async devices() {
        const devices2 = (await this._backend.devices()).filter((d) => d.status === "device");
        const newSerials = new Set();
        for (const d of devices2) {
          newSerials.add(d.serial);
          if (this._devices.has(d.serial))
            continue;
          const device = await AndroidDevice.create(this, d);
          this._devices.set(d.serial, device);
        }
        for (const d of this._devices.keys()) {
          if (!newSerials.has(d))
            this._devices.delete(d);
        }
        return [...this._devices.values()];
      }
      _deviceClosed(device) {
        this._devices.delete(device.serial);
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends instrumentation_1.SdkObject {
      constructor(android, backend, model) {
        super(android, "android-device");
        this._lastId = 0;
        this._callbacks = new Map();
        this._webViews = new Map();
        this._browserConnections = new Set();
        this._isClosed = false;
        this._android = android;
        this._backend = backend;
        this.model = model;
        this.serial = backend.serial;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(android._timeoutSettings);
      }
      static async create(android, backend) {
        await backend.init();
        const model = await backend.runCommand("shell:getprop ro.product.model");
        const device = new AndroidDevice(android, backend, model.toString().trim());
        await device._init();
        return device;
      }
      async _init() {
        await this._refreshWebViews();
        const poll = () => {
          this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {
          }), 500);
        };
        poll();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async shell(command) {
        const result = await this._backend.runCommand(`shell:${command}`);
        await this._refreshWebViews();
        return result;
      }
      async open(command) {
        return await this._backend.open(`${command}`);
      }
      async screenshot() {
        return await this._backend.runCommand(`shell:screencap -p`);
      }
      async _driver() {
        if (!this._driverPromise)
          this._driverPromise = this._installDriver();
        return this._driverPromise;
      }
      async _installDriver() {
        debug_1.default("pw:android")("Stopping the old driver");
        await this.shell(`am force-stop com.microsoft.playwright.androiddriver`);
        debug_1.default("pw:android")("Uninstalling the old driver");
        await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
        await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
        debug_1.default("pw:android")("Installing the new driver");
        for (const file of ["android-driver.apk", "android-driver-target.apk"])
          await this.installApk(await readFileAsync(require.resolve(`../../../bin/${file}`)));
        debug_1.default("pw:android")("Starting the new driver");
        this.shell("am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner").catch((e) => debug_1.default("pw:android")(e));
        const socket = await this._waitForLocalAbstract("playwright_android_driver_socket");
        const transport = new transport_1.Transport(socket, socket, socket, "be");
        transport.onmessage = (message) => {
          const response = JSON.parse(message);
          const {id, result, error: error3} = response;
          const callback = this._callbacks.get(id);
          if (!callback)
            return;
          if (error3)
            callback.reject(new Error(error3));
          else
            callback.fulfill(result);
          this._callbacks.delete(id);
        };
        return transport;
      }
      async _waitForLocalAbstract(socketName) {
        let socket;
        debug_1.default("pw:android")(`Polling the socket localabstract:${socketName}`);
        while (!socket) {
          try {
            socket = await this._backend.open(`localabstract:${socketName}`);
          } catch (e) {
            await new Promise((f) => setTimeout(f, 250));
          }
        }
        debug_1.default("pw:android")(`Connected to localabstract:${socketName}`);
        return socket;
      }
      async send(method, params = {}) {
        params.timeout = this._timeoutSettings.timeout(params);
        const driver = await this._driver();
        const id = ++this._lastId;
        const result = new Promise((fulfill, reject) => this._callbacks.set(id, {fulfill, reject}));
        driver.send(JSON.stringify({id, method, params}));
        return result;
      }
      async close() {
        this._isClosed = true;
        if (this._pollingWebViews)
          clearTimeout(this._pollingWebViews);
        for (const connection of this._browserConnections)
          await connection.close();
        if (this._driverPromise) {
          const driver = await this._driver();
          driver.close();
        }
        await this._backend.close();
        this._android._deviceClosed(this);
        this.emit(AndroidDevice.Events.Closed);
      }
      async launchBrowser(pkg2 = "com.android.chrome", options2) {
        debug_1.default("pw:android")("Force-stopping", pkg2);
        await this._backend.runCommand(`shell:am force-stop ${pkg2}`);
        const socketName = "playwright-" + utils_1.createGuid();
        const commandLine = `_ --disable-fre --no-default-browser-check --no-first-run --remote-debugging-socket-name=${socketName}`;
        debug_1.default("pw:android")("Starting", pkg2, commandLine);
        await this._backend.runCommand(`shell:echo "${commandLine}" > /data/local/tmp/chrome-command-line`);
        await this._backend.runCommand(`shell:am start -n ${pkg2}/com.google.android.apps.chrome.Main about:blank`);
        return await this._connectToBrowser(socketName, options2);
      }
      async connectToWebView(pid, sdkLanguage) {
        const webView = this._webViews.get(pid);
        if (!webView)
          throw new Error("WebView has been closed");
        return await this._connectToBrowser(`webview_devtools_remote_${pid}`, {sdkLanguage});
      }
      async _connectToBrowser(socketName, options2) {
        const socket = await this._waitForLocalAbstract(socketName);
        const androidBrowser = new AndroidBrowser(this, socket);
        await androidBrowser._init();
        this._browserConnections.add(androidBrowser);
        const browserOptions = {
          ...this._android._playwrightOptions,
          name: "clank",
          isChromium: true,
          slowMo: 0,
          persistent: {...options2, noDefaultViewport: true},
          downloadsPath: void 0,
          browserProcess: new ClankBrowserProcess(androidBrowser),
          proxy: options2.proxy,
          protocolLogger: helper_1.helper.debugProtocolLogger(),
          browserLogsCollector: new debugLogger_1.RecentLogsCollector()
        };
        browserContext_1.validateBrowserContextOptions(options2, browserOptions);
        const browser = await crBrowser_1.CRBrowser.connect(androidBrowser, browserOptions);
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), this);
        const defaultContext = browser._defaultContext;
        await controller.run(async (progress) => {
          await defaultContext._loadDefaultContextAsIs(progress);
        });
        {
          const page = defaultContext.pages()[0];
          const crPage = page._delegate;
          await crPage._mainFrameSession._client.send("Emulation.setDeviceMetricsOverride", {mobile: false, width: 0, height: 0, deviceScaleFactor: 0});
          await crPage._mainFrameSession._client.send("Emulation.clearDeviceMetricsOverride", {});
        }
        return defaultContext;
      }
      webViews() {
        return [...this._webViews.values()];
      }
      async installApk(content, options2) {
        const args = options2 && options2.args ? options2.args : ["-r", "-t", "-S"];
        debug_1.default("pw:android")("Opening install socket");
        const installSocket = await this._backend.open(`shell:cmd package install ${args.join(" ")} ${content.length}`);
        debug_1.default("pw:android")("Writing driver bytes: " + content.length);
        await installSocket.write(content);
        const success = await new Promise((f) => installSocket.on("data", f));
        debug_1.default("pw:android")("Written driver bytes: " + success);
        installSocket.close();
      }
      async push(content, path, mode = 420) {
        const socket = await this._backend.open(`sync:`);
        const sendHeader = async (command, length) => {
          const buffer = Buffer.alloc(command.length + 4);
          buffer.write(command, 0);
          buffer.writeUInt32LE(length, command.length);
          await socket.write(buffer);
        };
        const send = async (command, data) => {
          await sendHeader(command, data.length);
          await socket.write(data);
        };
        await send("SEND", Buffer.from(`${path},${mode}`));
        const maxChunk = 65535;
        for (let i = 0; i < content.length; i += maxChunk)
          await send("DATA", content.slice(i, i + maxChunk));
        await sendHeader("DONE", Date.now() / 1e3 | 0);
        const result = await new Promise((f) => socket.once("data", f));
        const code = result.slice(0, 4).toString();
        if (code !== "OKAY")
          throw new Error("Could not push: " + code);
        socket.close();
      }
      async _refreshWebViews() {
        const sockets = (await this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split("\n");
        if (this._isClosed)
          return;
        const newPids = new Set();
        for (const line of sockets) {
          const match = line.match(/[^@]+@webview_devtools_remote_(\d+)/);
          if (!match)
            continue;
          const pid = +match[1];
          newPids.add(pid);
        }
        for (const pid of newPids) {
          if (this._webViews.has(pid))
            continue;
          const procs = (await this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split("\n");
          if (this._isClosed)
            return;
          let pkg2 = "";
          for (const proc of procs) {
            const match = proc.match(/[^\s]+\s+(\d+).*$/);
            if (!match)
              continue;
            const p = match[1];
            if (+p !== pid)
              continue;
            pkg2 = proc.substring(proc.lastIndexOf(" ") + 1);
          }
          const webView = {pid, pkg: pkg2};
          this._webViews.set(pid, webView);
          this.emit(AndroidDevice.Events.WebViewAdded, webView);
        }
        for (const p of this._webViews.keys()) {
          if (!newPids.has(p)) {
            this._webViews.delete(p);
            this.emit(AndroidDevice.Events.WebViewRemoved, p);
          }
        }
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    AndroidDevice.Events = {
      WebViewAdded: "webViewAdded",
      WebViewRemoved: "webViewRemoved",
      Closed: "closed"
    };
    var AndroidBrowser = class extends events_1.EventEmitter {
      constructor(device, socket) {
        super();
        this._waitForNextTask = utils_1.makeWaitForNextTask();
        this.setMaxListeners(0);
        this.device = device;
        this._socket = socket;
        this._socket.on("close", () => {
          this._waitForNextTask(() => {
            if (this.onclose)
              this.onclose();
          });
        });
        this._receiver = new ws.Receiver();
        this._receiver.on("message", (message) => {
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(JSON.parse(message));
          });
        });
      }
      async _init() {
        await this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
        await new Promise((f) => this._socket.once("data", f));
        this._socket.on("data", (data) => this._receiver._write(data, "binary", () => {
        }));
      }
      async send(s2) {
        await this._socket.write(encodeWebFrame(JSON.stringify(s2)));
      }
      async close() {
        this._socket.close();
      }
    };
    function encodeWebFrame(data) {
      return ws.Sender.frame(Buffer.from(data), {
        opcode: 1,
        mask: true,
        fin: true,
        readOnly: true
      })[0];
    }
    var ClankBrowserProcess = class {
      constructor(browser) {
        this._browser = browser;
      }
      async kill() {
      }
      async close() {
        await this._browser.close();
      }
    };
  }
});

// node_modules/playwright/lib/server/android/backendAdb.js
var require_backendAdb = __commonJS({
  "node_modules/playwright/lib/server/android/backendAdb.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.AdbBackend = void 0;
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var net = __importStar(require("net"));
    var events_1 = require("events");
    var utils_1 = require_utils();
    var AdbBackend = class {
      async devices() {
        const result = await runCommand("host:devices");
        const lines = result.toString().trim().split("\n");
        return lines.map((line) => {
          const [serial, status] = line.trim().split("	");
          return new AdbDevice(serial, status);
        });
      }
    };
    exports2.AdbBackend = AdbBackend;
    var AdbDevice = class {
      constructor(serial, status) {
        this.serial = serial;
        this.status = status;
      }
      async init() {
      }
      async close() {
      }
      runCommand(command) {
        return runCommand(command, this.serial);
      }
      async open(command) {
        const result = await open(command, this.serial);
        result.becomeSocket();
        return result;
      }
    };
    async function runCommand(command, serial) {
      debug_1.default("pw:adb:runCommand")(command, serial);
      const socket = new BufferedSocketWrapper(command, net.createConnection({port: 5037}));
      if (serial) {
        await socket.write(encodeMessage(`host:transport:${serial}`));
        const status2 = await socket.read(4);
        assert_1.default(status2.toString() === "OKAY", status2.toString());
      }
      await socket.write(encodeMessage(command));
      const status = await socket.read(4);
      assert_1.default(status.toString() === "OKAY", status.toString());
      let commandOutput;
      if (!command.startsWith("shell:")) {
        const remainingLength = parseInt((await socket.read(4)).toString(), 16);
        commandOutput = await socket.read(remainingLength);
      } else {
        commandOutput = await socket.readAll();
      }
      socket.close();
      return commandOutput;
    }
    async function open(command, serial) {
      const socket = new BufferedSocketWrapper(command, net.createConnection({port: 5037}));
      if (serial) {
        await socket.write(encodeMessage(`host:transport:${serial}`));
        const status2 = await socket.read(4);
        assert_1.default(status2.toString() === "OKAY", status2.toString());
      }
      await socket.write(encodeMessage(command));
      const status = await socket.read(4);
      assert_1.default(status.toString() === "OKAY", status.toString());
      return socket;
    }
    function encodeMessage(message) {
      let lenHex = message.length.toString(16);
      lenHex = "0".repeat(4 - lenHex.length) + lenHex;
      return Buffer.from(lenHex + message);
    }
    var BufferedSocketWrapper = class extends events_1.EventEmitter {
      constructor(command, socket) {
        super();
        this.guid = utils_1.createGuid();
        this._buffer = Buffer.from([]);
        this._isSocket = false;
        this._isClosed = false;
        this._command = command;
        this._socket = socket;
        this._connectPromise = new Promise((f) => this._socket.on("connect", f));
        this._socket.on("data", (data) => {
          debug_1.default("pw:adb:data")(data.toString());
          if (this._isSocket) {
            this.emit("data", data);
            return;
          }
          this._buffer = Buffer.concat([this._buffer, data]);
          if (this._notifyReader)
            this._notifyReader();
        });
        this._socket.on("close", () => {
          this._isClosed = true;
          if (this._notifyReader)
            this._notifyReader();
          this.close();
          this.emit("close");
        });
        this._socket.on("error", (error3) => this.emit("error", error3));
      }
      async write(data) {
        debug_1.default("pw:adb:send")(data.toString().substring(0, 100) + "...");
        await this._connectPromise;
        await new Promise((f) => this._socket.write(data, f));
      }
      close() {
        if (this._isClosed)
          return;
        debug_1.default("pw:adb")("Close " + this._command);
        this._socket.destroy();
      }
      async read(length) {
        await this._connectPromise;
        assert_1.default(!this._isSocket, "Can not read by length in socket mode");
        while (this._buffer.length < length)
          await new Promise((f) => this._notifyReader = f);
        const result = this._buffer.slice(0, length);
        this._buffer = this._buffer.slice(length);
        debug_1.default("pw:adb:recv")(result.toString().substring(0, 100) + "...");
        return result;
      }
      async readAll() {
        while (!this._isClosed)
          await new Promise((f) => this._notifyReader = f);
        return this._buffer;
      }
      becomeSocket() {
        assert_1.default(!this._buffer.length);
        this._isSocket = true;
      }
    };
  }
});

// node_modules/playwright/lib/server/transport.js
var require_transport2 = __commonJS({
  "node_modules/playwright/lib/server/transport.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WebSocketTransport = void 0;
    var ws_1 = __importDefault(require_ws());
    var utils_1 = require_utils();
    var WebSocketTransport = class {
      constructor(progress, url, headers) {
        this.wsEndpoint = url;
        this._ws = new ws_1.default(url, [], {
          perMessageDeflate: false,
          maxPayload: 256 * 1024 * 1024,
          handshakeTimeout: progress.timeUntilDeadline(),
          headers
        });
        this._progress = progress;
        const messageWrap = utils_1.makeWaitForNextTask();
        this._ws.addEventListener("message", (event) => {
          messageWrap(() => {
            try {
              if (this.onmessage)
                this.onmessage.call(null, JSON.parse(event.data));
            } catch (e) {
              this._ws.close();
            }
          });
        });
        this._ws.addEventListener("close", (event) => {
          this._progress && this._progress.log(`<ws disconnected> ${url}`);
          if (this.onclose)
            this.onclose.call(null);
        });
        this._ws.addEventListener("error", () => {
        });
      }
      static async connect(progress, url, headers) {
        progress.log(`<ws connecting> ${url}`);
        const transport = new WebSocketTransport(progress, url, headers);
        let success = false;
        progress.cleanupWhenAborted(async () => {
          if (!success)
            await transport.closeAndWait().catch((e) => null);
        });
        await new Promise((fulfill, reject) => {
          transport._ws.addEventListener("open", async () => {
            progress.log(`<ws connected> ${url}`);
            fulfill(transport);
          });
          transport._ws.addEventListener("error", (event) => {
            progress.log(`<ws connect error> ${url} ${event.message}`);
            reject(new Error("WebSocket error: " + event.message));
            transport._ws.close();
          });
        });
        success = true;
        return transport;
      }
      send(message) {
        this._ws.send(JSON.stringify(message));
      }
      close() {
        this._progress && this._progress.log(`<ws disconnecting> ${this._ws.url}`);
        this._ws.close();
      }
      async closeAndWait() {
        const promise = new Promise((f) => this._ws.once("close", f));
        this.close();
        await promise;
      }
    };
    exports2.WebSocketTransport = WebSocketTransport;
  }
});

// node_modules/playwright/lib/server/pipeTransport.js
var require_pipeTransport = __commonJS({
  "node_modules/playwright/lib/server/pipeTransport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.PipeTransport = void 0;
    var utils_1 = require_utils();
    var debugLogger_1 = require_debugLogger();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        this._pendingMessage = "";
        this._waitForNextTask = utils_1.makeWaitForNextTask();
        this._closed = false;
        this._pipeWrite = pipeWrite;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose.call(null);
        });
        pipeRead.on("error", (e) => debugLogger_1.debugLogger.log("error", e));
        pipeWrite.on("error", (e) => debugLogger_1.debugLogger.log("error", e));
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        this._pipeWrite.write(JSON.stringify(message));
        this._pipeWrite.write("\0");
      }
      close() {
        throw new Error("unimplemented");
      }
      _dispatch(buffer) {
        let end = buffer.indexOf("\0");
        if (end === -1) {
          this._pendingMessage += buffer.toString();
          return;
        }
        const message = this._pendingMessage + buffer.toString(void 0, 0, end);
        this._waitForNextTask(() => {
          if (this.onmessage)
            this.onmessage.call(null, JSON.parse(message));
        });
        let start = end + 1;
        end = buffer.indexOf("\0", start);
        while (end !== -1) {
          const message2 = buffer.toString(void 0, start, end);
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage.call(null, JSON.parse(message2));
          });
          start = end + 1;
          end = buffer.indexOf("\0", start);
        }
        this._pendingMessage = buffer.toString(void 0, start);
      }
    };
    exports2.PipeTransport = PipeTransport;
  }
});

// node_modules/playwright/lib/utils/ubuntuVersion.js
var require_ubuntuVersion = __commonJS({
  "node_modules/playwright/lib/utils/ubuntuVersion.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getUbuntuVersionSync = exports2.getUbuntuVersion = void 0;
    var fs_1 = __importDefault(require("fs"));
    var os = __importStar(require("os"));
    var util = __importStar(require("util"));
    var readFileAsync = util.promisify(fs_1.default.readFile.bind(fs_1.default));
    async function getUbuntuVersion() {
      if (os.platform() !== "linux")
        return "";
      const osReleaseText = await readFileAsync("/etc/os-release", "utf8").catch((e) => "");
      if (!osReleaseText)
        return "";
      return getUbuntuVersionInternal(osReleaseText);
    }
    exports2.getUbuntuVersion = getUbuntuVersion;
    function getUbuntuVersionSync() {
      if (os.platform() !== "linux")
        return "";
      try {
        const osReleaseText = fs_1.default.readFileSync("/etc/os-release", "utf8");
        if (!osReleaseText)
          return "";
        return getUbuntuVersionInternal(osReleaseText);
      } catch (e) {
        return "";
      }
    }
    exports2.getUbuntuVersionSync = getUbuntuVersionSync;
    function getUbuntuVersionInternal(osReleaseText) {
      const fields = new Map();
      for (const line of osReleaseText.split("\n")) {
        const tokens = line.split("=");
        const name = tokens.shift();
        let value = tokens.join("=").trim();
        if (value.startsWith('"') && value.endsWith('"'))
          value = value.substring(1, value.length - 1);
        if (!name)
          continue;
        fields.set(name.toLowerCase(), value);
      }
      if (!fields.get("name") || fields.get("name").toLowerCase() !== "ubuntu")
        return "";
      return fields.get("version_id") || "";
    }
  }
});

// node_modules/playwright/lib/utils/binaryPaths.js
var require_binaryPaths = __commonJS({
  "node_modules/playwright/lib/utils/binaryPaths.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.printDepsWindowsExecutable = void 0;
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    function printDepsWindowsExecutable() {
      return pathToExecutable(["bin", "PrintDeps.exe"]);
    }
    exports2.printDepsWindowsExecutable = printDepsWindowsExecutable;
    function pathToExecutable(relative) {
      try {
        const defaultPath = path_1.default.join(__dirname, "..", "..", ...relative);
        if (fs_1.default.existsSync(defaultPath))
          return defaultPath;
      } catch (e) {
      }
    }
  }
});

// node_modules/playwright/lib/server/validateDependencies.js
var require_validateDependencies = __commonJS({
  "node_modules/playwright/lib/server/validateDependencies.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.spawnAsync = exports2.validateHostRequirements = void 0;
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var path_1 = __importDefault(require("path"));
    var os = __importStar(require("os"));
    var child_process_1 = require("child_process");
    var ubuntuVersion_1 = require_ubuntuVersion();
    var utils = __importStar(require_utils());
    var binaryPaths_1 = require_binaryPaths();
    var accessAsync = util.promisify(fs_1.default.access.bind(fs_1.default));
    var checkExecutable = (filePath) => accessAsync(filePath, fs_1.default.constants.X_OK).then(() => true).catch((e) => false);
    var statAsync = util.promisify(fs_1.default.stat.bind(fs_1.default));
    var readdirAsync = util.promisify(fs_1.default.readdir.bind(fs_1.default));
    async function validateHostRequirements(registry, browserName) {
      if (utils.getAsBooleanFromENV("PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS")) {
        process.stdout.write("Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n");
        return;
      }
      const ubuntuVersion = await ubuntuVersion_1.getUbuntuVersion();
      if (browserName === "firefox" && ubuntuVersion === "16.04")
        throw new Error(`Cannot launch firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 18.04`);
      if (os.platform() === "linux")
        return await validateDependenciesLinux(registry, browserName);
      if (os.platform() === "win32" && os.arch() === "x64")
        return await validateDependenciesWindows(registry, browserName);
    }
    exports2.validateHostRequirements = validateHostRequirements;
    var DL_OPEN_LIBRARIES = {
      "chromium": [],
      "webkit": ["libGLESv2.so.2", "libx264.so"],
      "webkit-technology-preview": ["libGLESv2.so.2", "libx264.so"],
      "firefox": [],
      "firefox-stable": [],
      "clank": [],
      "ffmpeg": []
    };
    function isSupportedWindowsVersion() {
      if (os.platform() !== "win32" || os.arch() !== "x64")
        return false;
      const [major, minor] = os.release().split(".").map((token) => parseInt(token, 10));
      return major > 6 || major === 6 && minor > 1;
    }
    async function validateDependenciesWindows(registry, browserName) {
      const directoryPaths = registry.windowsExeAndDllDirectories(browserName);
      const lddPaths = [];
      for (const directoryPath of directoryPaths)
        lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
      const allMissingDeps = await Promise.all(lddPaths.map((lddPath) => missingFileDependenciesWindows(lddPath)));
      const missingDeps = new Set();
      for (const deps of allMissingDeps) {
        for (const dep of deps)
          missingDeps.add(dep);
      }
      if (!missingDeps.size)
        return;
      let isCrtMissing = false;
      let isMediaFoundationMissing = false;
      for (const dep of missingDeps) {
        if (dep.startsWith("api-ms-win-crt") || dep === "vcruntime140.dll" || dep === "vcruntime140_1.dll" || dep === "msvcp140.dll")
          isCrtMissing = true;
        else if (dep === "mf.dll" || dep === "mfplat.dll" || dep === "msmpeg2vdec.dll" || dep === "evr.dll" || dep === "avrt.dll")
          isMediaFoundationMissing = true;
      }
      const details = [];
      if (isCrtMissing) {
        details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);
      }
      if (isMediaFoundationMissing) {
        details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);
      }
      details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join("\n    ")}`, ``);
      const message = `Host system is missing dependencies!

${details.join("\n")}`;
      if (isSupportedWindowsVersion()) {
        throw new Error(message);
      } else {
        console.warn(`WARNING: running on unsupported windows version!`);
        console.warn(message);
      }
    }
    async function validateDependenciesLinux(registry, browserName) {
      const directoryPaths = registry.linuxLddDirectories(browserName);
      const lddPaths = [];
      for (const directoryPath of directoryPaths)
        lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
      const allMissingDeps = await Promise.all(lddPaths.map((lddPath) => missingFileDependencies(lddPath, directoryPaths)));
      const missingDeps = new Set();
      for (const deps of allMissingDeps) {
        for (const dep of deps)
          missingDeps.add(dep);
      }
      for (const dep of await missingDLOPENLibraries(browserName))
        missingDeps.add(dep);
      if (!missingDeps.size)
        return;
      const missingPackages = new Set();
      const ubuntuVersion = await ubuntuVersion_1.getUbuntuVersion();
      let libraryToPackageNameMapping = null;
      if (ubuntuVersion === "18.04")
        libraryToPackageNameMapping = LIBRARY_TO_PACKAGE_NAME_UBUNTU_18_04;
      else if (ubuntuVersion === "20.04")
        libraryToPackageNameMapping = LIBRARY_TO_PACKAGE_NAME_UBUNTU_20_04;
      libraryToPackageNameMapping = Object.assign({}, libraryToPackageNameMapping, MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU);
      if (libraryToPackageNameMapping) {
        for (const missingDep of missingDeps) {
          const packageName = libraryToPackageNameMapping[missingDep];
          if (packageName) {
            missingPackages.add(packageName);
            missingDeps.delete(missingDep);
          }
        }
      }
      let missingPackagesMessage = "";
      if (missingPackages.size) {
        missingPackagesMessage = [
          `  Install missing packages with:`,
          `      sudo apt-get install ${[...missingPackages].join("\\\n          ")}`,
          ``,
          ``
        ].join("\n");
      }
      let missingDependenciesMessage = "";
      if (missingDeps.size) {
        const header = missingPackages.size ? `Missing libraries we didn't find packages for:` : `Missing libraries are:`;
        missingDependenciesMessage = [
          `  ${header}`,
          `      ${[...missingDeps].join("\n      ")}`,
          ``
        ].join("\n");
      }
      throw new Error("Host system is missing dependencies!\n\n" + missingPackagesMessage + missingDependenciesMessage);
    }
    function isSharedLib(basename) {
      switch (os.platform()) {
        case "linux":
          return basename.endsWith(".so") || basename.includes(".so.");
        case "win32":
          return basename.endsWith(".dll");
        default:
          return false;
      }
    }
    async function executablesOrSharedLibraries(directoryPath) {
      const allPaths = (await readdirAsync(directoryPath)).map((file) => path_1.default.resolve(directoryPath, file));
      const allStats = await Promise.all(allPaths.map((aPath) => statAsync(aPath)));
      const filePaths = allPaths.filter((aPath, index2) => allStats[index2].isFile());
      const executablersOrLibraries = (await Promise.all(filePaths.map(async (filePath) => {
        const basename = path_1.default.basename(filePath).toLowerCase();
        if (isSharedLib(basename))
          return filePath;
        if (await checkExecutable(filePath))
          return filePath;
        return false;
      }))).filter(Boolean);
      return executablersOrLibraries;
    }
    async function missingFileDependenciesWindows(filePath) {
      const executable = binaryPaths_1.printDepsWindowsExecutable();
      if (!executable)
        return [];
      const dirname = path_1.default.dirname(filePath);
      const {stdout, code} = await spawnAsync(executable, [filePath], {
        cwd: dirname,
        env: {
          ...process.env,
          LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname
        }
      });
      if (code !== 0)
        return [];
      const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim().toLowerCase());
      return missingDeps;
    }
    async function missingFileDependencies(filePath, extraLDPaths) {
      const dirname = path_1.default.dirname(filePath);
      let LD_LIBRARY_PATH = extraLDPaths.join(":");
      if (process.env.LD_LIBRARY_PATH)
        LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
      const {stdout, code} = await spawnAsync("ldd", [filePath], {
        cwd: dirname,
        env: {
          ...process.env,
          LD_LIBRARY_PATH
        }
      });
      if (code !== 0)
        return [];
      const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim());
      return missingDeps;
    }
    async function missingDLOPENLibraries(browserName) {
      const libraries = DL_OPEN_LIBRARIES[browserName];
      if (!libraries.length)
        return [];
      const {stdout, code, error: error3} = await spawnAsync("/sbin/ldconfig", ["-p"], {});
      if (code !== 0 || error3)
        return [];
      const isLibraryAvailable = (library) => stdout.toLowerCase().includes(library.toLowerCase());
      return libraries.filter((library) => !isLibraryAvailable(library));
    }
    function spawnAsync(cmd, args, options2) {
      const process2 = child_process_1.spawn(cmd, args, options2);
      return new Promise((resolve2) => {
        let stdout = "";
        let stderr = "";
        process2.stdout.on("data", (data) => stdout += data);
        process2.stderr.on("data", (data) => stderr += data);
        process2.on("close", (code) => resolve2({stdout, stderr, code}));
        process2.on("error", (error3) => resolve2({stdout, stderr, code: 0, error: error3}));
      });
    }
    exports2.spawnAsync = spawnAsync;
    var LIBRARY_TO_PACKAGE_NAME_UBUNTU_18_04 = {
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libbrotlidec.so.1": "libbrotli1",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libenchant.so.1": "libenchant1c2a",
      "libepoxy.so.0": "libepoxy0",
      "libevent-2.1.so.6": "libevent-2.1-6",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgdk-x11-2.0.so.0": "libgtk2.0-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGL.so.1": "libgl1",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
      "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgthread-2.0.so.0": "libglib2.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgtk-x11-2.0.so.0": "libgtk2.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicudata.so.60": "libicu60",
      "libicui18n.so.60": "libicu60",
      "libicuuc.so.60": "libicu60",
      "libjpeg.so.8": "libjpeg-turbo8",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libvpx.so.5": "libvpx5",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.6": "libwebp6",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-dri3.so.0": "libxcb-dri3-0",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXt.so.6": "libxt6",
      "libXtst.so.6": "libxtst6"
    };
    var LIBRARY_TO_PACKAGE_NAME_UBUNTU_20_04 = {
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libenchant.so.1": "libenchant1c2a",
      "libepoxy.so.0": "libepoxy0",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgdk-x11-2.0.so.0": "libgtk2.0-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGL.so.1": "libgl1",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
      "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
      "libgthread-2.0.so.0": "libglib2.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgtk-x11-2.0.so.0": "libgtk2.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicui18n.so.66": "libicu66",
      "libicuuc.so.66": "libicu66",
      "libjpeg.so.8": "libjpeg-turbo8",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libsoup-2.4.so.1": "libsoup2.4-1",
      "libvpx.so.6": "libvpx6",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.6": "libwebp6",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-dri3.so.0": "libxcb-dri3-0",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXt.so.6": "libxt6",
      "libXtst.so.6": "libxtst6"
    };
    var MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
      "libx264.so": "gstreamer1.0-libav"
    };
  }
});

// node_modules/playwright/lib/server/browserType.js
var require_browserType = __commonJS({
  "node_modules/playwright/lib/server/browserType.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BrowserType = void 0;
    var fs_1 = __importDefault(require("fs"));
    var os = __importStar(require("os"));
    var path_1 = __importDefault(require("path"));
    var util = __importStar(require("util"));
    var browserContext_1 = require_browserContext();
    var transport_1 = require_transport2();
    var processLauncher_1 = require_processLauncher();
    var pipeTransport_1 = require_pipeTransport();
    var progress_1 = require_progress();
    var timeoutSettings_1 = require_timeoutSettings();
    var validateDependencies_1 = require_validateDependencies();
    var utils_1 = require_utils();
    var helper_1 = require_helper();
    var debugLogger_1 = require_debugLogger();
    var instrumentation_1 = require_instrumentation();
    var mkdirAsync = util.promisify(fs_1.default.mkdir);
    var mkdtempAsync = util.promisify(fs_1.default.mkdtemp);
    var existsAsync = (path) => new Promise((resolve2) => fs_1.default.stat(path, (err) => resolve2(!err)));
    var DOWNLOADS_FOLDER = path_1.default.join(os.tmpdir(), "playwright_downloads-");
    var BrowserType = class extends instrumentation_1.SdkObject {
      constructor(browserName, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "browser-type");
        this.attribution.browserType = this;
        this._playwrightOptions = playwrightOptions;
        this._name = browserName;
        this._registry = playwrightOptions.registry;
      }
      executablePath(channel) {
        return this._registry.executablePath(this._name) || "";
      }
      name() {
        return this._name;
      }
      async launch(metadata, options2, protocolLogger) {
        options2 = validateLaunchOptions(options2);
        const controller = new progress_1.ProgressController(metadata, this);
        controller.setLogName("browser");
        const browser = await controller.run((progress) => {
          return this._innerLaunchWithRetries(progress, options2, void 0, helper_1.helper.debugProtocolLogger(protocolLogger)).catch((e) => {
            throw this._rewriteStartupError(e);
          });
        }, timeoutSettings_1.TimeoutSettings.timeout(options2));
        return browser;
      }
      async launchPersistentContext(metadata, userDataDir, options2) {
        options2 = validateLaunchOptions(options2);
        const controller = new progress_1.ProgressController(metadata, this);
        const persistent = options2;
        controller.setLogName("browser");
        const browser = await controller.run((progress) => {
          return this._innerLaunchWithRetries(progress, options2, persistent, helper_1.helper.debugProtocolLogger(), userDataDir).catch((e) => {
            throw this._rewriteStartupError(e);
          });
        }, timeoutSettings_1.TimeoutSettings.timeout(options2));
        return browser._defaultContext;
      }
      async _innerLaunchWithRetries(progress, options2, persistent, protocolLogger, userDataDir) {
        try {
          return this._innerLaunch(progress, options2, persistent, protocolLogger, userDataDir);
        } catch (error3) {
          const errorMessage = typeof error3 === "object" && typeof error3.message === "string" ? error3.message : "";
          if (errorMessage.includes("Inconsistency detected by ld.so")) {
            progress.log(`<restarting browser due to hitting race condition in glibc>`);
            return this._innerLaunch(progress, options2, persistent, protocolLogger, userDataDir);
          }
          throw error3;
        }
      }
      async _innerLaunch(progress, options2, persistent, protocolLogger, userDataDir) {
        options2.proxy = options2.proxy ? browserContext_1.normalizeProxySettings(options2.proxy) : void 0;
        const browserLogsCollector = new debugLogger_1.RecentLogsCollector();
        const {browserProcess, downloadsPath, transport} = await this._launchProcess(progress, options2, !!persistent, browserLogsCollector, userDataDir);
        if (options2.__testHookBeforeCreateBrowser)
          await options2.__testHookBeforeCreateBrowser();
        const browserOptions = {
          ...this._playwrightOptions,
          name: this._name,
          isChromium: this._name === "chromium",
          channel: options2.channel,
          slowMo: options2.slowMo,
          persistent,
          headful: !options2.headless,
          downloadsPath,
          browserProcess,
          customExecutablePath: options2.executablePath,
          proxy: options2.proxy,
          protocolLogger,
          browserLogsCollector,
          wsEndpoint: options2.useWebSocket ? transport.wsEndpoint : void 0,
          traceDir: options2._traceDir
        };
        if (persistent)
          browserContext_1.validateBrowserContextOptions(persistent, browserOptions);
        copyTestHooks(options2, browserOptions);
        const browser = await this._connectToTransport(transport, browserOptions);
        if (persistent && !options2.ignoreAllDefaultArgs)
          await browser._defaultContext._loadDefaultContext(progress);
        return browser;
      }
      async _launchProcess(progress, options2, isPersistent, browserLogsCollector, userDataDir) {
        const {ignoreDefaultArgs, ignoreAllDefaultArgs, args = [], executablePath = null, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true} = options2;
        const env2 = options2.env ? processLauncher_1.envArrayToObject(options2.env) : process.env;
        const tempDirectories = [];
        const ensurePath = async (tmpPrefix, pathFromOptions) => {
          let dir;
          if (pathFromOptions) {
            dir = pathFromOptions;
            await mkdirAsync(pathFromOptions, {recursive: true});
          } else {
            dir = await mkdtempAsync(tmpPrefix);
            tempDirectories.push(dir);
          }
          return dir;
        };
        const downloadsPath = await ensurePath(DOWNLOADS_FOLDER, options2.downloadsPath);
        if (!userDataDir) {
          userDataDir = await mkdtempAsync(path_1.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
          tempDirectories.push(userDataDir);
        }
        const browserArguments = [];
        if (ignoreAllDefaultArgs)
          browserArguments.push(...args);
        else if (ignoreDefaultArgs)
          browserArguments.push(...this._defaultArgs(options2, isPersistent, userDataDir).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
        else
          browserArguments.push(...this._defaultArgs(options2, isPersistent, userDataDir));
        const executable = executablePath || this.executablePath(options2.channel);
        if (!executable)
          throw new Error(`No executable path is specified. Pass "executablePath" option directly.`);
        if (!await existsAsync(executable)) {
          const errorMessageLines = [`Failed to launch ${this._name} because executable doesn't exist at ${executable}`];
          if (!executablePath)
            errorMessageLines.push(`Try re-installing playwright with "npm install playwright"`);
          throw new Error(errorMessageLines.join("\n"));
        }
        if (!executablePath && !options2.channel)
          await validateDependencies_1.validateHostRequirements(this._registry, this._name);
        else if (!executablePath && options2.channel && this._registry.isSupportedBrowser(options2.channel))
          await validateDependencies_1.validateHostRequirements(this._registry, options2.channel);
        let wsEndpointCallback;
        const wsEndpoint = options2.useWebSocket ? new Promise((f) => wsEndpointCallback = f) : void 0;
        let transport = void 0;
        let browserProcess = void 0;
        const {launchedProcess, gracefullyClose, kill} = await processLauncher_1.launchProcess({
          executablePath: executable,
          args: browserArguments,
          env: this._amendEnvironment(env2, userDataDir, executable, browserArguments),
          handleSIGINT,
          handleSIGTERM,
          handleSIGHUP,
          log: (message) => {
            if (wsEndpointCallback) {
              const match = message.match(/DevTools listening on (.*)/);
              if (match)
                wsEndpointCallback(match[1]);
            }
            progress.log(message);
            browserLogsCollector.log(message);
          },
          stdio: "pipe",
          tempDirectories,
          attemptToGracefullyClose: async () => {
            if (options2.__testHookGracefullyClose)
              await options2.__testHookGracefullyClose();
            this._attemptToGracefullyCloseBrowser(transport);
          },
          onExit: (exitCode, signal) => {
            if (browserProcess && browserProcess.onclose)
              browserProcess.onclose(exitCode, signal);
          }
        });
        async function closeOrKill(timeout) {
          let timer;
          try {
            await Promise.race([
              gracefullyClose(),
              new Promise((resolve2, reject) => timer = setTimeout(reject, timeout))
            ]);
          } catch (ignored) {
            await kill().catch((ignored2) => {
            });
          } finally {
            clearTimeout(timer);
          }
        }
        browserProcess = {
          onclose: void 0,
          process: launchedProcess,
          close: () => closeOrKill(options2.__testHookBrowserCloseTimeout || timeoutSettings_1.DEFAULT_TIMEOUT),
          kill
        };
        progress.cleanupWhenAborted(() => closeOrKill(progress.timeUntilDeadline()));
        if (options2.useWebSocket) {
          transport = await transport_1.WebSocketTransport.connect(progress, await wsEndpoint);
        } else {
          const stdio = launchedProcess.stdio;
          transport = new pipeTransport_1.PipeTransport(stdio[3], stdio[4]);
        }
        return {browserProcess, downloadsPath, transport};
      }
      async connectOverCDP(metadata, endpointURL, options2, timeout) {
        throw new Error("CDP connections are only supported by Chromium");
      }
    };
    exports2.BrowserType = BrowserType;
    function copyTestHooks(from, to) {
      for (const [key, value] of Object.entries(from)) {
        if (key.startsWith("__testHook"))
          to[key] = value;
      }
    }
    function validateLaunchOptions(options2) {
      const {devtools = false} = options2;
      let {headless = !devtools, downloadsPath} = options2;
      if (utils_1.debugMode())
        headless = false;
      if (downloadsPath && !path_1.default.isAbsolute(downloadsPath))
        downloadsPath = path_1.default.join(process.cwd(), downloadsPath);
      return {...options2, devtools, headless, downloadsPath};
    }
  }
});

// node_modules/playwright/lib/server/chromium/crDevTools.js
var require_crDevTools = __commonJS({
  "node_modules/playwright/lib/server/chromium/crDevTools.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CRDevTools = void 0;
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var kBindingName = "__pw_devtools__";
    var CRDevTools = class {
      constructor(preferencesPath) {
        this._preferencesPath = preferencesPath;
        this._savePromise = Promise.resolve();
      }
      install(session) {
        session.on("Runtime.bindingCalled", async (event) => {
          if (event.name !== kBindingName)
            return;
          const parsed = JSON.parse(event.payload);
          let result = void 0;
          if (this.__testHookOnBinding)
            this.__testHookOnBinding(parsed);
          if (parsed.method === "getPreferences") {
            if (this._prefs === void 0) {
              try {
                const json = await util.promisify(fs_1.default.readFile)(this._preferencesPath, "utf8");
                this._prefs = JSON.parse(json);
              } catch (e) {
                this._prefs = {};
              }
            }
            result = this._prefs;
          } else if (parsed.method === "setPreference") {
            this._prefs[parsed.params[0]] = parsed.params[1];
            this._save();
          } else if (parsed.method === "removePreference") {
            delete this._prefs[parsed.params[0]];
            this._save();
          } else if (parsed.method === "clearPreferences") {
            this._prefs = {};
            this._save();
          }
          session.send("Runtime.evaluate", {
            expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
            contextId: event.executionContextId
          }).catch((e) => null);
        });
        Promise.all([
          session.send("Runtime.enable"),
          session.send("Runtime.addBinding", {name: kBindingName}),
          session.send("Page.enable"),
          session.send("Page.addScriptToEvaluateOnNewDocument", {source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      `}),
          session.send("Runtime.runIfWaitingForDebugger")
        ]).catch((e) => null);
      }
      _save() {
        this._savePromise = this._savePromise.then(async () => {
          await util.promisify(fs_1.default.writeFile)(this._preferencesPath, JSON.stringify(this._prefs)).catch((e) => null);
        });
      }
    };
    exports2.CRDevTools = CRDevTools;
  }
});

// node_modules/playwright/lib/server/chromium/findChromiumChannel.js
var require_findChromiumChannel = __commonJS({
  "node_modules/playwright/lib/server/chromium/findChromiumChannel.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.findChromiumChannel = void 0;
    var path_1 = __importDefault(require("path"));
    var utils_1 = require_utils();
    function darwin(channel) {
      switch (channel) {
        case "chrome":
          return ["/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"];
        case "chrome-beta":
          return ["/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta"];
        case "chrome-dev":
          return ["/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev"];
        case "chrome-canary":
          return ["/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary"];
        case "msedge":
          return ["/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge"];
        case "msedge-beta":
          return ["/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta"];
        case "msedge-dev":
          return ["/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev"];
        case "msedge-canary":
          return ["/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary"];
      }
    }
    function linux(channel) {
      switch (channel) {
        case "chrome":
          return ["/opt/google/chrome/chrome"];
        case "chrome-beta":
          return ["/opt/google/chrome-beta/chrome"];
        case "chrome-dev":
          return ["/opt/google/chrome-unstable/chrome"];
        case "msedge-dev":
          return ["/opt/microsoft/msedge-dev/msedge"];
      }
    }
    function win32(channel) {
      let suffix;
      switch (channel) {
        case "chrome":
          suffix = `\\Google\\Chrome\\Application\\chrome.exe`;
          break;
        case "chrome-beta":
          suffix = `\\Google\\Chrome Beta\\Application\\chrome.exe`;
          break;
        case "chrome-dev":
          suffix = `\\Google\\Chrome Dev\\Application\\chrome.exe`;
          break;
        case "chrome-canary":
          suffix = `\\Google\\Chrome SxS\\Application\\chrome.exe`;
          break;
        case "msedge":
          suffix = `\\Microsoft\\Edge\\Application\\msedge.exe`;
          break;
        case "msedge-beta":
          suffix = `\\Microsoft\\Edge Beta\\Application\\msedge.exe`;
          break;
        case "msedge-dev":
          suffix = `\\Microsoft\\Edge Dev\\Application\\msedge.exe`;
          break;
        case "msedge-canary":
          suffix = `\\Microsoft\\Edge SxS\\Application\\msedge.exe`;
          break;
      }
      if (!suffix)
        return;
      const prefixes = [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"]
      ].filter(Boolean);
      return prefixes.map((prefix) => path_1.default.join(prefix, suffix));
    }
    function findChromiumChannel(channel) {
      let installationPaths;
      if (process.platform === "linux")
        installationPaths = linux(channel);
      else if (process.platform === "win32")
        installationPaths = win32(channel);
      else if (process.platform === "darwin")
        installationPaths = darwin(channel);
      if (!installationPaths)
        throw new Error(`Chromium distribution '${channel}' is not supported on ${process.platform}`);
      let result;
      installationPaths.forEach((chromePath) => {
        if (utils_1.canAccessFile(chromePath))
          result = chromePath;
      });
      if (result)
        return result;
      throw new Error(`Chromium distribution is not installed on the system: ${channel}`);
    }
    exports2.findChromiumChannel = findChromiumChannel;
  }
});

// node_modules/playwright/lib/server/chromium/chromium.js
var require_chromium = __commonJS({
  "node_modules/playwright/lib/server/chromium/chromium.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Chromium = void 0;
    var path_1 = __importDefault(require("path"));
    var crBrowser_1 = require_crBrowser();
    var crConnection_1 = require_crConnection();
    var stackTrace_1 = require_stackTrace();
    var browserType_1 = require_browserType();
    var transport_1 = require_transport2();
    var crDevTools_1 = require_crDevTools();
    var utils_1 = require_utils();
    var debugLogger_1 = require_debugLogger();
    var progress_1 = require_progress();
    var timeoutSettings_1 = require_timeoutSettings();
    var helper_1 = require_helper();
    var findChromiumChannel_1 = require_findChromiumChannel();
    var http_1 = __importDefault(require("http"));
    var Chromium = class extends browserType_1.BrowserType {
      constructor(playwrightOptions) {
        super("chromium", playwrightOptions);
        if (utils_1.debugMode())
          this._devtools = this._createDevTools();
      }
      executablePath(channel) {
        if (channel)
          return findChromiumChannel_1.findChromiumChannel(channel);
        return super.executablePath(channel);
      }
      async connectOverCDP(metadata, endpointURL, options2, timeout) {
        const controller = new progress_1.ProgressController(metadata, this);
        controller.setLogName("browser");
        const browserLogsCollector = new debugLogger_1.RecentLogsCollector();
        return controller.run(async (progress) => {
          let headersMap;
          if (options2.headers)
            headersMap = utils_1.headersArrayToObject(options2.headers, false);
          const chromeTransport = await transport_1.WebSocketTransport.connect(progress, await urlToWSEndpoint(endpointURL), headersMap);
          const browserProcess = {
            close: async () => {
              await chromeTransport.closeAndWait();
            },
            kill: async () => {
              await chromeTransport.closeAndWait();
            }
          };
          const browserOptions = {
            ...this._playwrightOptions,
            slowMo: options2.slowMo,
            name: "chromium",
            isChromium: true,
            persistent: {sdkLanguage: options2.sdkLanguage, noDefaultViewport: true},
            browserProcess,
            protocolLogger: helper_1.helper.debugProtocolLogger(),
            browserLogsCollector
          };
          return await crBrowser_1.CRBrowser.connect(chromeTransport, browserOptions);
        }, timeoutSettings_1.TimeoutSettings.timeout({timeout}));
      }
      _createDevTools() {
        return new crDevTools_1.CRDevTools(path_1.default.join(this._registry.browserDirectory("chromium"), "devtools-preferences.json"));
      }
      async _connectToTransport(transport, options2) {
        let devtools = this._devtools;
        if (options2.__testHookForDevTools) {
          devtools = this._createDevTools();
          await options2.__testHookForDevTools(devtools);
        }
        return crBrowser_1.CRBrowser.connect(transport, options2, devtools);
      }
      _rewriteStartupError(error3) {
        if (!error3.message.includes("crbug.com/357670") && !error3.message.includes("No usable sandbox!") && !error3.message.includes("crbug.com/638180"))
          return error3;
        return stackTrace_1.rewriteErrorMessage(error3, [
          `Chromium sandboxing failed!`,
          `================================`,
          `To workaround sandboxing issues, do either of the following:`,
          `  - (preferred): Configure environment to support sandboxing: https://github.com/microsoft/playwright/blob/master/docs/troubleshooting.md`,
          `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`,
          `================================`,
          ``
        ].join("\n"));
      }
      _amendEnvironment(env2, userDataDir, executable, browserArguments) {
        return env2;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {method: "Browser.close", id: crConnection_1.kBrowserCloseMessageId, params: {}};
        transport.send(message);
      }
      _defaultArgs(options2, isPersistent, userDataDir) {
        const {args = [], proxy} = options2;
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
          throw new Error("Playwright manages remote debugging connection itself.");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const chromeArguments = [...DEFAULT_ARGS];
        chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (options2.useWebSocket)
          chromeArguments.push("--remote-debugging-port=0");
        else
          chromeArguments.push("--remote-debugging-pipe");
        if (options2.devtools)
          chromeArguments.push("--auto-open-devtools-for-tabs");
        if (options2.headless) {
          chromeArguments.push("--headless", "--hide-scrollbars", "--mute-audio", "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4");
        }
        if (options2.chromiumSandbox !== true)
          chromeArguments.push("--no-sandbox");
        if (proxy) {
          const proxyURL = new URL(proxy.server);
          const isSocks = proxyURL.protocol === "socks5:";
          if (isSocks) {
            chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
          }
          chromeArguments.push(`--proxy-server=${proxy.server}`);
          if (proxy.bypass) {
            const patterns = proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t);
            chromeArguments.push(`--proxy-bypass-list=${patterns.join(";")}`);
          }
        }
        chromeArguments.push(...args);
        if (isPersistent)
          chromeArguments.push("about:blank");
        else
          chromeArguments.push("--no-startup-window");
        return chromeArguments;
      }
    };
    exports2.Chromium = Chromium;
    var DEFAULT_ARGS = [
      "--disable-background-networking",
      "--enable-features=NetworkService,NetworkServiceInProcess",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-component-extensions-with-background-pages",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-features=TranslateUI,BlinkGenPropertyTrees,ImprovedCookieControls,SameSiteByDefaultCookies,LazyFrameLoading",
      "--allow-pre-commit-input",
      "--disable-hang-monitor",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-sync",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--enable-automation",
      "--password-store=basic",
      "--use-mock-keychain",
      "--no-service-autorun"
    ];
    async function urlToWSEndpoint(endpointURL) {
      if (endpointURL.startsWith("ws"))
        return endpointURL;
      const httpURL = endpointURL.endsWith("/") ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
      const json = await new Promise((resolve2, reject) => {
        http_1.default.get(httpURL, (resp) => {
          let data = "";
          resp.on("data", (chunk) => data += chunk);
          resp.on("end", () => resolve2(data));
        }).on("error", reject);
      });
      return JSON.parse(json).webSocketDebuggerUrl;
    }
  }
});

// node_modules/electron/index.js
var require_electron = __commonJS({
  "node_modules/electron/index.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var pathFile = path.join(__dirname, "path.txt");
    function getElectronPath() {
      let executablePath;
      if (fs.existsSync(pathFile)) {
        executablePath = fs.readFileSync(pathFile, "utf-8");
      }
      if (process.env.ELECTRON_OVERRIDE_DIST_PATH) {
        return path.join(process.env.ELECTRON_OVERRIDE_DIST_PATH, executablePath || "electron");
      }
      if (executablePath) {
        return path.join(__dirname, "dist", executablePath);
      } else {
        throw new Error("Electron failed to install correctly, please delete node_modules/electron and try installing again");
      }
    }
    module2.exports = getElectronPath();
  }
});

// node_modules/playwright/lib/server/electron/electron.js
var require_electron2 = __commonJS({
  "node_modules/playwright/lib/server/electron/electron.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Electron = exports2.ElectronApplication = void 0;
    var os = __importStar(require("os"));
    var crBrowser_1 = require_crBrowser();
    var crConnection_1 = require_crConnection();
    var crExecutionContext_1 = require_crExecutionContext();
    var js = __importStar(require_javascript());
    var timeoutSettings_1 = require_timeoutSettings();
    var transport_1 = require_transport2();
    var processLauncher_1 = require_processLauncher();
    var browserContext_1 = require_browserContext();
    var progress_1 = require_progress();
    var helper_1 = require_helper();
    var readline = __importStar(require("readline"));
    var debugLogger_1 = require_debugLogger();
    var instrumentation_1 = require_instrumentation();
    var ElectronApplication = class extends instrumentation_1.SdkObject {
      constructor(parent, browser, nodeConnection) {
        super(parent, "electron-app");
        this._lastWindowId = 0;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._browserContext = browser._defaultContext;
        this._browserContext.on(browserContext_1.BrowserContext.Events.Close, () => {
          Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));
        });
        for (const page of this._browserContext.pages())
          this._onPage(page);
        this._browserContext.on(browserContext_1.BrowserContext.Events.Page, (event) => this._onPage(event));
        this._nodeConnection = nodeConnection;
        this._nodeSession = nodeConnection.rootSession;
        this._nodeElectronHandlePromise = new Promise((f) => {
          this._nodeSession.on("Runtime.executionContextCreated", async (event) => {
            if (event.context.auxData && event.context.auxData.isDefault) {
              this._nodeExecutionContext = new js.ExecutionContext(this, new crExecutionContext_1.CRExecutionContext(this._nodeSession, event.context));
              f(await js.evaluate(this._nodeExecutionContext, false, `process.mainModule.require('electron')`));
            }
          });
        });
        this._nodeSession.send("Runtime.enable", {}).catch((e) => {
        });
      }
      _onPage(page) {
        const windowId = ++this._lastWindowId;
        page._browserWindowId = windowId;
      }
      context() {
        return this._browserContext;
      }
      async close() {
        const progressController = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), this);
        const closed = progressController.run((progress) => helper_1.helper.waitForEvent(progress, this, ElectronApplication.Events.Close).promise, this._timeoutSettings.timeout({}));
        const electronHandle = await this._nodeElectronHandlePromise;
        await electronHandle.evaluate(({app}) => app.quit());
        this._nodeConnection.close();
        await closed;
      }
      async browserWindow(page) {
        const electronHandle = await this._nodeElectronHandlePromise;
        return await electronHandle.evaluateHandle(({BrowserWindow}, windowId) => BrowserWindow.fromId(windowId), page._browserWindowId);
      }
    };
    exports2.ElectronApplication = ElectronApplication;
    ElectronApplication.Events = {
      Close: "close"
    };
    var Electron = class extends instrumentation_1.SdkObject {
      constructor(playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "electron");
        this._playwrightOptions = playwrightOptions;
      }
      async launch(options2) {
        const {args = []} = options2;
        const controller = new progress_1.ProgressController(instrumentation_1.internalCallMetadata(), this);
        controller.setLogName("browser");
        return controller.run(async (progress) => {
          let app = void 0;
          const electronArguments = ["--inspect=0", "--remote-debugging-port=0", ...args];
          if (os.platform() === "linux") {
            const runningAsRoot = process.geteuid && process.geteuid() === 0;
            if (runningAsRoot && electronArguments.indexOf("--no-sandbox") === -1)
              electronArguments.push("--no-sandbox");
          }
          const browserLogsCollector = new debugLogger_1.RecentLogsCollector();
          const {launchedProcess, gracefullyClose, kill} = await processLauncher_1.launchProcess({
            executablePath: options2.executablePath || require_electron(),
            args: electronArguments,
            env: options2.env ? processLauncher_1.envArrayToObject(options2.env) : process.env,
            log: (message) => {
              progress.log(message);
              browserLogsCollector.log(message);
            },
            stdio: "pipe",
            cwd: options2.cwd,
            tempDirectories: [],
            attemptToGracefullyClose: () => app.close(),
            handleSIGINT: true,
            handleSIGTERM: true,
            handleSIGHUP: true,
            onExit: () => {
            }
          });
          const nodeMatch = await waitForLine(progress, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
          const nodeTransport = await transport_1.WebSocketTransport.connect(progress, nodeMatch[1]);
          const nodeConnection = new crConnection_1.CRConnection(nodeTransport, helper_1.helper.debugProtocolLogger(), browserLogsCollector);
          const chromeMatch = await waitForLine(progress, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/);
          const chromeTransport = await transport_1.WebSocketTransport.connect(progress, chromeMatch[1]);
          const browserProcess = {
            onclose: void 0,
            process: launchedProcess,
            close: gracefullyClose,
            kill
          };
          const browserOptions = {
            ...this._playwrightOptions,
            name: "electron",
            isChromium: true,
            headful: true,
            persistent: {sdkLanguage: options2.sdkLanguage, noDefaultViewport: true},
            browserProcess,
            protocolLogger: helper_1.helper.debugProtocolLogger(),
            browserLogsCollector
          };
          const browser = await crBrowser_1.CRBrowser.connect(chromeTransport, browserOptions);
          app = new ElectronApplication(this, browser, nodeConnection);
          return app;
        }, timeoutSettings_1.TimeoutSettings.timeout(options2));
      }
    };
    exports2.Electron = Electron;
    function waitForLine(progress, process2, regex) {
      return new Promise((resolve2, reject) => {
        const rl = readline.createInterface({input: process2.stderr});
        const failError = new Error("Process failed to launch!");
        const listeners = [
          helper_1.helper.addEventListener(rl, "line", onLine),
          helper_1.helper.addEventListener(rl, "close", reject.bind(null, failError)),
          helper_1.helper.addEventListener(process2, "exit", reject.bind(null, failError)),
          helper_1.helper.addEventListener(process2, "error", reject.bind(null, failError))
        ];
        progress.cleanupWhenAborted(cleanup);
        function onLine(line) {
          const match = line.match(regex);
          if (!match)
            return;
          cleanup();
          resolve2(match);
        }
        function cleanup() {
          helper_1.helper.removeEventListeners(listeners);
        }
      });
    }
  }
});

// node_modules/playwright/lib/server/firefox/ffConnection.js
var require_ffConnection = __commonJS({
  "node_modules/playwright/lib/server/firefox/ffConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FFSession = exports2.FFSessionEvents = exports2.FFConnection = exports2.kBrowserCloseMessageId = exports2.ConnectionEvents = void 0;
    var events_1 = require("events");
    var utils_1 = require_utils();
    var stackTrace_1 = require_stackTrace();
    var debugLogger_1 = require_debugLogger();
    var helper_1 = require_helper();
    exports2.ConnectionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports2.kBrowserCloseMessageId = -9999;
    var FFConnection = class extends events_1.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._lastId = 0;
        this._callbacks = new Map();
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = new Map();
        this._closed = false;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      async send(method, params) {
        this._checkClosed(method);
        const id = this.nextMessageId();
        this._rawSend({id, method, params});
        return new Promise((resolve2, reject) => {
          this._callbacks.set(id, {resolve: resolve2, reject, error: new Error(), method});
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      _checkClosed(method) {
        if (this._closed)
          throw new Error(`Protocol error (${method}): Browser closed.` + helper_1.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));
      }
      _rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      async _onMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === exports2.kBrowserCloseMessageId)
          return;
        if (message.sessionId) {
          const session = this._sessions.get(message.sessionId);
          if (session)
            session.dispatchMessage(message);
        } else if (message.id) {
          const callback = this._callbacks.get(message.id);
          if (callback) {
            this._callbacks.delete(message.id);
            if (message.error)
              callback.reject(createProtocolError(callback.error, callback.method, message.error));
            else
              callback.resolve(message.result);
          }
        } else {
          Promise.resolve().then(() => this.emit(message.method, message.params));
        }
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const formattedBrowserLogs = helper_1.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session.dispose(formattedBrowserLogs);
        this._sessions.clear();
        for (const callback of this._callbacks.values())
          callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs));
        this._callbacks.clear();
        Promise.resolve().then(() => this.emit(exports2.ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(sessionId, type) {
        const session = new FFSession(this, type, sessionId, (message) => this._rawSend({...message, sessionId}));
        this._sessions.set(sessionId, session);
        return session;
      }
    };
    exports2.FFConnection = FFConnection;
    exports2.FFSessionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    var FFSession = class extends events_1.EventEmitter {
      constructor(connection, targetType, sessionId, rawSend) {
        super();
        this._disposed = false;
        this._crashed = false;
        this.setMaxListeners(0);
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this._rawSend = rawSend;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      markAsCrashed() {
        this._crashed = true;
      }
      async send(method, params) {
        if (this._crashed)
          throw new Error("Page crashed");
        this._connection._checkClosed(method);
        if (this._disposed)
          throw new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`);
        const id = this._connection.nextMessageId();
        this._rawSend({method, params, id});
        return new Promise((resolve2, reject) => {
          this._callbacks.set(id, {resolve: resolve2, reject, error: new Error(), method});
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error3) => debugLogger_1.debugLogger.log("error", error3));
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          utils_1.assert(!object.id);
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
      dispose(formattedBrowserLogs) {
        for (const callback of this._callbacks.values())
          callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): Target closed.` + formattedBrowserLogs));
        this._callbacks.clear();
        this._disposed = true;
        this._connection._sessions.delete(this._sessionId);
        Promise.resolve().then(() => this.emit(exports2.FFSessionEvents.Disconnected));
      }
    };
    exports2.FFSession = FFSession;
    function createProtocolError(error3, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return stackTrace_1.rewriteErrorMessage(error3, message);
    }
  }
});

// node_modules/playwright/lib/server/firefox/ffAccessibility.js
var require_ffAccessibility = __commonJS({
  "node_modules/playwright/lib/server/firefox/ffAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getAccessibilityTree = void 0;
    async function getAccessibilityTree(session, needle) {
      const objectId = needle ? needle._objectId : void 0;
      const {tree} = await session.send("Accessibility.getFullAXTree", {objectId});
      const axNode = new FFAXNode(tree);
      return {
        tree: axNode,
        needle: needle ? axNode._findNeedle() : null
      };
    }
    exports2.getAccessibilityTree = getAccessibilityTree;
    var FFRoleToARIARole = new Map(Object.entries({
      "pushbutton": "button",
      "checkbutton": "checkbox",
      "editcombobox": "combobox",
      "content deletion": "deletion",
      "footnote": "doc-footnote",
      "non-native document": "document",
      "grouping": "group",
      "graphic": "img",
      "content insertion": "insertion",
      "animation": "marquee",
      "flat equation": "math",
      "menupopup": "menu",
      "check menu item": "menuitemcheckbox",
      "radio menu item": "menuitemradio",
      "listbox option": "option",
      "radiobutton": "radio",
      "statusbar": "status",
      "pagetab": "tab",
      "pagetablist": "tablist",
      "propertypage": "tabpanel",
      "entry": "textbox",
      "outline": "tree",
      "tree table": "treegrid",
      "outlineitem": "treeitem"
    }));
    var FFAXNode = class {
      constructor(payload) {
        this._payload = payload;
        this._children = (payload.children || []).map((x) => new FFAXNode(x));
        this._editable = !!payload.editable;
        this._richlyEditable = this._editable && (payload.tag !== "textarea" && payload.tag !== "input");
        this._focusable = !!payload.focusable;
        this._expanded = !!payload.expanded;
        this._name = this._payload.name;
        this._role = this._payload.role;
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "entry";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "text leaf" || role === "text" || role === "statictext";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.foundObject)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "graphic":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "document" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "checkbutton":
          case "check menu item":
          case "check rich option":
          case "combobox":
          case "combobox option":
          case "color chooser":
          case "listbox":
          case "listbox option":
          case "listbox rich option":
          case "popup menu":
          case "menupopup":
          case "menuitem":
          case "menubar":
          case "button":
          case "pushbutton":
          case "radiobutton":
          case "radio menuitem":
          case "scrollbar":
          case "slider":
          case "spinbutton":
          case "switch":
          case "pagetab":
          case "entry":
          case "tree table":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name.trim();
      }
      serialize() {
        const node = {
          role: FFRoleToARIARole.get(this._role) || this._role,
          name: this._name || ""
        };
        const userStringProperties = [
          "name",
          "description",
          "roledescription",
          "valuetext",
          "keyshortcuts"
        ];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = [
          "disabled",
          "expanded",
          "focused",
          "modal",
          "multiline",
          "multiselectable",
          "readonly",
          "required",
          "selected"
        ];
        for (const booleanProperty of booleanProperties) {
          if (this._role === "document" && booleanProperty === "focused")
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = [
          "level"
        ];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = [
          "autocomplete",
          "haspopup",
          "invalid",
          "orientation"
        ];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        axNode.valueString = this._payload.value;
        if ("checked" in this._payload)
          axNode.checked = this._payload.checked === true ? "checked" : this._payload.checked === "mixed" ? "mixed" : "unchecked";
        if ("pressed" in this._payload)
          axNode.pressed = this._payload.pressed === true ? "pressed" : "released";
        return axNode;
      }
    };
  }
});

// node_modules/playwright/lib/server/firefox/ffExecutionContext.js
var require_ffExecutionContext = __commonJS({
  "node_modules/playwright/lib/server/firefox/ffExecutionContext.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FFExecutionContext = void 0;
    var js = __importStar(require_javascript());
    var stackTrace_1 = require_stackTrace();
    var utilityScriptSerializers_1 = require_utilityScriptSerializers();
    var FFExecutionContext = class {
      constructor(session, executionContextId) {
        this._session = session;
        this._executionContextId = executionContextId;
      }
      async rawEvaluateJSON(expression) {
        const payload = await this._session.send("Runtime.evaluate", {
          expression,
          returnByValue: true,
          executionContextId: this._executionContextId
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        return payload.result.value;
      }
      async rawEvaluateHandle(expression) {
        const payload = await this._session.send("Runtime.evaluate", {
          expression,
          returnByValue: false,
          executionContextId: this._executionContextId
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        return payload.result.objectId;
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunction", {
          functionDeclaration: func.toString(),
          args: args.map((a) => a instanceof js.JSHandle ? {objectId: a._objectId} : {value: a}),
          returnByValue: true,
          executionContextId: this._executionContextId
        }).catch(() => {
        });
      }
      async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        const payload = await this._session.send("Runtime.callFunction", {
          functionDeclaration: expression,
          args: [
            {objectId: utilityScript._objectId, value: void 0},
            ...values.map((value) => ({value})),
            ...objectIds.map((objectId) => ({objectId, value: void 0}))
          ],
          returnByValue,
          executionContextId: this._executionContextId
        }).catch(rewriteError);
        checkException(payload.exceptionDetails);
        if (returnByValue)
          return utilityScriptSerializers_1.parseEvaluationResultValue(payload.result.value);
        return utilityScript._context.createHandle(payload.result);
      }
      async getProperties(context, objectId) {
        const response = await this._session.send("Runtime.getObjectProperties", {
          executionContextId: this._executionContextId,
          objectId
        });
        const result = new Map();
        for (const property of response.properties)
          result.set(property.name, context.createHandle(property.value));
        return result;
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || "", remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      async releaseHandle(objectId) {
        await this._session.send("Runtime.disposeObject", {
          executionContextId: this._executionContextId,
          objectId
        });
      }
    };
    exports2.FFExecutionContext = FFExecutionContext;
    function checkException(exceptionDetails) {
      if (!exceptionDetails)
        return;
      if (exceptionDetails.value)
        throw new Error("Evaluation failed: " + JSON.stringify(exceptionDetails.value));
      else
        throw new Error("Evaluation failed: " + exceptionDetails.text + "\n" + exceptionDetails.stack);
    }
    function rewriteError(error3) {
      if (error3.message.includes("cyclic object value") || error3.message.includes("Object is not serializable"))
        return {result: {type: "undefined", value: void 0}};
      if (error3.message.includes("Failed to find execution context with id") || error3.message.includes("Execution context was destroyed!"))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      if (error3 instanceof TypeError && error3.message.startsWith("Converting circular structure to JSON"))
        stackTrace_1.rewriteErrorMessage(error3, error3.message + " Are you passing a nested JSHandle?");
      throw error3;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
  }
});

// node_modules/playwright/lib/server/firefox/ffInput.js
var require_ffInput = __commonJS({
  "node_modules/playwright/lib/server/firefox/ffInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Shift"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonNumber(button) {
      if (button === "left")
        return 0;
      if (button === "middle")
        return 1;
      if (button === "right")
        return 2;
      return 0;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(client) {
        this._client = client;
      }
      async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        if (code === "MetaLeft")
          code = "OSLeft";
        if (code === "MetaRight")
          code = "OSRight";
        if (text === "\r")
          text = "";
        await this._client.send("Page.dispatchKeyEvent", {
          type: "keydown",
          keyCode: keyCodeWithoutLocation,
          code,
          key,
          repeat: autoRepeat,
          location: location2,
          text
        });
      }
      async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        if (code === "MetaLeft")
          code = "OSLeft";
        if (code === "MetaRight")
          code = "OSRight";
        await this._client.send("Page.dispatchKeyEvent", {
          type: "keyup",
          key,
          keyCode: keyCodeWithoutLocation,
          code,
          location: location2,
          repeat: false
        });
      }
      async sendText(text) {
        await this._client.send("Page.insertText", {text});
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(client) {
        this._client = client;
      }
      async move(x, y, button, buttons, modifiers) {
        await this._client.send("Page.dispatchMouseEvent", {
          type: "mousemove",
          button: 0,
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
      async down(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send("Page.dispatchMouseEvent", {
          type: "mousedown",
          button: toButtonNumber(button),
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
      async up(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send("Page.dispatchMouseEvent", {
          type: "mouseup",
          button: toButtonNumber(button),
          buttons: toButtonsMask(buttons),
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = client;
      }
      async tap(x, y, modifiers) {
        await this._client.send("Page.dispatchTapEvent", {
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright/lib/server/firefox/ffNetworkManager.js
var require_ffNetworkManager = __commonJS({
  "node_modules/playwright/lib/server/firefox/ffNetworkManager.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FFNetworkManager = void 0;
    var helper_1 = require_helper();
    var network = __importStar(require_network());
    var FFNetworkManager = class {
      constructor(session, page) {
        this._startTime = 0;
        this._session = session;
        this._requests = new Map();
        this._page = page;
        this._eventListeners = [
          helper_1.helper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this)),
          helper_1.helper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)),
          helper_1.helper.addEventListener(session, "Network.requestFinished", this._onRequestFinished.bind(this)),
          helper_1.helper.addEventListener(session, "Network.requestFailed", this._onRequestFailed.bind(this))
        ];
      }
      dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
      }
      async setRequestInterception(enabled) {
        await this._session.send("Network.setRequestInterception", {enabled});
      }
      _onRequestWillBeSent(event) {
        const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
        const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;
        if (!frame)
          return;
        if (redirectedFrom)
          this._requests.delete(redirectedFrom._id);
        const request = new InterceptableRequest(this._session, frame, redirectedFrom, event);
        this._requests.set(request._id, request);
        this._page._frameManager.requestStarted(request.request);
      }
      _onResponseReceived(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const getResponseBody = async () => {
          const response2 = await this._session.send("Network.getResponseBody", {
            requestId: request._id
          });
          if (response2.evicted)
            throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
          return Buffer.from(response2.base64body, "base64");
        };
        this._startTime = event.timing.startTime;
        const timing = {
          startTime: this._startTime / 1e3,
          domainLookupStart: this._relativeTiming(event.timing.domainLookupStart),
          domainLookupEnd: this._relativeTiming(event.timing.domainLookupEnd),
          connectStart: this._relativeTiming(event.timing.connectStart),
          secureConnectionStart: this._relativeTiming(event.timing.secureConnectionStart),
          connectEnd: this._relativeTiming(event.timing.connectEnd),
          requestStart: this._relativeTiming(event.timing.requestStart),
          responseStart: this._relativeTiming(event.timing.responseStart)
        };
        const response = new network.Response(request.request, event.status, event.statusText, event.headers, timing, getResponseBody);
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onRequestFinished(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        const isRedirected = response.status() >= 300 && response.status() <= 399;
        if (isRedirected) {
          response._requestFinished(this._relativeTiming(event.responseEndTime), "Response body is unavailable for redirect responses");
        } else {
          this._requests.delete(request._id);
          response._requestFinished(this._relativeTiming(event.responseEndTime));
        }
        this._page._frameManager.requestFinished(request.request);
      }
      _onRequestFailed(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        this._requests.delete(request._id);
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(-1);
        request.request._setFailureText(event.errorCode);
        this._page._frameManager.requestFailed(request.request, event.errorCode === "NS_BINDING_ABORTED");
      }
      _relativeTiming(time) {
        if (!time)
          return -1;
        return (time - this._startTime) / 1e3;
      }
    };
    exports2.FFNetworkManager = FFNetworkManager;
    var causeToResourceType = {
      TYPE_INVALID: "other",
      TYPE_OTHER: "other",
      TYPE_SCRIPT: "script",
      TYPE_IMAGE: "image",
      TYPE_STYLESHEET: "stylesheet",
      TYPE_OBJECT: "other",
      TYPE_DOCUMENT: "document",
      TYPE_SUBDOCUMENT: "document",
      TYPE_REFRESH: "document",
      TYPE_XBL: "other",
      TYPE_PING: "other",
      TYPE_XMLHTTPREQUEST: "xhr",
      TYPE_OBJECT_SUBREQUEST: "other",
      TYPE_DTD: "other",
      TYPE_FONT: "font",
      TYPE_MEDIA: "media",
      TYPE_WEBSOCKET: "websocket",
      TYPE_CSP_REPORT: "other",
      TYPE_XSLT: "other",
      TYPE_BEACON: "other",
      TYPE_FETCH: "fetch",
      TYPE_IMAGESET: "images",
      TYPE_WEB_MANIFEST: "manifest"
    };
    var internalCauseToResourceType = {
      TYPE_INTERNAL_EVENTSOURCE: "eventsource"
    };
    var InterceptableRequest = class {
      constructor(session, frame, redirectedFrom, payload) {
        this._id = payload.requestId;
        this._session = session;
        let postDataBuffer = null;
        if (payload.postData)
          postDataBuffer = Buffer.from(payload.postData, "base64");
        this.request = new network.Request(payload.isIntercepted ? this : null, frame, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || "other", payload.method, postDataBuffer, payload.headers);
      }
      async continue(overrides) {
        await this._session.sendMayFail("Network.resumeInterceptedRequest", {
          requestId: this._id,
          url: overrides.url,
          method: overrides.method,
          headers: overrides.headers,
          postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
        });
      }
      async fulfill(response) {
        const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
        await this._session.sendMayFail("Network.fulfillInterceptedRequest", {
          requestId: this._id,
          status: response.status,
          statusText: network.STATUS_TEXTS[String(response.status)] || "",
          headers: response.headers,
          base64body
        });
      }
      async abort(errorCode) {
        await this._session.sendMayFail("Network.abortInterceptedRequest", {
          requestId: this._id,
          errorCode
        });
      }
    };
  }
});

// node_modules/playwright/lib/server/firefox/ffPage.js
var require_ffPage = __commonJS({
  "node_modules/playwright/lib/server/firefox/ffPage.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FFPage = void 0;
    var dialog = __importStar(require_dialog());
    var dom = __importStar(require_dom());
    var helper_1 = require_helper();
    var utils_1 = require_utils();
    var page_1 = require_page();
    var ffAccessibility_1 = require_ffAccessibility();
    var ffConnection_1 = require_ffConnection();
    var ffExecutionContext_1 = require_ffExecutionContext();
    var ffInput_1 = require_ffInput();
    var ffNetworkManager_1 = require_ffNetworkManager();
    var stackTrace_1 = require_stackTrace();
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var FFPage = class {
      constructor(session, browserContext, opener) {
        this.cspErrorsAsynchronousForInlineScipts = true;
        this._pageCallback = () => {
        };
        this._initializedPage = null;
        this._initializationFailed = false;
        this._workers = new Map();
        this._session = session;
        this._opener = opener;
        this.rawKeyboard = new ffInput_1.RawKeyboardImpl(session);
        this.rawMouse = new ffInput_1.RawMouseImpl(session);
        this.rawTouchscreen = new ffInput_1.RawTouchscreenImpl(session);
        this._contextIdToContext = new Map();
        this._browserContext = browserContext;
        this._page = new page_1.Page(this, browserContext);
        this._networkManager = new ffNetworkManager_1.FFNetworkManager(session, this._page);
        this._page.on(page_1.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame));
        this._eventListeners = [
          helper_1.helper.addEventListener(this._session, "Page.eventFired", this._onEventFired.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.frameAttached", this._onFrameAttached.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.frameDetached", this._onFrameDetached.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.navigationAborted", this._onNavigationAborted.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.navigationCommitted", this._onNavigationCommitted.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.navigationStarted", this._onNavigationStarted.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.sameDocumentNavigation", this._onSameDocumentNavigation.bind(this)),
          helper_1.helper.addEventListener(this._session, "Runtime.executionContextCreated", this._onExecutionContextCreated.bind(this)),
          helper_1.helper.addEventListener(this._session, "Runtime.executionContextDestroyed", this._onExecutionContextDestroyed.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.linkClicked", (event) => this._onLinkClicked(event.phase)),
          helper_1.helper.addEventListener(this._session, "Page.uncaughtError", this._onUncaughtError.bind(this)),
          helper_1.helper.addEventListener(this._session, "Runtime.console", this._onConsole.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.dialogOpened", this._onDialogOpened.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.bindingCalled", this._onBindingCalled.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.fileChooserOpened", this._onFileChooserOpened.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.workerCreated", this._onWorkerCreated.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.workerDestroyed", this._onWorkerDestroyed.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.dispatchMessageFromWorker", this._onDispatchMessageFromWorker.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.crashed", this._onCrashed.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.screencastStarted", this._onScreencastStarted.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.webSocketCreated", this._onWebSocketCreated.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.webSocketClosed", this._onWebSocketClosed.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.webSocketFrameReceived", this._onWebSocketFrameReceived.bind(this)),
          helper_1.helper.addEventListener(this._session, "Page.webSocketFrameSent", this._onWebSocketFrameSent.bind(this))
        ];
        this._pagePromise = new Promise((f) => this._pageCallback = f);
        session.once(ffConnection_1.FFSessionEvents.Disconnected, () => {
          this._markAsError(new Error("Page closed"));
          this._page._didDisconnect();
        });
        this._session.once("Page.ready", async () => {
          await this._page.initOpener(this._opener);
          this._initializedPage = this._page;
          this._page.reportAsNew();
          this._pageCallback(this._page);
        });
        this._session.send("Page.addScriptToEvaluateOnNewDocument", {script: "", worldName: UTILITY_WORLD_NAME}).catch((e) => this._markAsError(e));
      }
      async _markAsError(error3) {
        if (this._initializationFailed)
          return;
        this._initializationFailed = true;
        if (!this._initializedPage) {
          await this._page.initOpener(this._opener);
          this._page.reportAsNew(error3);
          this._pageCallback(error3);
        }
      }
      async pageOrError() {
        return this._pagePromise;
      }
      _onWebSocketCreated(event) {
        this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
        this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketClosed(event) {
        if (event.error)
          this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
        this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketFrameReceived(event) {
        this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onWebSocketFrameSent(event) {
        this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onExecutionContextCreated(payload) {
        const {executionContextId, auxData} = payload;
        const frame = this._page._frameManager.frame(auxData ? auxData.frameId : null);
        if (!frame)
          return;
        const delegate = new ffExecutionContext_1.FFExecutionContext(this._session, executionContextId);
        let worldName = null;
        if (auxData.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        else if (!auxData.name)
          worldName = "main";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(executionContextId, context);
      }
      _onExecutionContextDestroyed(payload) {
        const {executionContextId} = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame)
            this._contextIdToContext.delete(contextId);
        }
      }
      _onLinkClicked(phase) {
        if (phase === "before")
          this._page._frameManager.frameWillPotentiallyRequestNavigation();
        else
          this._page._frameManager.frameDidPotentiallyRequestNavigation();
      }
      _onNavigationStarted(params) {
        this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
      }
      _onNavigationAborted(params) {
        this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
      }
      _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
          if (worker.frameId === params.frameId)
            this._onWorkerDestroyed({workerId});
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || "", params.navigationId || "", false);
      }
      _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
      }
      _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
      }
      _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
      }
      _onEventFired(payload) {
        const {frameId, name} = payload;
        if (name === "load")
          this._page._frameManager.frameLifecycleEvent(frameId, "load");
        if (name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
      }
      _onUncaughtError(params) {
        const {name, message} = stackTrace_1.splitErrorMessage(params.message);
        const error3 = new Error(message);
        error3.stack = params.stack;
        error3.name = name;
        this._page.emit(page_1.Page.Events.PageError, error3);
      }
      _onConsole(payload) {
        const {type, args, executionContextId, location: location2} = payload;
        const context = this._contextIdToContext.get(executionContextId);
        this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
      }
      _onDialogOpened(params) {
        this._page.emit(page_1.Page.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, async (accept, promptText) => {
          await this._session.sendMayFail("Page.handleDialog", {dialogId: params.dialogId, accept, promptText});
        }, params.defaultValue));
      }
      async _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        const pageOrError = await this.pageOrError();
        if (!(pageOrError instanceof Error))
          await this._page._onBindingCalled(event.payload, context);
      }
      async _onFileChooserOpened(payload) {
        const {executionContextId, element} = payload;
        const context = this._contextIdToContext.get(executionContextId);
        const handle = context.createHandle(element).asElement();
        await this._page._onFileChooserOpened(handle);
      }
      async _onWorkerCreated(event) {
        const workerId = event.workerId;
        const worker = new page_1.Worker(this._page, event.url);
        const workerSession = new ffConnection_1.FFSession(this._session._connection, "worker", workerId, (message) => {
          this._session.send("Page.sendMessageToWorker", {
            frameId: event.frameId,
            workerId,
            message: JSON.stringify(message)
          }).catch((e) => {
            workerSession.dispatchMessage({id: message.id, method: "", params: {}, error: {message: e.message, data: void 0}});
          });
        });
        this._workers.set(workerId, {session: workerSession, frameId: event.frameId});
        this._page._addWorker(workerId, worker);
        workerSession.once("Runtime.executionContextCreated", (event2) => {
          worker._createExecutionContext(new ffExecutionContext_1.FFExecutionContext(workerSession, event2.executionContextId));
        });
        workerSession.on("Runtime.console", (event2) => {
          const {type, args, location: location2} = event2;
          const context = worker._existingExecutionContext;
          this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
        });
      }
      _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.session.dispose();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
      }
      async _onDispatchMessageFromWorker(event) {
        const worker = this._workers.get(event.workerId);
        if (!worker)
          return;
        worker.session.dispatchMessage(JSON.parse(event.message));
      }
      async _onCrashed(event) {
        this._session.markAsCrashed();
        this._page._didCrash();
      }
      _onScreencastStarted(event) {
        this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());
      }
      async exposeBinding(binding) {
        if (binding.world !== "main")
          throw new Error("Only main context bindings are supported in Firefox.");
        await this._session.send("Page.addBinding", {name: binding.name, script: binding.source});
      }
      didClose() {
        this._session.dispose();
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
      }
      async navigateFrame(frame, url, referer) {
        const response = await this._session.send("Page.navigate", {url, referer, frameId: frame._id});
        return {newDocumentId: response.navigationId || void 0};
      }
      async updateExtraHTTPHeaders() {
        await this._session.send("Network.setExtraHTTPHeaders", {headers: this._page._state.extraHTTPHeaders || []});
      }
      async setEmulatedSize(emulatedSize) {
        utils_1.assert(this._page._state.emulatedSize === emulatedSize);
        await this._session.send("Page.setViewportSize", {
          viewportSize: {
            width: emulatedSize.viewport.width,
            height: emulatedSize.viewport.height
          }
        });
      }
      async bringToFront() {
        await this._session.send("Page.bringToFront", {});
      }
      async updateEmulateMedia() {
        const colorScheme = this._page._state.colorScheme || this._browserContext._options.colorScheme || "light";
        await this._session.send("Page.setEmulatedMedia", {
          type: this._page._state.mediaType === null ? "" : this._page._state.mediaType,
          colorScheme
        });
      }
      async updateRequestInterception() {
        await this._networkManager.setRequestInterception(this._page._needsRequestInterception());
      }
      async setFileChooserIntercepted(enabled) {
        await this._session.send("Page.setInterceptFileChooserDialog", {enabled}).catch((e) => {
        });
      }
      async reload() {
        await this._session.send("Page.reload", {frameId: this._page.mainFrame()._id});
      }
      async goBack() {
        const {success} = await this._session.send("Page.goBack", {frameId: this._page.mainFrame()._id});
        return success;
      }
      async goForward() {
        const {success} = await this._session.send("Page.goForward", {frameId: this._page.mainFrame()._id});
        return success;
      }
      async evaluateOnNewDocument(source) {
        await this._session.send("Page.addScriptToEvaluateOnNewDocument", {script: source});
      }
      async closePage(runBeforeUnload) {
        await this._session.send("Page.close", {runBeforeUnload});
      }
      canScreenshotOutsideViewport() {
        return true;
      }
      async setBackgroundColor(color) {
        if (color)
          throw new Error("Not implemented");
      }
      async takeScreenshot(progress, format2, documentRect, viewportRect, quality) {
        if (!documentRect) {
          const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({x: window.scrollX, y: window.scrollY}));
          documentRect = {
            x: viewportRect.x + scrollOffset.x,
            y: viewportRect.y + scrollOffset.y,
            width: viewportRect.width,
            height: viewportRect.height
          };
        }
        progress.throwIfAborted();
        const {data} = await this._session.send("Page.screenshot", {
          mimeType: "image/" + format2,
          clip: documentRect
        });
        return Buffer.from(data, "base64");
      }
      async resetViewport() {
        utils_1.assert(false, "Should not be called");
      }
      async getContentFrame(handle) {
        const {contentFrameId} = await this._session.send("Page.describeNode", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId
        });
        if (!contentFrameId)
          return null;
        return this._page._frameManager.frame(contentFrameId);
      }
      async getOwnerFrame(handle) {
        const {ownerFrameId} = await this._session.send("Page.describeNode", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId
        });
        return ownerFrameId || null;
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
          return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
          for (const point of quad) {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
          }
        }
        return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
      }
      async scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._session.send("Page.scrollIntoViewIfNeeded", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId,
          rect
        }).then(() => "done").catch((e) => {
          if (e instanceof Error && e.message.includes("Node is detached from document"))
            return "error:notconnected";
          if (e instanceof Error && e.message.includes("Node does not have a layout object"))
            return "error:notvisible";
          throw e;
        });
      }
      async setScreencastEnabled(enabled) {
        throw new Error("Not implemented");
      }
      rafCountForStablePosition() {
        return 1;
      }
      async getContentQuads(handle) {
        const result = await this._session.sendMayFail("Page.getContentQuads", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId
        });
        if (!result)
          return null;
        return result.quads.map((quad) => [quad.p1, quad.p2, quad.p3, quad.p4]);
      }
      async setInputFiles(handle, files) {
        await handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
      }
      async adoptElementHandle(handle, to) {
        const result = await this._session.send("Page.adoptNode", {
          frameId: handle._context.frame._id,
          objectId: handle._objectId,
          executionContextId: to._delegate._executionContextId
        });
        if (!result.remoteObject)
          throw new Error("Unable to adopt element handle from a different document");
        return to.createHandle(result.remoteObject);
      }
      async getAccessibilityTree(needle) {
        return ffAccessibility_1.getAccessibilityTree(this._session, needle);
      }
      async inputActionEpilogue() {
      }
      async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        const handles = await this._page.selectors._queryAll(parent, "iframe", void 0);
        const items = await Promise.all(handles.map(async (handle) => {
          const frame2 = await handle.contentFrame().catch((e) => null);
          return {handle, frame: frame2};
        }));
        const result = items.find((item) => item.frame === frame);
        items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
        if (!result)
          throw new Error("Frame has been detached.");
        return result.handle;
      }
    };
    exports2.FFPage = FFPage;
    function webSocketId(frameId, wsid) {
      return `${frameId}---${wsid}`;
    }
  }
});

// node_modules/playwright/lib/server/firefox/ffBrowser.js
var require_ffBrowser = __commonJS({
  "node_modules/playwright/lib/server/firefox/ffBrowser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FFBrowserContext = exports2.FFBrowser = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    var browser_1 = require_browser2();
    var browserContext_1 = require_browserContext();
    var network = __importStar(require_network());
    var ffConnection_1 = require_ffConnection();
    var ffPage_1 = require_ffPage();
    var FFBrowser = class extends browser_1.Browser {
      constructor(connection, options2) {
        super(options2);
        this._version = "";
        this._connection = connection;
        this._ffPages = new Map();
        this._contexts = new Map();
        this._connection.on(ffConnection_1.ConnectionEvents.Disconnected, () => this._onDisconnect());
        this._connection.on("Browser.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._connection.on("Browser.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._connection.on("Browser.downloadCreated", this._onDownloadCreated.bind(this));
        this._connection.on("Browser.downloadFinished", this._onDownloadFinished.bind(this));
        this._connection.on("Browser.screencastFinished", this._onScreencastFinished.bind(this));
      }
      static async connect(transport, options2) {
        const connection = new ffConnection_1.FFConnection(transport, options2.protocolLogger, options2.browserLogsCollector);
        const browser = new FFBrowser(connection, options2);
        if (options2.__testHookOnConnectToBrowser)
          await options2.__testHookOnConnectToBrowser();
        const promises = [
          connection.send("Browser.enable", {attachToDefaultContext: !!options2.persistent}),
          browser._initVersion()
        ];
        if (options2.persistent) {
          browser._defaultContext = new FFBrowserContext(browser, void 0, options2.persistent);
          promises.push(browser._defaultContext._initialize());
        }
        if (options2.proxy)
          promises.push(browser._connection.send("Browser.setBrowserProxy", toJugglerProxyOptions(options2.proxy)));
        await Promise.all(promises);
        return browser;
      }
      async _initVersion() {
        const result = await this._connection.send("Browser.getInfo");
        this._version = result.version.substring(result.version.indexOf("/") + 1);
      }
      isConnected() {
        return !this._connection._closed;
      }
      async newContext(options2) {
        browserContext_1.validateBrowserContextOptions(options2, this.options);
        if (options2.isMobile)
          throw new Error("options.isMobile is not supported in Firefox");
        const {browserContextId} = await this._connection.send("Browser.createBrowserContext", {removeOnDetach: true});
        const context = new FFBrowserContext(this, browserContextId, options2);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      _onDetachedFromTarget(payload) {
        const ffPage = this._ffPages.get(payload.targetId);
        this._ffPages.delete(payload.targetId);
        ffPage.didClose();
      }
      _onAttachedToTarget(payload) {
        const {targetId, browserContextId, openerId, type} = payload.targetInfo;
        utils_1.assert(type === "page");
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        utils_1.assert(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
        const session = this._connection.createSession(payload.sessionId, type);
        const opener = openerId ? this._ffPages.get(openerId) : null;
        const ffPage = new ffPage_1.FFPage(session, context, opener);
        this._ffPages.set(targetId, ffPage);
      }
      _onDownloadCreated(payload) {
        const ffPage = this._ffPages.get(payload.pageTargetId);
        utils_1.assert(ffPage);
        if (!ffPage)
          return;
        let originPage = ffPage._initializedPage;
        if (!originPage) {
          ffPage._markAsError(new Error("Starting new page download"));
          if (ffPage._opener)
            originPage = ffPage._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
      }
      _onDownloadFinished(payload) {
        const error3 = payload.canceled ? "canceled" : payload.error;
        this._downloadFinished(payload.uuid, error3);
      }
      _onScreencastFinished(payload) {
        var _a;
        (_a = this._takeVideo(payload.screencastId)) === null || _a === void 0 ? void 0 : _a.reportFinished();
      }
      _onDisconnect() {
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(errors_1.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
    };
    exports2.FFBrowser = FFBrowser;
    var FFBrowserContext = class extends browserContext_1.BrowserContext {
      constructor(browser, browserContextId, options2) {
        super(browser, options2, browserContextId);
        this._browser = browser;
      }
      async _initialize() {
        utils_1.assert(!this._ffPages().length);
        const browserContextId = this._browserContextId;
        const promises = [super._initialize()];
        if (this._browser.options.downloadsPath) {
          promises.push(this._browser._connection.send("Browser.setDownloadOptions", {
            browserContextId,
            downloadOptions: {
              behavior: this._options.acceptDownloads ? "saveToDisk" : "cancel",
              downloadsDir: this._browser.options.downloadsPath
            }
          }));
        }
        if (this._options.viewport) {
          const viewport = {
            viewportSize: {width: this._options.viewport.width, height: this._options.viewport.height},
            deviceScaleFactor: this._options.deviceScaleFactor || 1
          };
          promises.push(this._browser._connection.send("Browser.setDefaultViewport", {browserContextId, viewport}));
        }
        if (this._options.hasTouch)
          promises.push(this._browser._connection.send("Browser.setTouchOverride", {browserContextId, hasTouch: true}));
        if (this._options.userAgent)
          promises.push(this._browser._connection.send("Browser.setUserAgentOverride", {browserContextId, userAgent: this._options.userAgent}));
        if (this._options.bypassCSP)
          promises.push(this._browser._connection.send("Browser.setBypassCSP", {browserContextId, bypassCSP: true}));
        if (this._options.ignoreHTTPSErrors)
          promises.push(this._browser._connection.send("Browser.setIgnoreHTTPSErrors", {browserContextId, ignoreHTTPSErrors: true}));
        if (this._options.javaScriptEnabled === false)
          promises.push(this._browser._connection.send("Browser.setJavaScriptDisabled", {browserContextId, javaScriptDisabled: true}));
        if (this._options.locale)
          promises.push(this._browser._connection.send("Browser.setLocaleOverride", {browserContextId, locale: this._options.locale}));
        if (this._options.timezoneId)
          promises.push(this._browser._connection.send("Browser.setTimezoneOverride", {browserContextId, timezoneId: this._options.timezoneId}));
        if (this._options.permissions)
          promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.extraHTTPHeaders || this._options.locale)
          promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
        if (this._options.httpCredentials)
          promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        if (this._options.geolocation)
          promises.push(this.setGeolocation(this._options.geolocation));
        if (this._options.offline)
          promises.push(this.setOffline(this._options.offline));
        if (this._options.colorScheme)
          promises.push(this._browser._connection.send("Browser.setColorScheme", {browserContextId, colorScheme: this._options.colorScheme}));
        if (this._options.recordVideo) {
          promises.push(this._ensureVideosPath().then(() => {
            return this._browser._connection.send("Browser.setScreencastOptions", {
              ...this._options.recordVideo.size,
              dir: this._options.recordVideo.dir,
              browserContextId: this._browserContextId
            });
          }));
        }
        if (this._options.proxy) {
          promises.push(this._browser._connection.send("Browser.setContextProxy", {
            browserContextId: this._browserContextId,
            ...toJugglerProxyOptions(this._options.proxy)
          }));
        }
        await Promise.all(promises);
      }
      _ffPages() {
        return Array.from(this._browser._ffPages.values()).filter((ffPage) => ffPage._browserContext === this);
      }
      pages() {
        return this._ffPages().map((ffPage) => ffPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      async newPageDelegate() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const {targetId} = await this._browser._connection.send("Browser.newPage", {
          browserContextId: this._browserContextId
        }).catch((e) => {
          if (e.message.includes("Failed to override timezone"))
            throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
          throw e;
        });
        return this._browser._ffPages.get(targetId);
      }
      async _doCookies(urls) {
        const {cookies} = await this._browser._connection.send("Browser.getCookies", {browserContextId: this._browserContextId});
        return network.filterCookies(cookies.map((c) => {
          const copy = {...c};
          delete copy.size;
          delete copy.session;
          return copy;
        }), urls);
      }
      async addCookies(cookies) {
        const cc = network.rewriteCookies(cookies).map((c) => ({
          ...c,
          expires: c.expires && c.expires !== -1 ? c.expires : void 0
        }));
        await this._browser._connection.send("Browser.setCookies", {browserContextId: this._browserContextId, cookies: cc});
      }
      async clearCookies() {
        await this._browser._connection.send("Browser.clearCookies", {browserContextId: this._browserContextId});
      }
      async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
          ["geolocation", "geo"],
          ["persistent-storage", "persistent-storage"],
          ["push", "push"],
          ["notifications", "desktop-notification"]
        ]);
        const filtered = permissions.map((permission) => {
          const protocolPermission = webPermissionToProtocol.get(permission);
          if (!protocolPermission)
            throw new Error("Unknown permission: " + permission);
          return protocolPermission;
        });
        await this._browser._connection.send("Browser.grantPermissions", {origin, browserContextId: this._browserContextId, permissions: filtered});
      }
      async _doClearPermissions() {
        await this._browser._connection.send("Browser.resetPermissions", {browserContextId: this._browserContextId});
      }
      async setGeolocation(geolocation) {
        browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation;
        await this._browser._connection.send("Browser.setGeolocationOverride", {browserContextId: this._browserContextId, geolocation: geolocation || null});
      }
      async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        let allHeaders = this._options.extraHTTPHeaders;
        if (this._options.locale)
          allHeaders = network.mergeHeaders([allHeaders, network.singleHeader("Accept-Language", this._options.locale)]);
        await this._browser._connection.send("Browser.setExtraHTTPHeaders", {browserContextId: this._browserContextId, headers: allHeaders});
      }
      async setOffline(offline) {
        this._options.offline = offline;
        await this._browser._connection.send("Browser.setOnlineOverride", {browserContextId: this._browserContextId, override: offline ? "offline" : "online"});
      }
      async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        await this._browser._connection.send("Browser.setHTTPCredentials", {browserContextId: this._browserContextId, credentials: httpCredentials || null});
      }
      async _doAddInitScript(source) {
        await this._browser._connection.send("Browser.addScriptToEvaluateOnNewDocument", {browserContextId: this._browserContextId, script: source});
      }
      async _doExposeBinding(binding) {
        if (binding.world !== "main")
          throw new Error("Only main context bindings are supported in Firefox.");
        await this._browser._connection.send("Browser.addBinding", {browserContextId: this._browserContextId, name: binding.name, script: binding.source});
      }
      async _doUpdateRequestInterception() {
        await this._browser._connection.send("Browser.setRequestInterception", {browserContextId: this._browserContextId, enabled: !!this._requestInterceptor});
      }
      async _doClose() {
        utils_1.assert(this._browserContextId);
        await this._browser._connection.send("Browser.removeBrowserContext", {browserContextId: this._browserContextId});
        this._browser._contexts.delete(this._browserContextId);
      }
    };
    exports2.FFBrowserContext = FFBrowserContext;
    function toJugglerProxyOptions(proxy) {
      const proxyServer = new URL(proxy.server);
      let port = parseInt(proxyServer.port, 10);
      let type = "http";
      if (proxyServer.protocol === "socks5:")
        type = "socks";
      else if (proxyServer.protocol === "socks4:")
        type = "socks4";
      else if (proxyServer.protocol === "https:")
        type = "https";
      if (proxyServer.port === "") {
        if (proxyServer.protocol === "http:")
          port = 80;
        else if (proxyServer.protocol === "https:")
          port = 443;
      }
      return {
        type,
        bypass: proxy.bypass ? proxy.bypass.split(",").map((domain) => domain.trim()) : [],
        host: proxyServer.hostname,
        port,
        username: proxy.username,
        password: proxy.password
      };
    }
  }
});

// node_modules/playwright/lib/server/firefox/firefox.js
var require_firefox = __commonJS({
  "node_modules/playwright/lib/server/firefox/firefox.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Firefox = void 0;
    var os = __importStar(require("os"));
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var utils_1 = require_utils();
    var ffBrowser_1 = require_ffBrowser();
    var ffConnection_1 = require_ffConnection();
    var browserType_1 = require_browserType();
    var Firefox = class extends browserType_1.BrowserType {
      constructor(playwrightOptions) {
        super("firefox", playwrightOptions);
      }
      executablePath(channel) {
        if (channel) {
          let executablePath = void 0;
          if (channel === "firefox-stable")
            executablePath = this._registry.executablePath("firefox-stable");
          utils_1.assert(executablePath, `unsupported firefox channel "${channel}"`);
          utils_1.assert(fs_1.default.existsSync(executablePath), `"${channel}" channel is not installed. Try running 'npx playwright install ${channel}'`);
          return executablePath;
        }
        return super.executablePath(channel);
      }
      _connectToTransport(transport, options2) {
        return ffBrowser_1.FFBrowser.connect(transport, options2);
      }
      _rewriteStartupError(error3) {
        return error3;
      }
      _amendEnvironment(env2, userDataDir, executable, browserArguments) {
        if (!path_1.default.isAbsolute(os.homedir()))
          throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
        if (os.platform() === "linux") {
          return {
            ...env2,
            LD_LIBRARY_PATH: `${path_1.default.dirname(executable)}:${process.env.LD_LIBRARY_PATH}`
          };
        }
        if (os.platform() === "darwin") {
          return {
            ...env2,
            MOZ_WEBRENDER: 0
          };
        }
        return env2;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {method: "Browser.close", params: {}, id: ffConnection_1.kBrowserCloseMessageId};
        transport.send(message);
      }
      _defaultArgs(options2, isPersistent, userDataDir) {
        const {args = [], devtools, headless} = options2;
        if (devtools)
          console.warn("devtools parameter is not supported as a launch argument in Firefox. You can launch the devtools window manually.");
        const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument");
        if (args.find((arg) => arg.startsWith("-juggler")))
          throw new Error("Use the port parameter instead of -juggler argument");
        const firefoxUserPrefs = isPersistent ? void 0 : options2.firefoxUserPrefs;
        if (firefoxUserPrefs) {
          const lines = [];
          for (const [name, value] of Object.entries(firefoxUserPrefs))
            lines.push(`user_pref(${JSON.stringify(name)}, ${JSON.stringify(value)});`);
          fs_1.default.writeFileSync(path_1.default.join(userDataDir, "user.js"), lines.join("\n"));
        }
        const firefoxArguments = ["-no-remote"];
        if (headless) {
          firefoxArguments.push("-headless");
        } else {
          firefoxArguments.push("-wait-for-browser");
          firefoxArguments.push("-foreground");
        }
        firefoxArguments.push(`-profile`, userDataDir);
        firefoxArguments.push("-juggler-pipe");
        firefoxArguments.push(...args);
        if (isPersistent)
          firefoxArguments.push("about:blank");
        else
          firefoxArguments.push("-silent");
        return firefoxArguments;
      }
    };
    exports2.Firefox = Firefox;
  }
});

// node_modules/playwright/lib/server/webkit/wkConnection.js
var require_wkConnection = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isSwappedOutError = exports2.createProtocolError = exports2.WKSession = exports2.WKConnection = exports2.kPageProxyMessageReceived = exports2.kBrowserCloseMessageId = void 0;
    var events_1 = require("events");
    var utils_1 = require_utils();
    var stackTrace_1 = require_stackTrace();
    var debugLogger_1 = require_debugLogger();
    var helper_1 = require_helper();
    var errors_1 = require_errors();
    exports2.kBrowserCloseMessageId = -9999;
    exports2.kPageProxyMessageReceived = "kPageProxyMessageReceived";
    var WKConnection = class {
      constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
        this._lastId = 0;
        this._closed = false;
        this._transport = transport;
        this._transport.onmessage = this._dispatchMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._onDisconnect = onDisconnect;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this.browserSession = new WKSession(this, "", errors_1.kBrowserClosedError, (message) => {
          this.rawSend(message);
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _dispatchMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === exports2.kBrowserCloseMessageId)
          return;
        if (message.pageProxyId) {
          const payload = {message, pageProxyId: message.pageProxyId};
          this.browserSession.dispatchMessage({method: exports2.kPageProxyMessageReceived, params: payload});
          return;
        }
        this.browserSession.dispatchMessage(message);
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        this.browserSession.dispose(true);
        this._onDisconnect();
      }
      isClosed() {
        return this._closed;
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
    };
    exports2.WKConnection = WKConnection;
    var WKSession = class extends events_1.EventEmitter {
      constructor(connection, sessionId, errorText, rawSend) {
        super();
        this._disposed = false;
        this._callbacks = new Map();
        this._crashed = false;
        this.setMaxListeners(0);
        this.connection = connection;
        this.sessionId = sessionId;
        this._rawSend = rawSend;
        this.errorText = errorText;
        this.on = super.on;
        this.off = super.removeListener;
        this.addListener = super.addListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      async send(method, params) {
        if (this._crashed)
          throw new Error("Target crashed");
        if (this._disposed)
          throw new Error(`Protocol error (${method}): ${this.errorText}`);
        const id = this.connection.nextMessageId();
        const messageObj = {id, method, params};
        this._rawSend(messageObj);
        return new Promise((resolve2, reject) => {
          this._callbacks.set(id, {resolve: resolve2, reject, error: new Error(), method});
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error3) => debugLogger_1.debugLogger.log("error", error3));
      }
      markAsCrashed() {
        this._crashed = true;
      }
      isDisposed() {
        return this._disposed;
      }
      dispose(disconnected) {
        if (disconnected)
          this.errorText = "Browser closed." + helper_1.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());
        for (const callback of this._callbacks.values())
          callback.reject(stackTrace_1.rewriteErrorMessage(callback.error, `Protocol error (${callback.method}): ${this.errorText}`));
        this._callbacks.clear();
        this._disposed = true;
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else if (object.id && !object.error) {
          utils_1.assert(this.isDisposed());
        } else {
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
    };
    exports2.WKSession = WKSession;
    function createProtocolError(error3, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${JSON.stringify(protocolError.data)}`;
      return stackTrace_1.rewriteErrorMessage(error3, message);
    }
    exports2.createProtocolError = createProtocolError;
    function isSwappedOutError(e) {
      return e.message.includes("Target was swapped out.");
    }
    exports2.isSwappedOutError = isSwappedOutError;
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa = btoa || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module2 === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init2() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init2();
    }
    if (typeof module2 !== "undefined") {
      module2.exports = encode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({children: [], index: 0});
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = {children: [], index: 0});
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = {children: [], index: 0});
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s2 = rs & 15, r = rs >> 4;
            if (s2 === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s2);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s2 = rs & 15, r = rs >> 4;
            if (s2 === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s2) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s2 = rs & 15, r = rs >> 4;
                if (s2 === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s2 !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s2);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load2(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 0, maxV2 = 0;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: {major: appData[5], minor: appData[6]},
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module2 !== "undefined") {
      module2.exports = decode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        maxMemoryUsageInMB: 512
      };
      var opts = {...defaultOpts, ...userOpts};
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image["comments"] = decoder.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        } else {
          throw err;
        }
      }
      decoder.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode = require_encoder();
    var decode = require_decoder();
    module2.exports = {
      encode,
      decode
    };
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream2.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream2);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read2) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read2.length) {
        this._buffered -= read2.length;
        this._buffers[0] = smallerBuf.slice(read2.length);
        read2.func.call(this, smallerBuf.slice(0, read2.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read2.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read2) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read2.length);
      while (pos < read2.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read2.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read2.length;
      read2.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read2 = this._reads[0];
          if (read2.allowLess) {
            this._processReadAllowingLess(read2);
          } else if (this._buffered >= read2.length) {
            this._processRead(read2);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports2) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports2.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i = 0; i < imagePasses.length; i++) {
        let pass = imagePasses[i];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({width: passWidth, height: passHeight, index: i});
        }
      }
      return images;
    };
    exports2.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        let outerXLeftOver = x % imagePasses[pass].x.length;
        let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports2, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports2, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f3Up = lastLine ? lastLine[x] : 0;
        let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f4Up = lastLine ? lastLine[x] : 0;
        let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports2, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (let i = 0; i < 256; i++) {
        let currentCrc = i;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options2, dependencies) {
      this._options = options2;
      options2.checkCRC = options2.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants.PNG_SIGNATURE;
      for (let i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i = 0; i < entries; i++) {
        this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i];
        i++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports2.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{width, height}];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports2, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var zlib2 = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options2) {
      ChunkStream.call(this);
      this._parser = new Parser(options2, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options2;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib2.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
          this._inflate = zlib2.createInflate({chunkSize});
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    module2.exports = function(dataIn, width, height, options2) {
      let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options2.colorType) !== -1;
      if (options2.colorType === options2.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options2.bitDepth === 8 || options2.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options2.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants.COLORTYPE_TO_BPP_MAP[options2.inputColorType];
      if (inBpp === 4 && !options2.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants.COLORTYPE_TO_BPP_MAP[options2.colorType];
      if (options2.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options2.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options2.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options2.inputColorType + " is not supported at present");
        }
        if (options2.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return {red, green, blue, alpha};
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let rgba = getRGBA(data, inIndex);
          switch (options2.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options2.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options2.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options2.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports2, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x = pxPos; x < length; x++) {
        let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        let val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options2, bpp) {
      let filterTypes;
      if (!("filterType" in options2) || options2.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options2.filterType === "number") {
        filterTypes = [options2.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options2.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i = 0; i < filterTypes.length; i++) {
            let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib2 = require("zlib");
    var Packer = module2.exports = function(options2) {
      this._options = options2;
      options2.deflateChunkSize = options2.deflateChunkSize || 32 * 1024;
      options2.deflateLevel = options2.deflateLevel != null ? options2.deflateLevel : 9;
      options2.deflateStrategy = options2.deflateStrategy != null ? options2.deflateStrategy : 3;
      options2.inputHasAlpha = options2.inputHasAlpha != null ? options2.inputHasAlpha : true;
      options2.deflateFactory = options2.deflateFactory || zlib2.createDeflate;
      options2.bitDepth = options2.bitDepth || 8;
      options2.colorType = typeof options2.colorType === "number" ? options2.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options2.inputColorType = typeof options2.inputColorType === "number" ? options2.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options2.colorType) === -1) {
        throw new Error("option color type:" + options2.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options2.inputColorType) === -1) {
        throw new Error("option input color type:" + options2.inputColorType + " is not supported at present");
      }
      if (options2.bitDepth !== 8 && options2.bitDepth !== 16) {
        throw new Error("option bit depth:" + options2.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var constants = require_constants2();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream2.call(this);
      let options2 = opt || {};
      this._packer = new Packer(options2);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream2);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports2, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib2 = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error3;
      this.on("error", function(err) {
        error3 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error3;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports2 = inflateSync;
    exports2.Inflate = Inflate;
    exports2.createInflate = createInflate;
    exports2.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports2, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read2 = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read2.length || read2.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read2.length);
          read2.func.call(this, buf.slice(0, read2.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports2) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports2.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options2) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let err;
      function handleError(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options2, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib2.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants2();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let options2 = opt || {};
      let packer = new Packer(options2);
      let chunks = [];
      chunks.push(Buffer.from(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      let compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports2) {
    "use strict";
    var parse = require_parser_sync();
    var pack = require_packer_sync();
    exports2.read = function(buffer, options2) {
      return parse(buffer, options2 || {});
    };
    exports2.write = function(png, options2) {
      return pack(png, options2);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports2.PNG = function(options2) {
      Stream2.call(this);
      options2 = options2 || {};
      this.width = options2.width | 0;
      this.height = options2.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options2.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options2);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options2);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream2);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src2, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src2.width || srcY > src2.height || srcX + width > src2.width || srcY + height > src2.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src2.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src2.width + srcX << 2, (srcY + y) * src2.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src2) {
      if (src2.gamma) {
        for (let y = 0; y < src2.height; y++) {
          for (let x = 0; x < src2.width; x++) {
            let idx = src2.width * y + x << 2;
            for (let i = 0; i < 3; i++) {
              let sample = src2.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src2.gamma);
              src2.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src2.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/playwright/lib/utils/registry.js
var require_registry = __commonJS({
  "node_modules/playwright/lib/utils/registry.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Registry = exports2.isBrowserDirectory = exports2.registryDirectory = exports2.hostPlatform = exports2.allBrowserNames = void 0;
    var child_process_1 = require("child_process");
    var os = __importStar(require("os"));
    var path_1 = __importDefault(require("path"));
    var util = __importStar(require("util"));
    var ubuntuVersion_1 = require_ubuntuVersion();
    var utils_1 = require_utils();
    exports2.allBrowserNames = ["chromium", "webkit", "firefox", "ffmpeg", "webkit-technology-preview", "firefox-stable"];
    var PACKAGE_PATH = path_1.default.join(__dirname, "..", "..");
    var EXECUTABLE_PATHS = {
      "chromium": {
        "ubuntu18.04": ["chrome-linux", "chrome"],
        "ubuntu20.04": ["chrome-linux", "chrome"],
        "mac10.13": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac10.14": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac10.15": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac11": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "mac11-arm64": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "win32": ["chrome-win", "chrome.exe"],
        "win64": ["chrome-win", "chrome.exe"]
      },
      "firefox": {
        "ubuntu18.04": ["firefox", "firefox"],
        "ubuntu20.04": ["firefox", "firefox"],
        "mac10.13": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac10.14": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac10.15": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac11": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac11-arm64": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "win32": ["firefox", "firefox.exe"],
        "win64": ["firefox", "firefox.exe"]
      },
      "firefox-stable": {
        "ubuntu18.04": ["firefox", "firefox"],
        "ubuntu20.04": ["firefox", "firefox"],
        "mac10.13": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac10.14": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac10.15": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac11": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "mac11-arm64": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "win32": ["firefox", "firefox.exe"],
        "win64": ["firefox", "firefox.exe"]
      },
      "webkit": {
        "ubuntu18.04": ["pw_run.sh"],
        "ubuntu20.04": ["pw_run.sh"],
        "mac10.13": void 0,
        "mac10.14": ["pw_run.sh"],
        "mac10.15": ["pw_run.sh"],
        "mac11": ["pw_run.sh"],
        "mac11-arm64": ["pw_run.sh"],
        "win32": ["Playwright.exe"],
        "win64": ["Playwright.exe"]
      },
      "webkit-technology-preview": {
        "ubuntu18.04": ["pw_run.sh"],
        "ubuntu20.04": ["pw_run.sh"],
        "mac10.13": void 0,
        "mac10.14": ["pw_run.sh"],
        "mac10.15": ["pw_run.sh"],
        "mac11": ["pw_run.sh"],
        "mac11-arm64": ["pw_run.sh"],
        "win32": ["Playwright.exe"],
        "win64": ["Playwright.exe"]
      },
      "ffmpeg": {
        "ubuntu18.04": ["ffmpeg-linux"],
        "ubuntu20.04": ["ffmpeg-linux"],
        "mac10.13": ["ffmpeg-mac"],
        "mac10.14": ["ffmpeg-mac"],
        "mac10.15": ["ffmpeg-mac"],
        "mac11": ["ffmpeg-mac"],
        "mac11-arm64": ["ffmpeg-mac"],
        "win32": ["ffmpeg-win32.exe"],
        "win64": ["ffmpeg-win64.exe"]
      }
    };
    var DOWNLOAD_URLS = {
      "chromium": {
        "ubuntu18.04": "%s/builds/chromium/%s/chromium-linux.zip",
        "ubuntu20.04": "%s/builds/chromium/%s/chromium-linux.zip",
        "mac10.13": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac10.14": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac10.15": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac11": "%s/builds/chromium/%s/chromium-mac.zip",
        "mac11-arm64": "%s/builds/chromium/%s/chromium-mac-arm64.zip",
        "win32": "%s/builds/chromium/%s/chromium-win32.zip",
        "win64": "%s/builds/chromium/%s/chromium-win64.zip"
      },
      "firefox": {
        "ubuntu18.04": "%s/builds/firefox/%s/firefox-ubuntu-18.04.zip",
        "ubuntu20.04": "%s/builds/firefox/%s/firefox-ubuntu-20.04.zip",
        "mac10.13": "%s/builds/firefox/%s/firefox-mac-10.14.zip",
        "mac10.14": "%s/builds/firefox/%s/firefox-mac-10.14.zip",
        "mac10.15": "%s/builds/firefox/%s/firefox-mac-10.14.zip",
        "mac11": "%s/builds/firefox/%s/firefox-mac-10.14.zip",
        "mac11-arm64": "%s/builds/firefox/%s/firefox-mac-11.0-arm64.zip",
        "win32": "%s/builds/firefox/%s/firefox-win32.zip",
        "win64": "%s/builds/firefox/%s/firefox-win64.zip"
      },
      "firefox-stable": {
        "ubuntu18.04": "%s/builds/firefox-stable/%s/firefox-stable-ubuntu-18.04.zip",
        "ubuntu20.04": "%s/builds/firefox-stable/%s/firefox-stable-ubuntu-20.04.zip",
        "mac10.13": "%s/builds/firefox-stable/%s/firefox-stable-mac-10.14.zip",
        "mac10.14": "%s/builds/firefox-stable/%s/firefox-stable-mac-10.14.zip",
        "mac10.15": "%s/builds/firefox-stable/%s/firefox-stable-mac-10.14.zip",
        "mac11": "%s/builds/firefox-stable/%s/firefox-stable-mac-10.14.zip",
        "mac11-arm64": "%s/builds/firefox-stable/%s/firefox-stable-mac-11.0-arm64.zip",
        "win32": "%s/builds/firefox-stable/%s/firefox-stable-win32.zip",
        "win64": "%s/builds/firefox-stable/%s/firefox-stable-win64.zip"
      },
      "webkit": {
        "ubuntu18.04": "%s/builds/webkit/%s/webkit-ubuntu-18.04.zip",
        "ubuntu20.04": "%s/builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "mac10.13": void 0,
        "mac10.14": "%s/builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip",
        "mac10.15": "%s/builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11": "%s/builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11-arm64": "%s/builds/webkit/%s/webkit-mac-11.0-arm64.zip",
        "win32": "%s/builds/webkit/%s/webkit-win64.zip",
        "win64": "%s/builds/webkit/%s/webkit-win64.zip"
      },
      "webkit-technology-preview": {
        "ubuntu18.04": "%s/builds/webkit/%s/webkit-ubuntu-18.04.zip",
        "ubuntu20.04": "%s/builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "mac10.13": void 0,
        "mac10.14": void 0,
        "mac10.15": "%s/builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11": "%s/builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11-arm64": "%s/builds/webkit/%s/webkit-mac-11.0-arm64.zip",
        "win32": "%s/builds/webkit/%s/webkit-win64.zip",
        "win64": "%s/builds/webkit/%s/webkit-win64.zip"
      },
      "ffmpeg": {
        "ubuntu18.04": "%s/builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu20.04": "%s/builds/ffmpeg/%s/ffmpeg-linux.zip",
        "mac10.13": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.14": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.15": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11-arm64": "%s/builds/ffmpeg/%s/ffmpeg-mac.zip",
        "win32": "%s/builds/ffmpeg/%s/ffmpeg-win32.zip",
        "win64": "%s/builds/ffmpeg/%s/ffmpeg-win64.zip"
      }
    };
    exports2.hostPlatform = (() => {
      const platform = os.platform();
      if (platform === "darwin") {
        const [major, minor] = child_process_1.execSync("sw_vers -productVersion", {
          stdio: ["ignore", "pipe", "ignore"]
        }).toString("utf8").trim().split(".").map((x) => parseInt(x, 10));
        let arm64 = false;
        if (major >= 11) {
          arm64 = child_process_1.execSync("/usr/sbin/sysctl -in hw.optional.arm64", {
            stdio: ["ignore", "pipe", "ignore"]
          }).toString().trim() === "1";
        }
        const macVersion = major === 10 ? `${major}.${minor}` : `${major}`;
        const archSuffix = arm64 ? "-arm64" : "";
        return `mac${macVersion}${archSuffix}`;
      }
      if (platform === "linux") {
        const ubuntuVersion = ubuntuVersion_1.getUbuntuVersionSync();
        if (parseInt(ubuntuVersion, 10) <= 19)
          return "ubuntu18.04";
        return "ubuntu20.04";
      }
      if (platform === "win32")
        return os.arch() === "x64" ? "win64" : "win32";
      return platform;
    })();
    exports2.registryDirectory = (() => {
      let result;
      const envDefined = utils_1.getFromENV("PLAYWRIGHT_BROWSERS_PATH");
      if (envDefined === "0") {
        result = path_1.default.join(__dirname, "..", "..", ".local-browsers");
      } else if (envDefined) {
        result = envDefined;
      } else {
        let cacheDirectory;
        if (process.platform === "linux")
          cacheDirectory = process.env.XDG_CACHE_HOME || path_1.default.join(os.homedir(), ".cache");
        else if (process.platform === "darwin")
          cacheDirectory = path_1.default.join(os.homedir(), "Library", "Caches");
        else if (process.platform === "win32")
          cacheDirectory = process.env.LOCALAPPDATA || path_1.default.join(os.homedir(), "AppData", "Local");
        else
          throw new Error("Unsupported platform: " + process.platform);
        result = path_1.default.join(cacheDirectory, "ms-playwright");
      }
      if (!path_1.default.isAbsolute(result)) {
        result = path_1.default.resolve(utils_1.getFromENV("INIT_CWD") || process.cwd(), result);
      }
      return result;
    })();
    function isBrowserDirectory(browserDirectory) {
      const baseName = path_1.default.basename(browserDirectory);
      for (const browserName of exports2.allBrowserNames) {
        if (baseName.startsWith(browserName + "-"))
          return true;
      }
      return false;
    }
    exports2.isBrowserDirectory = isBrowserDirectory;
    var currentPackageRegistry = void 0;
    var Registry = class {
      constructor(packagePath) {
        const browsersJSON = require(path_1.default.join(packagePath, "browsers.json"));
        this._descriptors = browsersJSON["browsers"].map((obj) => {
          const name = obj.name;
          const revisionOverride = (obj.revisionOverrides || {})[exports2.hostPlatform];
          const revision = revisionOverride || obj.revision;
          const browserDirectoryPrefix = revisionOverride ? `${name}_${exports2.hostPlatform}_special` : `${name}`;
          return {
            name,
            revision,
            installByDefault: !!obj.installByDefault,
            browserDirectory: browserDirectoryPrefix.replace(/-/g, "_") + "-" + revision
          };
        });
      }
      static currentPackageRegistry() {
        if (!currentPackageRegistry)
          currentPackageRegistry = new Registry(PACKAGE_PATH);
        return currentPackageRegistry;
      }
      browserDirectory(browserName) {
        const browser = this._descriptors.find((browser2) => browser2.name === browserName);
        utils_1.assert(browser, `ERROR: Playwright does not support ${browserName}`);
        return path_1.default.join(exports2.registryDirectory, browser.browserDirectory);
      }
      revision(browserName) {
        const browser = this._descriptors.find((browser2) => browser2.name === browserName);
        utils_1.assert(browser, `ERROR: Playwright does not support ${browserName}`);
        return parseInt(browser.revision, 10);
      }
      linuxLddDirectories(browserName) {
        const browserDirectory = this.browserDirectory(browserName);
        switch (browserName) {
          case "chromium":
            return [path_1.default.join(browserDirectory, "chrome-linux")];
          case "webkit":
          case "webkit-technology-preview":
            return [
              path_1.default.join(browserDirectory, "minibrowser-gtk"),
              path_1.default.join(browserDirectory, "minibrowser-gtk", "bin"),
              path_1.default.join(browserDirectory, "minibrowser-gtk", "lib"),
              path_1.default.join(browserDirectory, "minibrowser-wpe"),
              path_1.default.join(browserDirectory, "minibrowser-wpe", "bin"),
              path_1.default.join(browserDirectory, "minibrowser-wpe", "lib")
            ];
          case "firefox":
          case "firefox-stable":
            return [path_1.default.join(browserDirectory, "firefox")];
          default:
            return [];
        }
      }
      windowsExeAndDllDirectories(browserName) {
        const browserDirectory = this.browserDirectory(browserName);
        if (browserName === "chromium")
          return [path_1.default.join(browserDirectory, "chrome-win")];
        if (browserName === "firefox")
          return [path_1.default.join(browserDirectory, "firefox")];
        if (browserName === "webkit")
          return [browserDirectory];
        return [];
      }
      executablePath(browserName) {
        const browserDirectory = this.browserDirectory(browserName);
        const tokens = EXECUTABLE_PATHS[browserName][exports2.hostPlatform];
        return tokens ? path_1.default.join(browserDirectory, ...tokens) : void 0;
      }
      downloadURL(browserName) {
        const browser = this._descriptors.find((browser2) => browser2.name === browserName);
        utils_1.assert(browser, `ERROR: Playwright does not support ${browserName}`);
        const envDownloadHost = {
          "chromium": "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST",
          "firefox": "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST",
          "firefox-stable": "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST",
          "webkit": "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST",
          "webkit-technology-preview": "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST",
          "ffmpeg": "PLAYWRIGHT_FFMPEG_DOWNLOAD_HOST"
        };
        const downloadHost = utils_1.getFromENV(envDownloadHost[browserName]) || utils_1.getFromENV("PLAYWRIGHT_DOWNLOAD_HOST") || "https://playwright.azureedge.net";
        const urlTemplate = DOWNLOAD_URLS[browserName][exports2.hostPlatform];
        utils_1.assert(urlTemplate, `ERROR: Playwright does not support ${browserName} on ${exports2.hostPlatform}`);
        return util.format(urlTemplate, downloadHost, browser.revision);
      }
      isSupportedBrowser(browserName) {
        return this._descriptors.some((browser) => browser.name === browserName);
      }
      installByDefault() {
        return this._descriptors.filter((browser) => browser.installByDefault).map((browser) => browser.name);
      }
    };
    exports2.Registry = Registry;
  }
});

// node_modules/playwright/lib/server/webkit/wkAccessibility.js
var require_wkAccessibility = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getAccessibilityTree = void 0;
    async function getAccessibilityTree(session, needle) {
      const objectId = needle ? needle._objectId : void 0;
      const {axNode} = await session.send("Page.accessibilitySnapshot", {objectId});
      const tree = new WKAXNode(axNode);
      return {
        tree,
        needle: needle ? tree._findNeedle() : null
      };
    }
    exports2.getAccessibilityTree = getAccessibilityTree;
    var WKRoleToARIARole = new Map(Object.entries({
      "TextField": "textbox"
    }));
    var WKUnhelpfulRoleDescriptions = new Map(Object.entries({
      "WebArea": "HTML content",
      "Summary": "summary",
      "DescriptionList": "description list",
      "ImageMap": "image map",
      "ListMarker": "list marker",
      "Video": "video playback",
      "Mark": "highlighted",
      "contentinfo": "content information",
      "Details": "details",
      "DescriptionListDetail": "description",
      "DescriptionListTerm": "term",
      "alertdialog": "web alert dialog",
      "dialog": "web dialog",
      "status": "application status",
      "tabpanel": "tab panel",
      "application": "web application"
    }));
    var WKAXNode = class {
      constructor(payload) {
        this._payload = payload;
        this._children = [];
        for (const payload2 of this._payload.children || [])
          this._children.push(new WKAXNode(payload2));
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.found)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isControl() {
        switch (this._payload.role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "TextField":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      _isTextControl() {
        switch (this._payload.role) {
          case "combobox":
          case "searchfield":
          case "textbox":
          case "TextField":
            return true;
        }
        return false;
      }
      _name() {
        if (this._payload.role === "text")
          return this._payload.value || "";
        return this._payload.name || "";
      }
      isInteresting(insideControl) {
        const {role, focusable} = this._payload;
        const name = this._name();
        if (role === "ScrollArea")
          return false;
        if (role === "WebArea")
          return true;
        if (focusable || role === "MenuListOption")
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!name;
      }
      _hasRendundantTextChild() {
        if (this._children.length !== 1)
          return false;
        const child = this._children[0];
        return child._payload.role === "text" && this._payload.name === child._payload.value;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isTextControl())
          return true;
        if (this._hasRendundantTextChild())
          return true;
        return false;
      }
      serialize() {
        const node = {
          role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
          name: this._name()
        };
        if ("description" in this._payload && this._payload.description !== node.name)
          node.description = this._payload.description;
        if ("roledescription" in this._payload) {
          const roledescription = this._payload.roledescription;
          if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
            node.roledescription = roledescription;
        }
        if ("value" in this._payload && this._payload.role !== "text") {
          if (typeof this._payload.value === "string")
            node.valueString = this._payload.value;
          else if (typeof this._payload.value === "number")
            node.valueNumber = this._payload.value;
        }
        if ("checked" in this._payload)
          node.checked = this._payload.checked === "true" ? "checked" : this._payload.checked === "false" ? "unchecked" : "mixed";
        if ("pressed" in this._payload)
          node.pressed = this._payload.pressed === "true" ? "pressed" : this._payload.pressed === "false" ? "released" : "mixed";
        const userStringProperties = [
          "keyshortcuts",
          "valuetext"
        ];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = [
          "disabled",
          "expanded",
          "focused",
          "modal",
          "multiline",
          "multiselectable",
          "readonly",
          "required",
          "selected"
        ];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._payload.role === "WebArea" || this._payload.role === "ScrollArea"))
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = [
          "level",
          "valuemax",
          "valuemin"
        ];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = [
          "autocomplete",
          "haspopup",
          "invalid"
        ];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const orientationIsApplicable = new Set([
          "ScrollArea",
          "scrollbar",
          "listbox",
          "combobox",
          "menu",
          "tree",
          "separator",
          "slider",
          "tablist",
          "toolbar"
        ]);
        if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
          node.orientation = this._payload.orientation;
        return node;
      }
    };
  }
});

// node_modules/playwright/lib/server/webkit/wkExecutionContext.js
var require_wkExecutionContext = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkExecutionContext.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WKExecutionContext = void 0;
    var wkConnection_1 = require_wkConnection();
    var js = __importStar(require_javascript());
    var utilityScriptSerializers_1 = require_utilityScriptSerializers();
    var WKExecutionContext = class {
      constructor(session, contextId) {
        this._contextDestroyedCallback = () => {
        };
        this._session = session;
        this._contextId = contextId;
        this._executionContextDestroyedPromise = new Promise((resolve2, reject) => {
          this._contextDestroyedCallback = resolve2;
        });
      }
      _dispose() {
        this._contextDestroyedCallback();
      }
      async rawEvaluateJSON(expression) {
        try {
          const response = await this._session.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId,
            returnByValue: true
          });
          if (response.wasThrown)
            throw new Error("Evaluation failed: " + response.result.description);
          return response.result.value;
        } catch (error3) {
          throw rewriteError(error3);
        }
      }
      async rawEvaluateHandle(expression) {
        try {
          const response = await this._session.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId,
            returnByValue: false
          });
          if (response.wasThrown)
            throw new Error("Evaluation failed: " + response.result.description);
          return response.result.objectId;
        } catch (error3) {
          throw rewriteError(error3);
        }
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          objectId: args.find((a) => a instanceof js.JSHandle)._objectId,
          arguments: args.map((a) => a instanceof js.JSHandle ? {objectId: a._objectId} : {value: a}),
          returnByValue: true,
          emulateUserGesture: true
        }).catch(() => {
        });
      }
      async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        try {
          let response = await this._session.send("Runtime.callFunctionOn", {
            functionDeclaration: expression,
            objectId: utilityScript._objectId,
            arguments: [
              {objectId: utilityScript._objectId},
              ...values.map((value) => ({value})),
              ...objectIds.map((objectId) => ({objectId}))
            ],
            returnByValue: false,
            emulateUserGesture: true
          });
          if (response.result.objectId && response.result.className === "Promise") {
            response = await Promise.race([
              this._executionContextDestroyedPromise.then(() => contextDestroyedResult),
              this._session.send("Runtime.awaitPromise", {
                promiseObjectId: response.result.objectId,
                returnByValue: false
              })
            ]);
          }
          if (response.wasThrown)
            throw new Error("Evaluation failed: " + response.result.description);
          if (!returnByValue)
            return utilityScript._context.createHandle(response.result);
          if (response.result.objectId) {
            if (response.result.type === "undefined")
              return void 0;
            return await this._returnObjectByValue(utilityScript, response.result.objectId);
          }
          return utilityScriptSerializers_1.parseEvaluationResultValue(response.result.value);
        } catch (error3) {
          throw rewriteError(error3);
        }
      }
      async _returnObjectByValue(utilityScript, objectId) {
        try {
          const serializeResponse = await this._session.send("Runtime.callFunctionOn", {
            functionDeclaration: "object => object",
            objectId: utilityScript._objectId,
            arguments: [{objectId}],
            returnByValue: true
          });
          if (serializeResponse.wasThrown)
            throw new Error("Evaluation failed: " + serializeResponse.result.description);
          return utilityScriptSerializers_1.parseEvaluationResultValue(serializeResponse.result.value);
        } catch (error3) {
          throw rewriteError(error3);
        }
      }
      async getProperties(context, objectId) {
        const response = await this._session.send("Runtime.getProperties", {
          objectId,
          ownProperties: true
        });
        const result = new Map();
        for (const property of response.properties) {
          if (!property.enumerable || !property.value)
            continue;
          result.set(property.name, context.createHandle(property.value));
        }
        return result;
      }
      createHandle(context, remoteObject) {
        const isPromise = remoteObject.className === "Promise";
        return new js.JSHandle(context, isPromise ? "promise" : remoteObject.subtype || remoteObject.type, remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      async releaseHandle(objectId) {
        await this._session.send("Runtime.releaseObject", {objectId});
      }
    };
    exports2.WKExecutionContext = WKExecutionContext;
    var contextDestroyedResult = {
      wasThrown: true,
      result: {
        description: "Protocol error: Execution context was destroyed, most likely because of a navigation."
      }
    };
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const isUnserializable = remoteObject.type === "number" && ["NaN", "-Infinity", "Infinity", "-0"].includes(remoteObject.description);
      return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;
    }
    function rewriteError(error3) {
      if (wkConnection_1.isSwappedOutError(error3) || error3.message.includes("Missing injected script for given"))
        return new Error("Execution context was destroyed, most likely because of a navigation.");
      return error3;
    }
  }
});

// node_modules/playwright/lib/server/webkit/wkInput.js
var require_wkInput = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkInput.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = __importStar(require_input());
    var macEditingCommands_1 = require_macEditingCommands();
    var utils_1 = require_utils();
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Shift"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Alt"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(session) {
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        const parts = [];
        for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
          if (modifiers.has(modifier))
            parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join("+");
        let commands = macEditingCommands_1.macEditingCommands[shortcut];
        if (utils_1.isString(commands))
          commands = [commands];
        await this._pageProxySession.send("Input.dispatchKeyEvent", {
          type: "keyDown",
          modifiers: toModifiersMask(modifiers),
          windowsVirtualKeyCode: keyCode,
          code,
          key,
          text,
          unmodifiedText: text,
          autoRepeat,
          macCommands: commands,
          isKeypad: location2 === input.keypadLocation
        });
      }
      async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        await this._pageProxySession.send("Input.dispatchKeyEvent", {
          type: "keyUp",
          modifiers: toModifiersMask(modifiers),
          key,
          windowsVirtualKeyCode: keyCode,
          code,
          isKeypad: location2 === input.keypadLocation
        });
      }
      async sendText(text) {
        await this._session.send("Page.insertText", {text});
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(session) {
        this._pageProxySession = session;
      }
      async move(x, y, button, buttons, modifiers) {
        await this._pageProxySession.send("Input.dispatchMouseEvent", {
          type: "move",
          button,
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
      async down(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send("Input.dispatchMouseEvent", {
          type: "down",
          button,
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
      async up(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send("Input.dispatchMouseEvent", {
          type: "up",
          button,
          x,
          y,
          modifiers: toModifiersMask(modifiers),
          clickCount
        });
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(session) {
        this._pageProxySession = session;
      }
      async tap(x, y, modifiers) {
        await this._pageProxySession.send("Input.dispatchTapEvent", {
          x,
          y,
          modifiers: toModifiersMask(modifiers)
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright/lib/server/webkit/wkInterceptableRequest.js
var require_wkInterceptableRequest = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkInterceptableRequest.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WKInterceptableRequest = void 0;
    var network = __importStar(require_network());
    var utils_1 = require_utils();
    var errorReasons = {
      "aborted": "Cancellation",
      "accessdenied": "AccessControl",
      "addressunreachable": "General",
      "blockedbyclient": "Cancellation",
      "blockedbyresponse": "General",
      "connectionaborted": "General",
      "connectionclosed": "General",
      "connectionfailed": "General",
      "connectionrefused": "General",
      "connectionreset": "General",
      "internetdisconnected": "General",
      "namenotresolved": "General",
      "timedout": "Timeout",
      "failed": "General"
    };
    var WKInterceptableRequest = class {
      constructor(session, allowInterception, frame, event, redirectedFrom, documentId) {
        this._interceptedCallback = () => {
        };
        this._session = session;
        this._requestId = event.requestId;
        this._allowInterception = allowInterception;
        const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.resourceType() : "other";
        let postDataBuffer = null;
        this._timestamp = event.timestamp;
        this._wallTime = event.walltime * 1e3;
        if (event.request.postData)
          postDataBuffer = Buffer.from(event.request.postData, "base64");
        this.request = new network.Request(allowInterception ? this : null, frame, redirectedFrom, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, utils_1.headersObjectToArray(event.request.headers));
        this._interceptedPromise = new Promise((f) => this._interceptedCallback = f);
      }
      async abort(errorCode) {
        const errorType = errorReasons[errorCode];
        utils_1.assert(errorType, "Unknown error code: " + errorCode);
        await this._interceptedPromise;
        await this._session.sendMayFail("Network.interceptRequestWithError", {requestId: this._requestId, errorType});
      }
      async fulfill(response) {
        if (300 <= response.status && response.status < 400)
          throw new Error("Cannot fulfill with redirect status: " + response.status);
        await this._interceptedPromise;
        let mimeType = response.isBase64 ? "application/octet-stream" : "text/plain";
        const headers = utils_1.headersArrayToObject(response.headers, false);
        const contentType = headers["content-type"];
        if (contentType)
          mimeType = contentType.split(";")[0].trim();
        await this._session.sendMayFail("Network.interceptRequestWithResponse", {
          requestId: this._requestId,
          status: response.status,
          statusText: network.STATUS_TEXTS[String(response.status)],
          mimeType,
          headers,
          base64Encoded: response.isBase64,
          content: response.body
        });
      }
      async continue(overrides) {
        await this._interceptedPromise;
        await this._session.sendMayFail("Network.interceptWithRequest", {
          requestId: this._requestId,
          url: overrides.url,
          method: overrides.method,
          headers: overrides.headers ? utils_1.headersArrayToObject(overrides.headers, false) : void 0,
          postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
        });
      }
      createResponse(responsePayload) {
        const getResponseBody = async () => {
          const response = await this._session.send("Network.getResponseBody", {requestId: this._requestId});
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        };
        const timingPayload = responsePayload.timing;
        const timing = {
          startTime: this._wallTime,
          domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
          domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
          connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
          secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
          connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
          requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
          responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
        };
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, utils_1.headersObjectToArray(responsePayload.headers), timing, getResponseBody);
      }
    };
    exports2.WKInterceptableRequest = WKInterceptableRequest;
    function wkMillisToRoundishMillis(value) {
      if (value === -1e3)
        return -1;
      if (value <= 0) {
        return -1;
      }
      return (value * 1e3 | 0) / 1e3;
    }
  }
});

// node_modules/playwright/lib/server/webkit/wkProvisionalPage.js
var require_wkProvisionalPage = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkProvisionalPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WKProvisionalPage = void 0;
    var helper_1 = require_helper();
    var utils_1 = require_utils();
    var WKProvisionalPage = class {
      constructor(session, page) {
        this._sessionListeners = [];
        this._mainFrameId = null;
        this._session = session;
        this._wkPage = page;
        const overrideFrameId = (handler2) => {
          return (payload) => {
            if (payload.frameId)
              payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
            handler2(payload);
          };
        };
        const wkPage = this._wkPage;
        this._sessionListeners = [
          helper_1.helper.addEventListener(session, "Network.requestWillBeSent", overrideFrameId((e) => wkPage._onRequestWillBeSent(session, e))),
          helper_1.helper.addEventListener(session, "Network.requestIntercepted", overrideFrameId((e) => wkPage._onRequestIntercepted(e))),
          helper_1.helper.addEventListener(session, "Network.responseReceived", overrideFrameId((e) => wkPage._onResponseReceived(e))),
          helper_1.helper.addEventListener(session, "Network.loadingFinished", overrideFrameId((e) => wkPage._onLoadingFinished(e))),
          helper_1.helper.addEventListener(session, "Network.loadingFailed", overrideFrameId((e) => wkPage._onLoadingFailed(e)))
        ];
        this.initializationPromise = this._wkPage._initializeSession(session, true, ({frameTree}) => this._handleFrameTree(frameTree));
      }
      dispose() {
        helper_1.helper.removeEventListeners(this._sessionListeners);
      }
      commit() {
        utils_1.assert(this._mainFrameId);
        this._wkPage._onFrameAttached(this._mainFrameId, null);
      }
      _handleFrameTree(frameTree) {
        utils_1.assert(!frameTree.frame.parentId);
        this._mainFrameId = frameTree.frame.id;
      }
    };
    exports2.WKProvisionalPage = WKProvisionalPage;
  }
});

// node_modules/playwright/lib/server/webkit/wkWorkers.js
var require_wkWorkers = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkWorkers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WKWorkers = void 0;
    var helper_1 = require_helper();
    var page_1 = require_page();
    var wkConnection_1 = require_wkConnection();
    var wkExecutionContext_1 = require_wkExecutionContext();
    var WKWorkers = class {
      constructor(page) {
        this._sessionListeners = [];
        this._workerSessions = new Map();
        this._page = page;
      }
      setSession(session) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        this.clear();
        this._sessionListeners = [
          helper_1.helper.addEventListener(session, "Worker.workerCreated", (event) => {
            const worker = new page_1.Worker(this._page, event.url);
            const workerSession = new wkConnection_1.WKSession(session.connection, event.workerId, "Most likely the worker has been closed.", (message) => {
              session.send("Worker.sendMessageToWorker", {
                workerId: event.workerId,
                message: JSON.stringify(message)
              }).catch((e) => {
                workerSession.dispatchMessage({id: message.id, error: {message: e.message}});
              });
            });
            this._workerSessions.set(event.workerId, workerSession);
            worker._createExecutionContext(new wkExecutionContext_1.WKExecutionContext(workerSession, void 0));
            this._page._addWorker(event.workerId, worker);
            workerSession.on("Console.messageAdded", (event2) => this._onConsoleMessage(worker, event2));
            Promise.all([
              workerSession.send("Runtime.enable"),
              workerSession.send("Console.enable"),
              session.send("Worker.initialized", {workerId: event.workerId})
            ]).catch((e) => {
              this._page._removeWorker(event.workerId);
            });
          }),
          helper_1.helper.addEventListener(session, "Worker.dispatchMessageFromWorker", (event) => {
            const workerSession = this._workerSessions.get(event.workerId);
            if (!workerSession)
              return;
            workerSession.dispatchMessage(JSON.parse(event.message));
          }),
          helper_1.helper.addEventListener(session, "Worker.workerTerminated", (event) => {
            const workerSession = this._workerSessions.get(event.workerId);
            if (!workerSession)
              return;
            workerSession.dispose(false);
            this._workerSessions.delete(event.workerId);
            this._page._removeWorker(event.workerId);
          })
        ];
      }
      clear() {
        this._page._clearWorkers();
        this._workerSessions.clear();
      }
      async initializeSession(session) {
        await session.send("Worker.enable");
      }
      async _onConsoleMessage(worker, event) {
        const {type, level, text, parameters, url, line: lineNumber, column: columnNumber} = event.message;
        let derivedType = type || "";
        if (type === "log")
          derivedType = level;
        else if (type === "timing")
          derivedType = "timeEnd";
        const handles = (parameters || []).map((p) => {
          return worker._existingExecutionContext.createHandle(p);
        });
        const location2 = {
          url: url || "",
          lineNumber: (lineNumber || 1) - 1,
          columnNumber: (columnNumber || 1) - 1
        };
        this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
      }
    };
    exports2.WKWorkers = WKWorkers;
  }
});

// node_modules/playwright/lib/server/webkit/wkPage.js
var require_wkPage = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkPage.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WKPage = void 0;
    var jpeg = __importStar(require_jpeg_js());
    var path_1 = __importDefault(require("path"));
    var png = __importStar(require_png());
    var stackTrace_1 = require_stackTrace();
    var registry_1 = require_registry();
    var utils_1 = require_utils();
    var dialog = __importStar(require_dialog());
    var dom = __importStar(require_dom());
    var helper_1 = require_helper();
    var network = __importStar(require_network());
    var page_1 = require_page();
    var wkAccessibility_1 = require_wkAccessibility();
    var wkConnection_1 = require_wkConnection();
    var wkExecutionContext_1 = require_wkExecutionContext();
    var wkInput_1 = require_wkInput();
    var wkInterceptableRequest_1 = require_wkInterceptableRequest();
    var wkProvisionalPage_1 = require_wkProvisionalPage();
    var wkWorkers_1 = require_wkWorkers();
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var BINDING_CALL_MESSAGE = "__playwright_binding_call__";
    var WKPage = class {
      constructor(browserContext, pageProxySession, opener) {
        this._provisionalPage = null;
        this._pagePromiseCallback = () => {
        };
        this._requestIdToRequest = new Map();
        this._sessionListeners = [];
        this._initializedPage = null;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._lastConsoleMessage = null;
        this._recordingVideoFile = null;
        this._pageProxySession = pageProxySession;
        this._opener = opener;
        this.rawKeyboard = new wkInput_1.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new wkInput_1.RawMouseImpl(pageProxySession);
        this.rawTouchscreen = new wkInput_1.RawTouchscreenImpl(pageProxySession);
        this._contextIdToContext = new Map();
        this._page = new page_1.Page(this, browserContext);
        this._workers = new wkWorkers_1.WKWorkers(this._page);
        this._session = void 0;
        this._browserContext = browserContext;
        this._page.on(page_1.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
        this._eventListeners = [
          helper_1.helper.addEventListener(this._pageProxySession, "Target.targetCreated", this._onTargetCreated.bind(this)),
          helper_1.helper.addEventListener(this._pageProxySession, "Target.targetDestroyed", this._onTargetDestroyed.bind(this)),
          helper_1.helper.addEventListener(this._pageProxySession, "Target.dispatchMessageFromTarget", this._onDispatchMessageFromTarget.bind(this)),
          helper_1.helper.addEventListener(this._pageProxySession, "Target.didCommitProvisionalTarget", this._onDidCommitProvisionalTarget.bind(this))
        ];
        this._pagePromise = new Promise((f) => this._pagePromiseCallback = f);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
          const viewportSize = helper_1.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
          opener._nextWindowOpenPopupFeatures = void 0;
          if (viewportSize)
            this._page._state.emulatedSize = {viewport: viewportSize, screen: viewportSize};
        }
      }
      async _initializePageProxySession() {
        const promises = [
          this._pageProxySession.send("Dialog.enable"),
          this._pageProxySession.send("Emulation.setActiveAndFocused", {active: true})
        ];
        const contextOptions = this._browserContext._options;
        if (contextOptions.javaScriptEnabled === false)
          promises.push(this._pageProxySession.send("Emulation.setJavaScriptEnabled", {enabled: false}));
        promises.push(this._updateViewport());
        promises.push(this.updateHttpCredentials());
        if (this._browserContext._permissions.size) {
          for (const [key, value] of this._browserContext._permissions)
            promises.push(this._grantPermissions(key, value));
        }
        if (this._browserContext._options.recordVideo) {
          const outputFile = path_1.default.join(this._browserContext._options.recordVideo.dir, utils_1.createGuid() + ".webm");
          promises.push(this._browserContext._ensureVideosPath().then(() => {
            return this._startScreencast({
              ...this._browserContext._options.recordVideo.size,
              outputFile
            });
          }));
        }
        await Promise.all(promises);
      }
      _setSession(session) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
      }
      async _initializeSession(session, provisional, resourceTreeHandler) {
        await this._initializeSessionMayThrow(session, resourceTreeHandler).catch((e) => {
          if (provisional && session.isDisposed())
            return;
          if (this._session === session)
            throw e;
        });
      }
      async _initializeSessionMayThrow(session, resourceTreeHandler) {
        const [, frameTree] = await Promise.all([
          session.send("Page.enable"),
          session.send("Page.getResourceTree")
        ]);
        resourceTreeHandler(frameTree);
        const promises = [
          session.send("Runtime.enable"),
          session.send("Page.createUserWorld", {name: UTILITY_WORLD_NAME}).catch((_) => {
          }),
          session.send("Console.enable"),
          session.send("Network.enable"),
          this._workers.initializeSession(session)
        ];
        if (this._page._needsRequestInterception()) {
          promises.push(session.send("Network.setInterceptionEnabled", {enabled: true}));
          promises.push(session.send("Network.addInterception", {url: ".*", stage: "request", isRegex: true}));
        }
        const contextOptions = this._browserContext._options;
        if (contextOptions.userAgent)
          promises.push(session.send("Page.overrideUserAgent", {value: contextOptions.userAgent}));
        if (this._page._state.mediaType || this._page._state.colorScheme)
          promises.push(WKPage._setEmulateMedia(session, this._page._state.mediaType, this._page._state.colorScheme));
        const bootstrapScript = this._calculateBootstrapScript();
        promises.push(session.send("Page.setBootstrapScript", {source: bootstrapScript}));
        this._page.frames().map((frame) => frame.evaluateExpression(bootstrapScript, false, void 0, "main").catch((e) => {
        }));
        if (contextOptions.bypassCSP)
          promises.push(session.send("Page.setBypassCSP", {enabled: true}));
        if (this._page._state.emulatedSize) {
          promises.push(session.send("Page.setScreenSizeOverride", {
            width: this._page._state.emulatedSize.screen.width,
            height: this._page._state.emulatedSize.screen.height
          }));
        }
        promises.push(this.updateEmulateMedia());
        promises.push(session.send("Network.setExtraHTTPHeaders", {headers: utils_1.headersArrayToObject(this._calculateExtraHTTPHeaders(), false)}));
        if (contextOptions.offline)
          promises.push(session.send("Network.setEmulateOfflineState", {offline: true}));
        promises.push(session.send("Page.setTouchEmulationEnabled", {enabled: !!contextOptions.hasTouch}));
        if (contextOptions.timezoneId) {
          promises.push(session.send("Page.setTimeZone", {timeZone: contextOptions.timezoneId}).catch((e) => {
            throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
          }));
        }
        await Promise.all(promises);
      }
      _onDidCommitProvisionalTarget(event) {
        const {oldTargetId, newTargetId} = event;
        utils_1.assert(this._provisionalPage);
        utils_1.assert(this._provisionalPage._session.sessionId === newTargetId, "Unknown new target: " + newTargetId);
        utils_1.assert(this._session.sessionId === oldTargetId, "Unknown old target: " + oldTargetId);
        this._session.errorText = "Target was swapped out.";
        const newSession = this._provisionalPage._session;
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(newSession);
      }
      _onTargetDestroyed(event) {
        const {targetId, crashed} = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
          this._provisionalPage._session.dispose(false);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        } else if (this._session.sessionId === targetId) {
          this._session.dispose(false);
          helper_1.helper.removeEventListeners(this._sessionListeners);
          if (crashed) {
            this._session.markAsCrashed();
            this._page._didCrash();
          }
        }
      }
      didClose() {
        this._page._didClose();
      }
      dispose(disconnected) {
        this._pageProxySession.dispose(disconnected);
        helper_1.helper.removeEventListeners(this._sessionListeners);
        helper_1.helper.removeEventListeners(this._eventListeners);
        if (this._session)
          this._session.dispose(disconnected);
        if (this._provisionalPage) {
          this._provisionalPage._session.dispose(disconnected);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        }
        this._page._didDisconnect();
        this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
      }
      dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
      }
      handleProvisionalLoadFailed(event) {
        if (!this._initializedPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Initial load failed"));
          return;
        }
        if (!this._provisionalPage)
          return;
        let errorText = event.error;
        if (errorText.includes("cancelled"))
          errorText += "; maybe frame was detached?";
        this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
      }
      handleWindowOpen(event) {
        utils_1.debugAssert(!this._nextWindowOpenPopupFeatures);
        this._nextWindowOpenPopupFeatures = event.windowFeatures;
      }
      async pageOrError() {
        return this._pagePromise;
      }
      async _onTargetCreated(event) {
        const {targetInfo} = event;
        const session = new wkConnection_1.WKSession(this._pageProxySession.connection, targetInfo.targetId, `The ${targetInfo.type} has been closed.`, (message) => {
          this._pageProxySession.send("Target.sendMessageToTarget", {
            message: JSON.stringify(message),
            targetId: targetInfo.targetId
          }).catch((e) => {
            session.dispatchMessage({id: message.id, error: {message: e.message}});
          });
        });
        utils_1.assert(targetInfo.type === "page", "Only page targets are expected in WebKit, received: " + targetInfo.type);
        if (!targetInfo.isProvisional) {
          utils_1.assert(!this._initializedPage);
          let pageOrError;
          try {
            this._setSession(session);
            await Promise.all([
              this._initializePageProxySession(),
              this._initializeSession(session, false, ({frameTree}) => this._handleFrameTree(frameTree))
            ]);
            pageOrError = this._page;
          } catch (e) {
            pageOrError = e;
          }
          if (targetInfo.isPaused)
            this._pageProxySession.sendMayFail("Target.resume", {targetId: targetInfo.targetId});
          if (pageOrError instanceof page_1.Page && this._page.mainFrame().url() === "") {
            try {
              await this._firstNonInitialNavigationCommittedPromise;
            } catch (e) {
              pageOrError = e;
            }
          } else {
            this._firstNonInitialNavigationCommittedPromise.catch(() => {
            });
          }
          await this._page.initOpener(this._opener);
          this._initializedPage = pageOrError instanceof page_1.Page ? pageOrError : null;
          this._page.reportAsNew(pageOrError instanceof page_1.Page ? void 0 : pageOrError);
          this._pagePromiseCallback(pageOrError);
        } else {
          utils_1.assert(targetInfo.isProvisional);
          utils_1.assert(!this._provisionalPage);
          this._provisionalPage = new wkProvisionalPage_1.WKProvisionalPage(session, this);
          if (targetInfo.isPaused) {
            this._provisionalPage.initializationPromise.then(() => {
              this._pageProxySession.sendMayFail("Target.resume", {targetId: targetInfo.targetId});
            });
          }
        }
      }
      _onDispatchMessageFromTarget(event) {
        const {targetId, message} = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
          this._provisionalPage._session.dispatchMessage(JSON.parse(message));
        else if (this._session.sessionId === targetId)
          this._session.dispatchMessage(JSON.parse(message));
        else
          throw new Error("Unknown target: " + targetId);
      }
      _addSessionListeners() {
        this._sessionListeners = [
          helper_1.helper.addEventListener(this._session, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)),
          helper_1.helper.addEventListener(this._session, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
          helper_1.helper.addEventListener(this._session, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)),
          helper_1.helper.addEventListener(this._session, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId)),
          helper_1.helper.addEventListener(this._session, "Page.frameScheduledNavigation", (event) => this._onFrameScheduledNavigation(event.frameId)),
          helper_1.helper.addEventListener(this._session, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)),
          helper_1.helper.addEventListener(this._session, "Page.loadEventFired", (event) => this._onLifecycleEvent(event.frameId, "load")),
          helper_1.helper.addEventListener(this._session, "Page.domContentEventFired", (event) => this._onLifecycleEvent(event.frameId, "domcontentloaded")),
          helper_1.helper.addEventListener(this._session, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)),
          helper_1.helper.addEventListener(this._session, "Console.messageAdded", (event) => this._onConsoleMessage(event)),
          helper_1.helper.addEventListener(this._session, "Console.messageRepeatCountUpdated", (event) => this._onConsoleRepeatCountUpdated(event)),
          helper_1.helper.addEventListener(this._pageProxySession, "Dialog.javascriptDialogOpening", (event) => this._onDialog(event)),
          helper_1.helper.addEventListener(this._session, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)),
          helper_1.helper.addEventListener(this._session, "Network.requestWillBeSent", (e) => this._onRequestWillBeSent(this._session, e)),
          helper_1.helper.addEventListener(this._session, "Network.requestIntercepted", (e) => this._onRequestIntercepted(e)),
          helper_1.helper.addEventListener(this._session, "Network.responseReceived", (e) => this._onResponseReceived(e)),
          helper_1.helper.addEventListener(this._session, "Network.loadingFinished", (e) => this._onLoadingFinished(e)),
          helper_1.helper.addEventListener(this._session, "Network.loadingFailed", (e) => this._onLoadingFailed(e)),
          helper_1.helper.addEventListener(this._session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)),
          helper_1.helper.addEventListener(this._session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)),
          helper_1.helper.addEventListener(this._session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
          helper_1.helper.addEventListener(this._session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
          helper_1.helper.addEventListener(this._session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
          helper_1.helper.addEventListener(this._session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)),
          helper_1.helper.addEventListener(this._session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))
        ];
      }
      async _updateState(method, params) {
        await this._forAllSessions((session) => session.send(method, params).then());
      }
      async _forAllSessions(callback) {
        const sessions = [
          this._session
        ];
        if (this._provisionalPage)
          sessions.push(this._provisionalPage._session);
        await Promise.all(sessions.map((session) => callback(session).catch((e) => {
        })));
      }
      _onFrameScheduledNavigation(frameId) {
        this._page._frameManager.frameRequestedNavigation(frameId);
      }
      _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _onLifecycleEvent(frameId, event) {
        this._page._frameManager.frameLifecycleEvent(frameId, event);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "domcontentloaded");
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "load");
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        utils_1.assert(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
          this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
      }
      _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame) {
            context._delegate._dispose();
            this._contextIdToContext.delete(contextId);
            if (notifyFrame)
              frame._contextDestroyed(context);
          }
        }
      }
      _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
          return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
          return;
        const delegate = new wkExecutionContext_1.WKExecutionContext(this._session, contextPayload.id);
        let worldName = null;
        if (contextPayload.type === "normal")
          worldName = "main";
        else if (contextPayload.type === "user" && contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        if (worldName)
          frame._contextCreated(worldName, context);
        if (contextPayload.type === "normal" && frame === this._page.mainFrame())
          this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
      }
      async navigateFrame(frame, url, referrer) {
        if (this._pageProxySession.isDisposed())
          throw new Error("Target closed");
        const pageProxyId = this._pageProxySession.sessionId;
        const result = await this._pageProxySession.connection.browserSession.send("Playwright.navigate", {url, pageProxyId, frameId: frame._id, referrer});
        return {newDocumentId: result.loaderId};
      }
      _onConsoleMessage(event) {
        const {type, level, text, parameters, url, line: lineNumber, column: columnNumber, source} = event.message;
        if (level === "debug" && parameters && parameters[0].value === BINDING_CALL_MESSAGE) {
          const parsedObjectId = JSON.parse(parameters[1].objectId);
          const context = this._contextIdToContext.get(parsedObjectId.injectedScriptId);
          this.pageOrError().then((pageOrError) => {
            if (!(pageOrError instanceof Error))
              this._page._onBindingCalled(parameters[2].value, context);
          });
          return;
        }
        if (level === "error" && source === "javascript") {
          const {name, message} = stackTrace_1.splitErrorMessage(text);
          const error3 = new Error(message);
          if (event.message.stackTrace) {
            error3.stack = event.message.stackTrace.map((callFrame) => {
              return `${callFrame.functionName}@${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber}`;
            }).join("\n");
          } else {
            error3.stack = "";
          }
          error3.name = name;
          this._page.emit(page_1.Page.Events.PageError, error3);
          return;
        }
        let derivedType = type || "";
        if (type === "log")
          derivedType = level;
        else if (type === "timing")
          derivedType = "timeEnd";
        const handles = (parameters || []).map((p) => {
          let context = null;
          if (p.objectId) {
            const objectId = JSON.parse(p.objectId);
            context = this._contextIdToContext.get(objectId.injectedScriptId);
          } else {
            context = this._contextIdToContext.get(this._mainFrameContextId);
          }
          return context.createHandle(p);
        });
        this._lastConsoleMessage = {
          derivedType,
          text,
          handles,
          count: 0,
          location: {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          }
        };
        this._onConsoleRepeatCountUpdated({count: 1});
      }
      _onConsoleRepeatCountUpdated(event) {
        if (this._lastConsoleMessage) {
          const {derivedType, text, handles, count, location: location2} = this._lastConsoleMessage;
          for (let i = count; i < event.count; ++i)
            this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
          this._lastConsoleMessage.count = event.count;
        }
      }
      _onDialog(event) {
        this._page.emit(page_1.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
          await this._pageProxySession.send("Dialog.handleJavaScriptDialog", {accept, promptText});
        }, event.defaultPrompt));
      }
      async _onFileChooserOpened(event) {
        let handle;
        try {
          const context = await this._page._frameManager.frame(event.frameId)._mainContext();
          handle = context.createHandle(event.element).asElement();
        } catch (e) {
          return;
        }
        await this._page._onFileChooserOpened(handle);
      }
      static async _setEmulateMedia(session, mediaType, colorScheme) {
        const promises = [];
        promises.push(session.send("Page.setEmulatedMedia", {media: mediaType || ""}));
        if (colorScheme !== null) {
          let appearance = "";
          switch (colorScheme) {
            case "light":
              appearance = "Light";
              break;
            case "dark":
              appearance = "Dark";
              break;
          }
          promises.push(session.send("Page.setForcedAppearance", {appearance}));
        }
        await Promise.all(promises);
      }
      async updateExtraHTTPHeaders() {
        await this._updateState("Network.setExtraHTTPHeaders", {headers: utils_1.headersArrayToObject(this._calculateExtraHTTPHeaders(), false)});
      }
      _calculateExtraHTTPHeaders() {
        const locale = this._browserContext._options.locale;
        const headers = network.mergeHeaders([
          this._browserContext._options.extraHTTPHeaders,
          this._page._state.extraHTTPHeaders,
          locale ? network.singleHeader("Accept-Language", locale) : void 0
        ]);
        return headers;
      }
      async updateEmulateMedia() {
        const colorScheme = this._page._state.colorScheme || this._browserContext._options.colorScheme || "light";
        await this._forAllSessions((session) => WKPage._setEmulateMedia(session, this._page._state.mediaType, colorScheme));
      }
      async setEmulatedSize(emulatedSize) {
        utils_1.assert(this._page._state.emulatedSize === emulatedSize);
        await this._updateViewport();
      }
      async bringToFront() {
        this._pageProxySession.send("Target.activate", {
          targetId: this._session.sessionId
        });
      }
      async _updateViewport() {
        const options2 = this._browserContext._options;
        const deviceSize = this._page._state.emulatedSize;
        if (deviceSize === null)
          return;
        const viewportSize = deviceSize.viewport;
        const screenSize = deviceSize.screen;
        const promises = [
          this._pageProxySession.send("Emulation.setDeviceMetricsOverride", {
            width: viewportSize.width,
            height: viewportSize.height,
            fixedLayout: !!options2.isMobile,
            deviceScaleFactor: options2.deviceScaleFactor || 1
          }),
          this._session.send("Page.setScreenSizeOverride", {
            width: screenSize.width,
            height: screenSize.height
          })
        ];
        if (options2.isMobile) {
          const angle = viewportSize.width > viewportSize.height ? 90 : 0;
          promises.push(this._session.send("Page.setOrientationOverride", {angle}));
        }
        await Promise.all(promises);
      }
      async updateRequestInterception() {
        const enabled = this._page._needsRequestInterception();
        await Promise.all([
          this._updateState("Network.setInterceptionEnabled", {enabled}),
          this._updateState("Network.addInterception", {url: ".*", stage: "request", isRegex: true})
        ]);
      }
      async updateOffline() {
        await this._updateState("Network.setEmulateOfflineState", {offline: !!this._browserContext._options.offline});
      }
      async updateHttpCredentials() {
        const credentials = this._browserContext._options.httpCredentials || {username: "", password: ""};
        await this._pageProxySession.send("Emulation.setAuthCredentials", {username: credentials.username, password: credentials.password});
      }
      async setFileChooserIntercepted(enabled) {
        await this._session.send("Page.setInterceptFileChooserDialog", {enabled}).catch((e) => {
        });
      }
      async reload() {
        await this._session.send("Page.reload");
      }
      goBack() {
        return this._session.send("Page.goBack").then(() => true).catch((error3) => {
          if (error3 instanceof Error && error3.message.includes(`Protocol error (Page.goBack): Failed to go`))
            return false;
          throw error3;
        });
      }
      goForward() {
        return this._session.send("Page.goForward").then(() => true).catch((error3) => {
          if (error3 instanceof Error && error3.message.includes(`Protocol error (Page.goForward): Failed to go`))
            return false;
          throw error3;
        });
      }
      async exposeBinding(binding) {
        if (binding.world !== "main")
          throw new Error("Only main context bindings are supported in WebKit.");
        await this._updateBootstrapScript();
        await this._evaluateBindingScript(binding);
      }
      async _evaluateBindingScript(binding) {
        if (binding.world !== "main")
          throw new Error("Only main context bindings are supported in WebKit.");
        const script = this._bindingToScript(binding);
        await Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(script, false, {}).catch((e) => {
        })));
      }
      async evaluateOnNewDocument(script) {
        await this._updateBootstrapScript();
      }
      _bindingToScript(binding) {
        return `self.${binding.name} = (param) => console.debug('${BINDING_CALL_MESSAGE}', {}, param); ${binding.source}`;
      }
      _calculateBootstrapScript() {
        const scripts = [];
        for (const binding of this._page.allBindings())
          scripts.push(this._bindingToScript(binding));
        scripts.push(...this._browserContext._evaluateOnNewDocumentSources);
        scripts.push(...this._page._evaluateOnNewDocumentSources);
        return scripts.join(";");
      }
      async _updateBootstrapScript() {
        await this._updateState("Page.setBootstrapScript", {source: this._calculateBootstrapScript()});
      }
      async closePage(runBeforeUnload) {
        await this._stopScreencast();
        await this._pageProxySession.sendMayFail("Target.close", {
          targetId: this._session.sessionId,
          runBeforeUnload
        });
      }
      canScreenshotOutsideViewport() {
        return true;
      }
      async setBackgroundColor(color) {
        await this._session.send("Page.setDefaultBackgroundColorOverride", {color});
      }
      async _startScreencast(options2) {
        utils_1.assert(!this._recordingVideoFile);
        const START_VIDEO_PROTOCOL_COMMAND = registry_1.hostPlatform === "mac10.14" ? "Screencast.start" : "Screencast.startVideo";
        const {screencastId} = await this._pageProxySession.send(START_VIDEO_PROTOCOL_COMMAND, {
          file: options2.outputFile,
          width: options2.width,
          height: options2.height
        });
        this._recordingVideoFile = options2.outputFile;
        this._browserContext._browser._videoStarted(this._browserContext, screencastId, options2.outputFile, this.pageOrError());
      }
      async _stopScreencast() {
        if (!this._recordingVideoFile)
          return;
        const STOP_VIDEO_PROTOCOL_COMMAND = registry_1.hostPlatform === "mac10.14" ? "Screencast.stop" : "Screencast.stopVideo";
        await this._pageProxySession.sendMayFail(STOP_VIDEO_PROTOCOL_COMMAND);
        this._recordingVideoFile = null;
      }
      async takeScreenshot(progress, format2, documentRect, viewportRect, quality) {
        const rect = documentRect || viewportRect;
        const result = await this._session.send("Page.snapshotRect", {...rect, coordinateSystem: documentRect ? "Page" : "Viewport"});
        const prefix = "data:image/png;base64,";
        let buffer = Buffer.from(result.dataURL.substr(prefix.length), "base64");
        if (format2 === "jpeg")
          buffer = jpeg.encode(png.PNG.sync.read(buffer), quality).data;
        return buffer;
      }
      async resetViewport() {
        utils_1.assert(false, "Should not be called");
      }
      async getContentFrame(handle) {
        const nodeInfo = await this._session.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        if (!nodeInfo.contentFrameId)
          return null;
        return this._page._frameManager.frame(nodeInfo.contentFrameId);
      }
      async getOwnerFrame(handle) {
        if (!handle._objectId)
          return null;
        const nodeInfo = await this._session.send("DOM.describeNode", {
          objectId: handle._objectId
        });
        return nodeInfo.ownerFrameId || null;
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
          return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
          for (const point of quad) {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
          }
        }
        return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
      }
      async scrollRectIntoViewIfNeeded(handle, rect) {
        return await this._session.send("DOM.scrollIntoViewIfNeeded", {
          objectId: handle._objectId,
          rect
        }).then(() => "done").catch((e) => {
          if (e instanceof Error && e.message.includes("Node does not have a layout object"))
            return "error:notvisible";
          if (e instanceof Error && e.message.includes("Node is detached from document"))
            return "error:notconnected";
          throw e;
        });
      }
      async setScreencastEnabled(enabled) {
        throw new Error("Not implemented");
      }
      rafCountForStablePosition() {
        return process.platform === "win32" ? 5 : 1;
      }
      async getContentQuads(handle) {
        const result = await this._session.sendMayFail("DOM.getContentQuads", {
          objectId: handle._objectId
        });
        if (!result)
          return null;
        return result.quads.map((quad) => [
          {x: quad[0], y: quad[1]},
          {x: quad[2], y: quad[3]},
          {x: quad[4], y: quad[5]},
          {x: quad[6], y: quad[7]}
        ]);
      }
      async setInputFiles(handle, files) {
        const objectId = handle._objectId;
        const protocolFiles = files.map((file) => ({
          name: file.name,
          type: file.mimeType,
          data: file.buffer
        }));
        await this._session.send("DOM.setInputFiles", {objectId, files: protocolFiles});
      }
      async adoptElementHandle(handle, to) {
        const result = await this._session.sendMayFail("DOM.resolveNode", {
          objectId: handle._objectId,
          executionContextId: to._delegate._contextId
        });
        if (!result || result.object.subtype === "null")
          throw new Error("Unable to adopt element handle from a different document");
        return to.createHandle(result.object);
      }
      async getAccessibilityTree(needle) {
        return wkAccessibility_1.getAccessibilityTree(this._session, needle);
      }
      async inputActionEpilogue() {
      }
      async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
          throw new Error("Frame has been detached.");
        const handles = await this._page.selectors._queryAll(parent, "iframe", void 0);
        const items = await Promise.all(handles.map(async (handle) => {
          const frame2 = await handle.contentFrame().catch((e) => null);
          return {handle, frame: frame2};
        }));
        const result = items.find((item) => item.frame === frame);
        items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
        if (!result)
          throw new Error("Frame has been detached.");
        return result.handle;
      }
      _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (event.redirectResponse) {
          const request2 = this._requestIdToRequest.get(event.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, event.redirectResponse, event.timestamp);
            redirectedFrom = request2.request;
          }
        }
        const frame = redirectedFrom ? redirectedFrom.frame() : this._page._frameManager.frame(event.frameId);
        if (!frame)
          return;
        const isNavigationRequest = event.type === "Document";
        const documentId = isNavigationRequest ? event.loaderId : void 0;
        const allowInterception = this._page._needsRequestInterception() && !redirectedFrom;
        const request = new wkInterceptableRequest_1.WKInterceptableRequest(session, allowInterception, frame, event, redirectedFrom, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request);
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = request.createResponse(responsePayload);
        response._requestFinished(responsePayload.timing ? helper_1.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1, "Response body is unavailable for redirect responses");
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.requestFinished(request.request);
      }
      _onRequestIntercepted(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request) {
          this._session.sendMayFail("Network.interceptRequestWithError", {errorType: "Cancellation", requestId: event.requestId});
          return;
        }
        if (!request._allowInterception) {
          this._session.sendMayFail("Network.interceptWithRequest", {requestId: request._requestId});
        } else {
          request._interceptedCallback();
        }
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.createResponse(event.response);
        if (event.response.requestHeaders && Object.keys(event.response.requestHeaders).length)
          request.request.updateWithRawHeaders(utils_1.headersObjectToArray(event.response.requestHeaders));
        this._page._frameManager.requestReceivedResponse(response);
        if (response.status() === 204) {
          this._onLoadingFailed({
            requestId: event.requestId,
            errorText: "Aborted: 204 No Content",
            timestamp: event.timestamp
          });
        }
      }
      _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestFinished(request.request);
      }
      _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(helper_1.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes("cancelled"));
      }
      async _grantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
          ["geolocation", "geolocation"]
        ]);
        const filtered = permissions.map((permission) => {
          const protocolPermission = webPermissionToProtocol.get(permission);
          if (!protocolPermission)
            throw new Error("Unknown permission: " + permission);
          return protocolPermission;
        });
        await this._pageProxySession.send("Emulation.grantPermissions", {origin, permissions: filtered});
      }
      async _clearPermissions() {
        await this._pageProxySession.send("Emulation.resetPermissions", {});
      }
    };
    exports2.WKPage = WKPage;
  }
});

// node_modules/playwright/lib/server/webkit/wkBrowser.js
var require_wkBrowser = __commonJS({
  "node_modules/playwright/lib/server/webkit/wkBrowser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WKBrowserContext = exports2.WKBrowser = void 0;
    var browser_1 = require_browser2();
    var browserContext_1 = require_browserContext();
    var helper_1 = require_helper();
    var utils_1 = require_utils();
    var network = __importStar(require_network());
    var wkConnection_1 = require_wkConnection();
    var wkPage_1 = require_wkPage();
    var errors_1 = require_errors();
    var DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.2 Safari/605.1.15";
    var BROWSER_VERSION = "14.2";
    var WKBrowser = class extends browser_1.Browser {
      constructor(transport, options2) {
        super(options2);
        this._contexts = new Map();
        this._wkPages = new Map();
        this._connection = new wkConnection_1.WKConnection(transport, this._onDisconnect.bind(this), options2.protocolLogger, options2.browserLogsCollector);
        this._browserSession = this._connection.browserSession;
        this._eventListeners = [
          helper_1.helper.addEventListener(this._browserSession, "Playwright.pageProxyCreated", this._onPageProxyCreated.bind(this)),
          helper_1.helper.addEventListener(this._browserSession, "Playwright.pageProxyDestroyed", this._onPageProxyDestroyed.bind(this)),
          helper_1.helper.addEventListener(this._browserSession, "Playwright.provisionalLoadFailed", (event) => this._onProvisionalLoadFailed(event)),
          helper_1.helper.addEventListener(this._browserSession, "Playwright.windowOpen", (event) => this._onWindowOpen(event)),
          helper_1.helper.addEventListener(this._browserSession, "Playwright.downloadCreated", this._onDownloadCreated.bind(this)),
          helper_1.helper.addEventListener(this._browserSession, "Playwright.downloadFilenameSuggested", this._onDownloadFilenameSuggested.bind(this)),
          helper_1.helper.addEventListener(this._browserSession, "Playwright.downloadFinished", this._onDownloadFinished.bind(this)),
          helper_1.helper.addEventListener(this._browserSession, "Playwright.screencastFinished", this._onScreencastFinished.bind(this)),
          helper_1.helper.addEventListener(this._browserSession, wkConnection_1.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this))
        ];
      }
      static async connect(transport, options2) {
        const browser = new WKBrowser(transport, options2);
        if (options2.__testHookOnConnectToBrowser)
          await options2.__testHookOnConnectToBrowser();
        const promises = [
          browser._browserSession.send("Playwright.enable")
        ];
        if (options2.persistent) {
          browser._defaultContext = new WKBrowserContext(browser, void 0, options2.persistent);
          promises.push(browser._defaultContext._initialize());
        }
        await Promise.all(promises);
        return browser;
      }
      _onDisconnect() {
        for (const wkPage of this._wkPages.values())
          wkPage.dispose(true);
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(errors_1.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
      async newContext(options2) {
        browserContext_1.validateBrowserContextOptions(options2, this.options);
        const createOptions = options2.proxy ? {
          proxyServer: options2.proxy.server,
          proxyBypassList: options2.proxy.bypass
        } : void 0;
        const {browserContextId} = await this._browserSession.send("Playwright.createContext", createOptions);
        options2.userAgent = options2.userAgent || DEFAULT_USER_AGENT;
        const context = new WKBrowserContext(this, browserContextId, options2);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return BROWSER_VERSION;
      }
      _onDownloadCreated(payload) {
        const page = this._wkPages.get(payload.pageProxyId);
        if (!page)
          return;
        page._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
        let originPage = page._initializedPage;
        if (!originPage) {
          page._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
          if (page._opener)
            originPage = page._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
      }
      _onDownloadFilenameSuggested(payload) {
        this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
      }
      _onDownloadFinished(payload) {
        this._downloadFinished(payload.uuid, payload.error);
      }
      _onScreencastFinished(payload) {
        var _a;
        (_a = this._takeVideo(payload.screencastId)) === null || _a === void 0 ? void 0 : _a.reportFinished();
      }
      _onPageProxyCreated(event) {
        const pageProxyId = event.pageProxyId;
        let context = null;
        if (event.browserContextId) {
          context = this._contexts.get(event.browserContextId) || null;
        }
        if (!context)
          context = this._defaultContext;
        if (!context)
          return;
        const pageProxySession = new wkConnection_1.WKSession(this._connection, pageProxyId, `The page has been closed.`, (message) => {
          this._connection.rawSend({...message, pageProxyId});
        });
        const opener = event.openerId ? this._wkPages.get(event.openerId) : void 0;
        const wkPage = new wkPage_1.WKPage(context, pageProxySession, opener || null);
        this._wkPages.set(pageProxyId, wkPage);
      }
      _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const wkPage = this._wkPages.get(pageProxyId);
        if (!wkPage)
          return;
        wkPage.didClose();
        wkPage.dispose(false);
        this._wkPages.delete(pageProxyId);
      }
      _onPageProxyMessageReceived(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.dispatchMessageToSession(event.message);
      }
      _onProvisionalLoadFailed(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleProvisionalLoadFailed(event);
      }
      _onWindowOpen(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleWindowOpen(event);
      }
      isConnected() {
        return !this._connection.isClosed();
      }
    };
    exports2.WKBrowser = WKBrowser;
    var WKBrowserContext = class extends browserContext_1.BrowserContext {
      constructor(browser, browserContextId, options2) {
        super(browser, options2, browserContextId);
        this._browser = browser;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaHeader();
      }
      async _initialize() {
        utils_1.assert(!this._wkPages().length);
        const browserContextId = this._browserContextId;
        const promises = [super._initialize()];
        if (this._browser.options.downloadsPath) {
          promises.push(this._browser._browserSession.send("Playwright.setDownloadBehavior", {
            behavior: this._options.acceptDownloads ? "allow" : "deny",
            downloadPath: this._browser.options.downloadsPath,
            browserContextId
          }));
        }
        if (this._options.ignoreHTTPSErrors)
          promises.push(this._browser._browserSession.send("Playwright.setIgnoreCertificateErrors", {browserContextId, ignore: true}));
        if (this._options.locale)
          promises.push(this._browser._browserSession.send("Playwright.setLanguages", {browserContextId, languages: [this._options.locale]}));
        if (this._options.permissions)
          promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.geolocation)
          promises.push(this.setGeolocation(this._options.geolocation));
        if (this._options.offline)
          promises.push(this.setOffline(this._options.offline));
        if (this._options.httpCredentials)
          promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        await Promise.all(promises);
      }
      _wkPages() {
        return Array.from(this._browser._wkPages.values()).filter((wkPage) => wkPage._browserContext === this);
      }
      pages() {
        return this._wkPages().map((wkPage) => wkPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      async newPageDelegate() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const {pageProxyId} = await this._browser._browserSession.send("Playwright.createPage", {browserContextId: this._browserContextId});
        return this._browser._wkPages.get(pageProxyId);
      }
      async _doCookies(urls) {
        const {cookies} = await this._browser._browserSession.send("Playwright.getAllCookies", {browserContextId: this._browserContextId});
        return network.filterCookies(cookies.map((c) => {
          const copy = {...c};
          copy.expires = c.expires === -1 ? -1 : c.expires / 1e3;
          delete copy.session;
          return copy;
        }), urls);
      }
      async addCookies(cookies) {
        const cc = network.rewriteCookies(cookies).map((c) => ({
          ...c,
          session: c.expires === -1 || c.expires === void 0,
          expires: c.expires && c.expires !== -1 ? c.expires * 1e3 : c.expires
        }));
        await this._browser._browserSession.send("Playwright.setCookies", {cookies: cc, browserContextId: this._browserContextId});
      }
      async clearCookies() {
        await this._browser._browserSession.send("Playwright.deleteAllCookies", {browserContextId: this._browserContextId});
      }
      async _doGrantPermissions(origin, permissions) {
        await Promise.all(this.pages().map((page) => page._delegate._grantPermissions(origin, permissions)));
      }
      async _doClearPermissions() {
        await Promise.all(this.pages().map((page) => page._delegate._clearPermissions()));
      }
      async setGeolocation(geolocation) {
        browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation;
        const payload = geolocation ? {...geolocation, timestamp: Date.now()} : void 0;
        await this._browser._browserSession.send("Playwright.setGeolocationOverride", {browserContextId: this._browserContextId, geolocation: payload});
      }
      async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = headers;
        for (const page of this.pages())
          await page._delegate.updateExtraHTTPHeaders();
      }
      async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
          await page._delegate.updateOffline();
      }
      async _doSetHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials;
        for (const page of this.pages())
          await page._delegate.updateHttpCredentials();
      }
      async _doAddInitScript(source) {
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
          await page._delegate._updateBootstrapScript();
      }
      async _doExposeBinding(binding) {
        for (const page of this.pages())
          await page._delegate.exposeBinding(binding);
      }
      async _doUpdateRequestInterception() {
        for (const page of this.pages())
          await page._delegate.updateRequestInterception();
      }
      async _doClose() {
        utils_1.assert(this._browserContextId);
        await this._browser._browserSession.send("Playwright.deleteContext", {browserContextId: this._browserContextId});
        this._browser._contexts.delete(this._browserContextId);
      }
    };
    exports2.WKBrowserContext = WKBrowserContext;
  }
});

// node_modules/playwright/lib/server/webkit/webkit.js
var require_webkit = __commonJS({
  "node_modules/playwright/lib/server/webkit/webkit.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WebKit = void 0;
    var wkBrowser_1 = require_wkBrowser();
    var path_1 = __importDefault(require("path"));
    var wkConnection_1 = require_wkConnection();
    var browserType_1 = require_browserType();
    var fs = __importStar(require("fs"));
    var utils_1 = require_utils();
    var WebKit = class extends browserType_1.BrowserType {
      constructor(playwrightOptions) {
        super("webkit", playwrightOptions);
      }
      executablePath(channel) {
        if (channel) {
          let executablePath = void 0;
          if (channel === "technology-preview")
            executablePath = this._registry.executablePath("webkit-technology-preview");
          utils_1.assert(executablePath, `unsupported webkit channel "${channel}"`);
          utils_1.assert(fs.existsSync(executablePath), `webkit channel "${channel}" is not installed. Try running 'npx playwright install webkit-technology-preview'`);
          return executablePath;
        }
        return super.executablePath(channel);
      }
      _connectToTransport(transport, options2) {
        return wkBrowser_1.WKBrowser.connect(transport, options2);
      }
      _amendEnvironment(env2, userDataDir, executable, browserArguments) {
        return {...env2, CURL_COOKIE_JAR_PATH: path_1.default.join(userDataDir, "cookiejar.db")};
      }
      _rewriteStartupError(error3) {
        return error3;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        transport.send({method: "Playwright.close", params: {}, id: wkConnection_1.kBrowserCloseMessageId});
      }
      _defaultArgs(options2, isPersistent, userDataDir) {
        const {args = [], proxy, devtools, headless} = options2;
        if (devtools)
          console.warn("devtools parameter as a launch argument in WebKit is not supported. Also starting Web Inspector manually will terminate the execution in WebKit.");
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const webkitArguments = ["--inspector-pipe"];
        if (headless)
          webkitArguments.push("--headless");
        if (isPersistent)
          webkitArguments.push(`--user-data-dir=${userDataDir}`);
        else
          webkitArguments.push(`--no-startup-window`);
        if (proxy) {
          if (process.platform === "darwin") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
          } else if (process.platform === "linux") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(...proxy.bypass.split(",").map((t) => `--ignore-host=${t}`));
          } else if (process.platform === "win32") {
            webkitArguments.push(`--curl-proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
          }
        }
        webkitArguments.push(...args);
        if (isPersistent)
          webkitArguments.push("about:blank");
        return webkitArguments;
      }
    };
    exports2.WebKit = WebKit;
  }
});

// node_modules/playwright/lib/server/playwright.js
var require_playwright = __commonJS({
  "node_modules/playwright/lib/server/playwright.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createPlaywright = exports2.Playwright = void 0;
    var path_1 = __importDefault(require("path"));
    var android_1 = require_android();
    var backendAdb_1 = require_backendAdb();
    var chromium_1 = require_chromium();
    var electron_1 = require_electron2();
    var firefox_1 = require_firefox();
    var selectors_1 = require_selectors();
    var webkit_1 = require_webkit();
    var registry_1 = require_registry();
    var instrumentation_1 = require_instrumentation();
    var debugLogger_1 = require_debugLogger();
    var Playwright = class extends instrumentation_1.SdkObject {
      constructor(isInternal) {
        super({attribution: {isInternal}, instrumentation: instrumentation_1.createInstrumentation()}, void 0, "Playwright");
        this.instrumentation.addListener({
          onCallLog: (logName, message, sdkObject, metadata) => {
            debugLogger_1.debugLogger.log(logName, message);
          }
        });
        this.options = {
          registry: new registry_1.Registry(path_1.default.join(__dirname, "..", "..")),
          rootSdkObject: this
        };
        this.chromium = new chromium_1.Chromium(this.options);
        this.firefox = new firefox_1.Firefox(this.options);
        this.webkit = new webkit_1.WebKit(this.options);
        this.electron = new electron_1.Electron(this.options);
        this.android = new android_1.Android(new backendAdb_1.AdbBackend(), this.options);
        this.selectors = selectors_1.serverSelectors;
      }
    };
    exports2.Playwright = Playwright;
    function createPlaywright(isInternal = false) {
      return new Playwright(isInternal);
    }
    exports2.createPlaywright = createPlaywright;
  }
});

// node_modules/playwright/lib/dispatchers/jsHandleDispatcher.js
var require_jsHandleDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/jsHandleDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.serializeResult = exports2.parseValue = exports2.parseArgument = exports2.JSHandleDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var elementHandlerDispatcher_1 = require_elementHandlerDispatcher();
    var serializers_1 = require_serializers();
    var JSHandleDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, jsHandle) {
        super(scope, jsHandle, jsHandle.asElement() ? "ElementHandle" : "JSHandle", {
          preview: jsHandle.toString()
        });
        jsHandle._setPreviewCallback((preview) => this._dispatchEvent("previewUpdated", {preview}));
      }
      async evaluateExpression(params) {
        return {value: serializeResult(await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, parseArgument(params.arg)))};
      }
      async evaluateExpressionHandle(params) {
        const jsHandle = await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, parseArgument(params.arg));
        return {handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)};
      }
      async getProperty(params) {
        const jsHandle = await this._object.getProperty(params.name);
        return {handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)};
      }
      async getPropertyList() {
        const map = await this._object.getProperties();
        const properties = [];
        for (const [name, value] of map)
          properties.push({name, value: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, value)});
        return {properties};
      }
      async jsonValue() {
        return {value: serializeResult(await this._object.jsonValue())};
      }
      async dispose() {
        await this._object.dispose();
      }
    };
    exports2.JSHandleDispatcher = JSHandleDispatcher;
    function parseArgument(arg) {
      return serializers_1.parseSerializedValue(arg.value, arg.handles.map((a) => a._object));
    }
    exports2.parseArgument = parseArgument;
    function parseValue(v) {
      return serializers_1.parseSerializedValue(v, []);
    }
    exports2.parseValue = parseValue;
    function serializeResult(arg) {
      return serializers_1.serializeValue(arg, (value) => ({fallThrough: value}), new Set());
    }
    exports2.serializeResult = serializeResult;
  }
});

// node_modules/playwright/lib/dispatchers/elementHandlerDispatcher.js
var require_elementHandlerDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/elementHandlerDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ElementHandleDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var jsHandleDispatcher_1 = require_jsHandleDispatcher();
    var ElementHandleDispatcher = class extends jsHandleDispatcher_1.JSHandleDispatcher {
      constructor(scope, elementHandle) {
        super(scope, elementHandle);
        this._elementHandle = elementHandle;
      }
      static from(scope, handle) {
        return dispatcher_1.existingDispatcher(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromNullable(scope, handle) {
        if (!handle)
          return void 0;
        return dispatcher_1.existingDispatcher(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromJSHandle(scope, handle) {
        const result = dispatcher_1.existingDispatcher(handle);
        if (result)
          return result;
        return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new jsHandleDispatcher_1.JSHandleDispatcher(scope, handle);
      }
      async ownerFrame(params, metadata) {
        return {frame: dispatcher_1.lookupNullableDispatcher(await this._elementHandle.ownerFrame())};
      }
      async contentFrame(params, metadata) {
        return {frame: dispatcher_1.lookupNullableDispatcher(await this._elementHandle.contentFrame())};
      }
      async getAttribute(params, metadata) {
        const value = await this._elementHandle.getAttribute(params.name);
        return {value: value === null ? void 0 : value};
      }
      async textContent(params, metadata) {
        const value = await this._elementHandle.textContent();
        return {value: value === null ? void 0 : value};
      }
      async innerText(params, metadata) {
        return {value: await this._elementHandle.innerText()};
      }
      async innerHTML(params, metadata) {
        return {value: await this._elementHandle.innerHTML()};
      }
      async isChecked(params, metadata) {
        return {value: await this._elementHandle.isChecked()};
      }
      async isDisabled(params, metadata) {
        return {value: await this._elementHandle.isDisabled()};
      }
      async isEditable(params, metadata) {
        return {value: await this._elementHandle.isEditable()};
      }
      async isEnabled(params, metadata) {
        return {value: await this._elementHandle.isEnabled()};
      }
      async isHidden(params, metadata) {
        return {value: await this._elementHandle.isHidden()};
      }
      async isVisible(params, metadata) {
        return {value: await this._elementHandle.isVisible()};
      }
      async dispatchEvent(params, metadata) {
        await this._elementHandle.dispatchEvent(params.type, jsHandleDispatcher_1.parseArgument(params.eventInit));
      }
      async scrollIntoViewIfNeeded(params, metadata) {
        await this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
      }
      async hover(params, metadata) {
        return await this._elementHandle.hover(metadata, params);
      }
      async click(params, metadata) {
        return await this._elementHandle.click(metadata, params);
      }
      async dblclick(params, metadata) {
        return await this._elementHandle.dblclick(metadata, params);
      }
      async tap(params, metadata) {
        return await this._elementHandle.tap(metadata, params);
      }
      async selectOption(params, metadata) {
        const elements = (params.elements || []).map((e) => e._elementHandle);
        return {values: await this._elementHandle.selectOption(metadata, elements, params.options || [], params)};
      }
      async fill(params, metadata) {
        return await this._elementHandle.fill(metadata, params.value, params);
      }
      async selectText(params, metadata) {
        await this._elementHandle.selectText(metadata, params);
      }
      async setInputFiles(params, metadata) {
        return await this._elementHandle.setInputFiles(metadata, params.files, params);
      }
      async focus(params, metadata) {
        await this._elementHandle.focus(metadata);
      }
      async type(params, metadata) {
        return await this._elementHandle.type(metadata, params.text, params);
      }
      async press(params, metadata) {
        return await this._elementHandle.press(metadata, params.key, params);
      }
      async check(params, metadata) {
        return await this._elementHandle.check(metadata, params);
      }
      async uncheck(params, metadata) {
        return await this._elementHandle.uncheck(metadata, params);
      }
      async boundingBox(params, metadata) {
        const value = await this._elementHandle.boundingBox();
        return {value: value || void 0};
      }
      async screenshot(params, metadata) {
        return {binary: (await this._elementHandle.screenshot(metadata, params)).toString("base64")};
      }
      async querySelector(params, metadata) {
        const handle = await this._elementHandle.$(params.selector);
        return {element: ElementHandleDispatcher.fromNullable(this._scope, handle)};
      }
      async querySelectorAll(params, metadata) {
        const elements = await this._elementHandle.$$(params.selector);
        return {elements: elements.map((e) => ElementHandleDispatcher.from(this._scope, e))};
      }
      async evalOnSelector(params, metadata) {
        return {value: jsHandleDispatcher_1.serializeResult(await this._elementHandle.evalOnSelectorAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)))};
      }
      async evalOnSelectorAll(params, metadata) {
        return {value: jsHandleDispatcher_1.serializeResult(await this._elementHandle.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)))};
      }
      async waitForElementState(params, metadata) {
        await this._elementHandle.waitForElementState(metadata, params.state, params);
      }
      async waitForSelector(params, metadata) {
        return {element: ElementHandleDispatcher.fromNullable(this._scope, await this._elementHandle.waitForSelector(metadata, params.selector, params))};
      }
    };
    exports2.ElementHandleDispatcher = ElementHandleDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/consoleMessageDispatcher.js
var require_consoleMessageDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/consoleMessageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ConsoleMessageDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var elementHandlerDispatcher_1 = require_elementHandlerDispatcher();
    var ConsoleMessageDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, message) {
        super(scope, message, "ConsoleMessage", {
          type: message.type(),
          text: message.text(),
          args: message.args().map((a) => elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(scope, a)),
          location: message.location()
        });
      }
    };
    exports2.ConsoleMessageDispatcher = ConsoleMessageDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/dialogDispatcher.js
var require_dialogDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/dialogDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.DialogDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var DialogDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, dialog) {
        super(scope, dialog, "Dialog", {
          type: dialog.type(),
          message: dialog.message(),
          defaultValue: dialog.defaultValue()
        });
      }
      async accept(params) {
        await this._object.accept(params.promptText);
      }
      async dismiss() {
        await this._object.dismiss();
      }
    };
    exports2.DialogDispatcher = DialogDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/networkDispatchers.js
var require_networkDispatchers = __commonJS({
  "node_modules/playwright/lib/dispatchers/networkDispatchers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.WebSocketDispatcher = exports2.RouteDispatcher = exports2.ResponseDispatcher = exports2.RequestDispatcher = void 0;
    var network_1 = require_network();
    var dispatcher_1 = require_dispatcher();
    var frameDispatcher_1 = require_frameDispatcher();
    var RequestDispatcher = class extends dispatcher_1.Dispatcher {
      static from(scope, request) {
        const result = dispatcher_1.existingDispatcher(request);
        return result || new RequestDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? RequestDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        const postData = request.postDataBuffer();
        super(scope, request, "Request", {
          frame: frameDispatcher_1.FrameDispatcher.from(scope, request.frame()),
          url: request.url(),
          resourceType: request.resourceType(),
          method: request.method(),
          postData: postData === null ? void 0 : postData.toString("base64"),
          headers: request.headers(),
          isNavigationRequest: request.isNavigationRequest(),
          redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())
        });
      }
      async response() {
        return {response: dispatcher_1.lookupNullableDispatcher(await this._object.response())};
      }
    };
    exports2.RequestDispatcher = RequestDispatcher;
    var ResponseDispatcher = class extends dispatcher_1.Dispatcher {
      static from(scope, response) {
        const result = dispatcher_1.existingDispatcher(response);
        return result || new ResponseDispatcher(scope, response);
      }
      static fromNullable(scope, response) {
        return response ? ResponseDispatcher.from(scope, response) : void 0;
      }
      constructor(scope, response) {
        super(scope, response, "Response", {
          request: RequestDispatcher.from(scope, response.request()),
          url: response.url(),
          status: response.status(),
          statusText: response.statusText(),
          requestHeaders: response.request().headers(),
          headers: response.headers(),
          timing: response.timing()
        });
      }
      async finished() {
        return await this._object._finishedPromise;
      }
      async body() {
        return {binary: (await this._object.body()).toString("base64")};
      }
    };
    exports2.ResponseDispatcher = ResponseDispatcher;
    var RouteDispatcher = class extends dispatcher_1.Dispatcher {
      static from(scope, route) {
        const result = dispatcher_1.existingDispatcher(route);
        return result || new RouteDispatcher(scope, route);
      }
      static fromNullable(scope, route) {
        return route ? RouteDispatcher.from(scope, route) : void 0;
      }
      constructor(scope, route) {
        super(scope, route, "Route", {
          request: RequestDispatcher.from(scope, route.request())
        });
      }
      async continue(params) {
        await this._object.continue({
          url: params.url,
          method: params.method,
          headers: params.headers,
          postData: params.postData ? Buffer.from(params.postData, "base64") : void 0
        });
      }
      async fulfill(params) {
        await this._object.fulfill(params);
      }
      async abort(params) {
        await this._object.abort(params.errorCode || "failed");
      }
    };
    exports2.RouteDispatcher = RouteDispatcher;
    var WebSocketDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, webSocket) {
        super(scope, webSocket, "WebSocket", {
          url: webSocket.url()
        });
        webSocket.on(network_1.WebSocket.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
        webSocket.on(network_1.WebSocket.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
        webSocket.on(network_1.WebSocket.Events.SocketError, (error3) => this._dispatchEvent("socketError", {error: error3}));
        webSocket.on(network_1.WebSocket.Events.Close, () => this._dispatchEvent("close", {}));
      }
    };
    exports2.WebSocketDispatcher = WebSocketDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/frameDispatcher.js
var require_frameDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/frameDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FrameDispatcher = void 0;
    var frames_1 = require_frames();
    var dispatcher_1 = require_dispatcher();
    var elementHandlerDispatcher_1 = require_elementHandlerDispatcher();
    var jsHandleDispatcher_1 = require_jsHandleDispatcher();
    var networkDispatchers_1 = require_networkDispatchers();
    var FrameDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, frame) {
        super(scope, frame, "Frame", {
          url: frame.url(),
          name: frame.name(),
          parentFrame: dispatcher_1.lookupNullableDispatcher(frame.parentFrame()),
          loadStates: Array.from(frame._subtreeLifecycleEvents)
        });
        this._frame = frame;
        frame.on(frames_1.Frame.Events.AddLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {add: lifecycleEvent});
        });
        frame.on(frames_1.Frame.Events.RemoveLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {remove: lifecycleEvent});
        });
        frame.on(frames_1.Frame.Events.Navigation, (event) => {
          const params = {url: event.url, name: event.name, error: event.error ? event.error.message : void 0};
          if (event.newDocument)
            params.newDocument = {request: networkDispatchers_1.RequestDispatcher.fromNullable(this._scope, event.newDocument.request || null)};
          this._dispatchEvent("navigated", params);
        });
      }
      static from(scope, frame) {
        const result = dispatcher_1.existingDispatcher(frame);
        return result || new FrameDispatcher(scope, frame);
      }
      async goto(params, metadata) {
        return {response: dispatcher_1.lookupNullableDispatcher(await this._frame.goto(metadata, params.url, params))};
      }
      async frameElement() {
        return {element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, await this._frame.frameElement())};
      }
      async evaluateExpression(params, metadata) {
        return {value: jsHandleDispatcher_1.serializeResult(await this._frame.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), params.world))};
      }
      async evaluateExpressionHandle(params, metadata) {
        return {handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame.evaluateExpressionHandleAndWaitForSignals(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), params.world))};
      }
      async waitForSelector(params, metadata) {
        return {element: elementHandlerDispatcher_1.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.waitForSelector(metadata, params.selector, params))};
      }
      async dispatchEvent(params, metadata) {
        return this._frame.dispatchEvent(metadata, params.selector, params.type, jsHandleDispatcher_1.parseArgument(params.eventInit), params);
      }
      async evalOnSelector(params, metadata) {
        return {value: jsHandleDispatcher_1.serializeResult(await this._frame.evalOnSelectorAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)))};
      }
      async evalOnSelectorAll(params, metadata) {
        return {value: jsHandleDispatcher_1.serializeResult(await this._frame.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)))};
      }
      async querySelector(params, metadata) {
        return {element: elementHandlerDispatcher_1.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.$(params.selector))};
      }
      async querySelectorAll(params, metadata) {
        const elements = await this._frame.$$(params.selector);
        return {elements: elements.map((e) => elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, e))};
      }
      async content() {
        return {value: await this._frame.content()};
      }
      async setContent(params, metadata) {
        return await this._frame.setContent(metadata, params.html, params);
      }
      async addScriptTag(params, metadata) {
        return {element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, await this._frame.addScriptTag(params))};
      }
      async addStyleTag(params, metadata) {
        return {element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, await this._frame.addStyleTag(params))};
      }
      async click(params, metadata) {
        return await this._frame.click(metadata, params.selector, params);
      }
      async dblclick(params, metadata) {
        return await this._frame.dblclick(metadata, params.selector, params);
      }
      async tap(params, metadata) {
        return await this._frame.tap(metadata, params.selector, params);
      }
      async fill(params, metadata) {
        return await this._frame.fill(metadata, params.selector, params.value, params);
      }
      async focus(params, metadata) {
        await this._frame.focus(metadata, params.selector, params);
      }
      async textContent(params, metadata) {
        const value = await this._frame.textContent(metadata, params.selector, params);
        return {value: value === null ? void 0 : value};
      }
      async innerText(params, metadata) {
        return {value: await this._frame.innerText(metadata, params.selector, params)};
      }
      async innerHTML(params, metadata) {
        return {value: await this._frame.innerHTML(metadata, params.selector, params)};
      }
      async getAttribute(params, metadata) {
        const value = await this._frame.getAttribute(metadata, params.selector, params.name, params);
        return {value: value === null ? void 0 : value};
      }
      async isChecked(params, metadata) {
        return {value: await this._frame.isChecked(metadata, params.selector, params)};
      }
      async isDisabled(params, metadata) {
        return {value: await this._frame.isDisabled(metadata, params.selector, params)};
      }
      async isEditable(params, metadata) {
        return {value: await this._frame.isEditable(metadata, params.selector, params)};
      }
      async isEnabled(params, metadata) {
        return {value: await this._frame.isEnabled(metadata, params.selector, params)};
      }
      async isHidden(params, metadata) {
        return {value: await this._frame.isHidden(metadata, params.selector, params)};
      }
      async isVisible(params, metadata) {
        return {value: await this._frame.isVisible(metadata, params.selector, params)};
      }
      async hover(params, metadata) {
        return await this._frame.hover(metadata, params.selector, params);
      }
      async selectOption(params, metadata) {
        const elements = (params.elements || []).map((e) => e._elementHandle);
        return {values: await this._frame.selectOption(metadata, params.selector, elements, params.options || [], params)};
      }
      async setInputFiles(params, metadata) {
        return await this._frame.setInputFiles(metadata, params.selector, params.files, params);
      }
      async type(params, metadata) {
        return await this._frame.type(metadata, params.selector, params.text, params);
      }
      async press(params, metadata) {
        return await this._frame.press(metadata, params.selector, params.key, params);
      }
      async check(params, metadata) {
        return await this._frame.check(metadata, params.selector, params);
      }
      async uncheck(params, metadata) {
        return await this._frame.uncheck(metadata, params.selector, params);
      }
      async waitForFunction(params, metadata) {
        return {handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), params))};
      }
      async title(params, metadata) {
        return {value: await this._frame.title()};
      }
    };
    exports2.FrameDispatcher = FrameDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/streamDispatcher.js
var require_streamDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/streamDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.StreamDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var utils_1 = require_utils();
    var StreamDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, stream) {
        super(scope, {guid: utils_1.createGuid(), stream}, "Stream", {});
        this._ended = false;
        stream.once("end", () => this._ended = true);
        stream.once("error", () => this._ended = true);
      }
      async read(params) {
        const stream = this._object.stream;
        if (this._ended)
          return {binary: ""};
        if (!stream.readableLength) {
          await new Promise((fulfill, reject) => {
            stream.once("readable", fulfill);
            stream.once("end", fulfill);
            stream.once("error", reject);
          });
        }
        const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
        return {binary: buffer ? buffer.toString("base64") : ""};
      }
      async close() {
        this._object.stream.destroy();
      }
    };
    exports2.StreamDispatcher = StreamDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/artifactDispatcher.js
var require_artifactDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/artifactDispatcher.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ArtifactDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var streamDispatcher_1 = require_streamDispatcher();
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var utils_1 = require_utils();
    var ArtifactDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, artifact) {
        super(scope, artifact, "Artifact", {
          absolutePath: artifact.localPath()
        });
      }
      async pathAfterFinished() {
        const path = await this._object.localPathAfterFinished();
        return {value: path || void 0};
      }
      async saveAs(params) {
        return await new Promise((resolve2, reject) => {
          this._object.saveAs(async (localPath, error3) => {
            if (error3 !== void 0) {
              reject(new Error(error3));
              return;
            }
            try {
              await utils_1.mkdirIfNeeded(params.path);
              await util.promisify(fs_1.default.copyFile)(localPath, params.path);
              resolve2();
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async saveAsStream() {
        return await new Promise((resolve2, reject) => {
          this._object.saveAs(async (localPath, error3) => {
            if (error3 !== void 0) {
              reject(new Error(error3));
              return;
            }
            try {
              const readable = fs_1.default.createReadStream(localPath);
              const stream = new streamDispatcher_1.StreamDispatcher(this._scope, readable);
              resolve2({stream});
              await new Promise((resolve3) => {
                readable.on("close", resolve3);
                readable.on("end", resolve3);
                readable.on("error", resolve3);
              });
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async stream() {
        const fileName = await this._object.localPathAfterFinished();
        if (!fileName)
          return {};
        const readable = fs_1.default.createReadStream(fileName);
        return {stream: new streamDispatcher_1.StreamDispatcher(this._scope, readable)};
      }
      async failure() {
        const error3 = await this._object.failureError();
        return {error: error3 || void 0};
      }
      async delete() {
        await this._object.delete();
        this._dispose();
      }
    };
    exports2.ArtifactDispatcher = ArtifactDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/pageDispatcher.js
var require_pageDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/pageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BindingCallDispatcher = exports2.WorkerDispatcher = exports2.PageDispatcher = void 0;
    var page_1 = require_page();
    var dispatcher_1 = require_dispatcher();
    var serializers_1 = require_serializers();
    var consoleMessageDispatcher_1 = require_consoleMessageDispatcher();
    var dialogDispatcher_1 = require_dialogDispatcher();
    var frameDispatcher_1 = require_frameDispatcher();
    var networkDispatchers_1 = require_networkDispatchers();
    var jsHandleDispatcher_1 = require_jsHandleDispatcher();
    var elementHandlerDispatcher_1 = require_elementHandlerDispatcher();
    var artifactDispatcher_1 = require_artifactDispatcher();
    var utils_1 = require_utils();
    var PageDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, page) {
        super(scope, page, "Page", {
          mainFrame: frameDispatcher_1.FrameDispatcher.from(scope, page.mainFrame()),
          viewportSize: page.viewportSize() || void 0,
          isClosed: page.isClosed(),
          opener: PageDispatcher.fromNullable(scope, page.opener())
        }, true);
        this._page = page;
        page.on(page_1.Page.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        page.on(page_1.Page.Events.Console, (message) => this._dispatchEvent("console", {message: new consoleMessageDispatcher_1.ConsoleMessageDispatcher(this._scope, message)}));
        page.on(page_1.Page.Events.Crash, () => this._dispatchEvent("crash"));
        page.on(page_1.Page.Events.DOMContentLoaded, () => this._dispatchEvent("domcontentloaded"));
        page.on(page_1.Page.Events.Dialog, (dialog) => this._dispatchEvent("dialog", {dialog: new dialogDispatcher_1.DialogDispatcher(this._scope, dialog)}));
        page.on(page_1.Page.Events.Download, (download) => {
          this._dispatchEvent("download", {url: download.url, suggestedFilename: download.suggestedFilename(), artifact: new artifactDispatcher_1.ArtifactDispatcher(scope, download.artifact)});
        });
        this._page.on(page_1.Page.Events.FileChooser, (fileChooser) => this._dispatchEvent("fileChooser", {
          element: elementHandlerDispatcher_1.ElementHandleDispatcher.from(this._scope, fileChooser.element()),
          isMultiple: fileChooser.isMultiple()
        }));
        page.on(page_1.Page.Events.FrameAttached, (frame) => this._onFrameAttached(frame));
        page.on(page_1.Page.Events.FrameDetached, (frame) => this._onFrameDetached(frame));
        page.on(page_1.Page.Events.Load, () => this._dispatchEvent("load"));
        page.on(page_1.Page.Events.PageError, (error3) => this._dispatchEvent("pageError", {error: serializers_1.serializeError(error3)}));
        page.on(page_1.Page.Events.Request, (request) => this._dispatchEvent("request", {request: networkDispatchers_1.RequestDispatcher.from(this._scope, request)}));
        page.on(page_1.Page.Events.RequestFailed, (request) => this._dispatchEvent("requestFailed", {
          request: networkDispatchers_1.RequestDispatcher.from(this._scope, request),
          failureText: request._failureText,
          responseEndTiming: request._responseEndTiming
        }));
        page.on(page_1.Page.Events.RequestFinished, (request) => this._dispatchEvent("requestFinished", {
          request: networkDispatchers_1.RequestDispatcher.from(scope, request),
          responseEndTiming: request._responseEndTiming
        }));
        page.on(page_1.Page.Events.Response, (response) => this._dispatchEvent("response", {response: networkDispatchers_1.ResponseDispatcher.from(this._scope, response)}));
        page.on(page_1.Page.Events.WebSocket, (webSocket) => this._dispatchEvent("webSocket", {webSocket: new networkDispatchers_1.WebSocketDispatcher(this._scope, webSocket)}));
        page.on(page_1.Page.Events.Worker, (worker) => this._dispatchEvent("worker", {worker: new WorkerDispatcher(this._scope, worker)}));
        page.on(page_1.Page.Events.Video, (artifact) => this._dispatchEvent("video", {artifact: dispatcher_1.existingDispatcher(artifact)}));
        if (page._video)
          this._dispatchEvent("video", {artifact: dispatcher_1.existingDispatcher(page._video)});
      }
      static fromNullable(scope, page) {
        if (!page)
          return void 0;
        const result = dispatcher_1.existingDispatcher(page);
        return result || new PageDispatcher(scope, page);
      }
      page() {
        return this._page;
      }
      async setDefaultNavigationTimeoutNoReply(params, metadata) {
        this._page.setDefaultNavigationTimeout(params.timeout);
      }
      async setDefaultTimeoutNoReply(params, metadata) {
        this._page.setDefaultTimeout(params.timeout);
      }
      async exposeBinding(params, metadata) {
        await this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
          const binding = new BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
          this._dispatchEvent("bindingCall", {binding});
          return binding.promise();
        });
      }
      async setExtraHTTPHeaders(params, metadata) {
        await this._page.setExtraHTTPHeaders(params.headers);
      }
      async reload(params, metadata) {
        return {response: dispatcher_1.lookupNullableDispatcher(await this._page.reload(metadata, params))};
      }
      async goBack(params, metadata) {
        return {response: dispatcher_1.lookupNullableDispatcher(await this._page.goBack(metadata, params))};
      }
      async goForward(params, metadata) {
        return {response: dispatcher_1.lookupNullableDispatcher(await this._page.goForward(metadata, params))};
      }
      async emulateMedia(params, metadata) {
        await this._page.emulateMedia({
          media: params.media === "null" ? null : params.media,
          colorScheme: params.colorScheme === "null" ? null : params.colorScheme
        });
      }
      async setViewportSize(params, metadata) {
        await this._page.setViewportSize(params.viewportSize);
      }
      async addInitScript(params, metadata) {
        await this._page._addInitScriptExpression(params.source);
      }
      async setNetworkInterceptionEnabled(params, metadata) {
        if (!params.enabled) {
          await this._page._setClientRequestInterceptor(void 0);
          return;
        }
        await this._page._setClientRequestInterceptor((route, request) => {
          this._dispatchEvent("route", {route: networkDispatchers_1.RouteDispatcher.from(this._scope, route), request: networkDispatchers_1.RequestDispatcher.from(this._scope, request)});
        });
      }
      async screenshot(params, metadata) {
        return {binary: (await this._page.screenshot(metadata, params)).toString("base64")};
      }
      async close(params, metadata) {
        await this._page.close(metadata, params);
      }
      async setFileChooserInterceptedNoReply(params, metadata) {
        await this._page._setFileChooserIntercepted(params.intercepted);
      }
      async keyboardDown(params, metadata) {
        await this._page.keyboard.down(params.key);
      }
      async keyboardUp(params, metadata) {
        await this._page.keyboard.up(params.key);
      }
      async keyboardInsertText(params, metadata) {
        await this._page.keyboard.insertText(params.text);
      }
      async keyboardType(params, metadata) {
        await this._page.keyboard.type(params.text, params);
      }
      async keyboardPress(params, metadata) {
        await this._page.keyboard.press(params.key, params);
      }
      async mouseMove(params, metadata) {
        await this._page.mouse.move(params.x, params.y, params);
      }
      async mouseDown(params, metadata) {
        await this._page.mouse.down(params);
      }
      async mouseUp(params, metadata) {
        await this._page.mouse.up(params);
      }
      async mouseClick(params, metadata) {
        await this._page.mouse.click(params.x, params.y, params);
      }
      async touchscreenTap(params, metadata) {
        await this._page.touchscreen.tap(params.x, params.y);
      }
      async accessibilitySnapshot(params, metadata) {
        const rootAXNode = await this._page.accessibility.snapshot({
          interestingOnly: params.interestingOnly,
          root: params.root ? params.root._elementHandle : void 0
        });
        return {rootAXNode: rootAXNode || void 0};
      }
      async pdf(params, metadata) {
        if (!this._page.pdf)
          throw new Error("PDF generation is only supported for Headless Chromium");
        const buffer = await this._page.pdf(params);
        return {pdf: buffer.toString("base64")};
      }
      async bringToFront(params, metadata) {
        await this._page.bringToFront();
      }
      async startJSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        await coverage.startJSCoverage(params);
      }
      async stopJSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        return {entries: await coverage.stopJSCoverage()};
      }
      async startCSSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        await coverage.startCSSCoverage(params);
      }
      async stopCSSCoverage(params, metadata) {
        const coverage = this._page.coverage;
        return {entries: await coverage.stopCSSCoverage()};
      }
      _onFrameAttached(frame) {
        this._dispatchEvent("frameAttached", {frame: frameDispatcher_1.FrameDispatcher.from(this._scope, frame)});
      }
      _onFrameDetached(frame) {
        this._dispatchEvent("frameDetached", {frame: dispatcher_1.lookupDispatcher(frame)});
      }
    };
    exports2.PageDispatcher = PageDispatcher;
    var WorkerDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, worker) {
        super(scope, worker, "Worker", {
          url: worker.url()
        });
        worker.on(page_1.Worker.Events.Close, () => this._dispatchEvent("close"));
      }
      async evaluateExpression(params, metadata) {
        return {value: jsHandleDispatcher_1.serializeResult(await this._object.evaluateExpression(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)))};
      }
      async evaluateExpressionHandle(params, metadata) {
        return {handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg)))};
      }
    };
    exports2.WorkerDispatcher = WorkerDispatcher;
    var BindingCallDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, name, needsHandle, source, args) {
        super(scope, {guid: utils_1.createGuid()}, "BindingCall", {
          frame: dispatcher_1.lookupDispatcher(source.frame),
          name,
          args: needsHandle ? void 0 : args.map(jsHandleDispatcher_1.serializeResult),
          handle: needsHandle ? elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : void 0
        });
        this._promise = new Promise((resolve2, reject) => {
          this._resolve = resolve2;
          this._reject = reject;
        });
      }
      promise() {
        return this._promise;
      }
      async resolve(params, metadata) {
        this._resolve(jsHandleDispatcher_1.parseArgument(params.result));
      }
      async reject(params, metadata) {
        this._reject(serializers_1.parseError(params.error));
      }
    };
    exports2.BindingCallDispatcher = BindingCallDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/cdpSessionDispatcher.js
var require_cdpSessionDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/cdpSessionDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CDPSessionDispatcher = void 0;
    var crConnection_1 = require_crConnection();
    var dispatcher_1 = require_dispatcher();
    var CDPSessionDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, crSession) {
        super(scope, crSession, "CDPSession", {}, true);
        crSession._eventListener = (method, params) => {
          this._dispatchEvent("event", {method, params});
        };
        crSession.on(crConnection_1.CRSessionEvents.Disconnected, () => this._dispose());
      }
      async send(params) {
        return {result: await this._object.send(params.method, params.params)};
      }
      async detach() {
        return this._object.detach();
      }
    };
    exports2.CDPSessionDispatcher = CDPSessionDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/browserContextDispatcher.js
var require_browserContextDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/browserContextDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BrowserContextDispatcher = void 0;
    var browserContext_1 = require_browserContext();
    var dispatcher_1 = require_dispatcher();
    var pageDispatcher_1 = require_pageDispatcher();
    var networkDispatchers_1 = require_networkDispatchers();
    var crBrowser_1 = require_crBrowser();
    var cdpSessionDispatcher_1 = require_cdpSessionDispatcher();
    var recorderSupplement_1 = require_recorderSupplement();
    var artifactDispatcher_1 = require_artifactDispatcher();
    var BrowserContextDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, context) {
        super(scope, context, "BrowserContext", {isChromium: context._browser.options.isChromium}, true);
        this._context = context;
        const onVideo = (artifact) => {
          const artifactDispatcher = new artifactDispatcher_1.ArtifactDispatcher(scope, artifact);
          this._dispatchEvent("video", {artifact: artifactDispatcher});
        };
        context.on(browserContext_1.BrowserContext.Events.VideoStarted, onVideo);
        for (const video of context._browser._idToVideo.values()) {
          if (video.context === context)
            onVideo(video.artifact);
        }
        for (const page of context.pages())
          this._dispatchEvent("page", {page: new pageDispatcher_1.PageDispatcher(this._scope, page)});
        context.on(browserContext_1.BrowserContext.Events.Page, (page) => this._dispatchEvent("page", {page: new pageDispatcher_1.PageDispatcher(this._scope, page)}));
        context.on(browserContext_1.BrowserContext.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        if (context._browser.options.name === "chromium") {
          for (const page of context.backgroundPages())
            this._dispatchEvent("backgroundPage", {page: new pageDispatcher_1.PageDispatcher(this._scope, page)});
          context.on(crBrowser_1.CRBrowserContext.CREvents.BackgroundPage, (page) => this._dispatchEvent("backgroundPage", {page: new pageDispatcher_1.PageDispatcher(this._scope, page)}));
          for (const serviceWorker of context.serviceWorkers())
            this._dispatchEvent("serviceWorker", {worker: new pageDispatcher_1.WorkerDispatcher(this._scope, serviceWorker)});
          context.on(crBrowser_1.CRBrowserContext.CREvents.ServiceWorker, (serviceWorker) => this._dispatchEvent("serviceWorker", {worker: new pageDispatcher_1.WorkerDispatcher(this._scope, serviceWorker)}));
        }
      }
      async setDefaultNavigationTimeoutNoReply(params) {
        this._context.setDefaultNavigationTimeout(params.timeout);
      }
      async setDefaultTimeoutNoReply(params) {
        this._context.setDefaultTimeout(params.timeout);
      }
      async exposeBinding(params) {
        await this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
          const binding = new pageDispatcher_1.BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
          this._dispatchEvent("bindingCall", {binding});
          return binding.promise();
        });
      }
      async newPage(params, metadata) {
        return {page: dispatcher_1.lookupDispatcher(await this._context.newPage(metadata))};
      }
      async cookies(params) {
        return {cookies: await this._context.cookies(params.urls)};
      }
      async addCookies(params) {
        await this._context.addCookies(params.cookies);
      }
      async clearCookies() {
        await this._context.clearCookies();
      }
      async grantPermissions(params) {
        await this._context.grantPermissions(params.permissions, params.origin);
      }
      async clearPermissions() {
        await this._context.clearPermissions();
      }
      async setGeolocation(params) {
        await this._context.setGeolocation(params.geolocation);
      }
      async setExtraHTTPHeaders(params) {
        await this._context.setExtraHTTPHeaders(params.headers);
      }
      async setOffline(params) {
        await this._context.setOffline(params.offline);
      }
      async setHTTPCredentials(params) {
        await this._context.setHTTPCredentials(params.httpCredentials);
      }
      async addInitScript(params) {
        await this._context._doAddInitScript(params.source);
      }
      async setNetworkInterceptionEnabled(params) {
        if (!params.enabled) {
          await this._context._setRequestInterceptor(void 0);
          return;
        }
        await this._context._setRequestInterceptor((route, request) => {
          this._dispatchEvent("route", {route: networkDispatchers_1.RouteDispatcher.from(this._scope, route), request: networkDispatchers_1.RequestDispatcher.from(this._scope, request)});
        });
      }
      async storageState(params, metadata) {
        return await this._context.storageState(metadata);
      }
      async close(params, metadata) {
        await this._context.close(metadata);
      }
      async recorderSupplementEnable(params) {
        await recorderSupplement_1.RecorderSupplement.show(this._context, params);
      }
      async pause(params, metadata) {
      }
      async newCDPSession(params) {
        if (!this._object._browser.options.isChromium)
          throw new Error(`CDP session is only available in Chromium`);
        const crBrowserContext = this._object;
        return {session: new cdpSessionDispatcher_1.CDPSessionDispatcher(this._scope, await crBrowserContext.newCDPSession(params.page._object))};
      }
      async tracingStart(params) {
        await this._context.tracing.start(params);
      }
      async tracingStop(params) {
        await this._context.tracing.stop();
      }
      async tracingExport(params) {
        const artifact = await this._context.tracing.export();
        return {artifact: new artifactDispatcher_1.ArtifactDispatcher(this._scope, artifact)};
      }
    };
    exports2.BrowserContextDispatcher = BrowserContextDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/androidDispatcher.js
var require_androidDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/androidDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.AndroidSocketDispatcher = exports2.AndroidDeviceDispatcher = exports2.AndroidDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var android_1 = require_android();
    var browserContextDispatcher_1 = require_browserContextDispatcher();
    var AndroidDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, android) {
        super(scope, android, "Android", {}, true);
      }
      async devices(params) {
        const devices2 = await this._object.devices();
        return {
          devices: devices2.map((d) => AndroidDeviceDispatcher.from(this._scope, d))
        };
      }
      async setDefaultTimeoutNoReply(params) {
        this._object.setDefaultTimeout(params.timeout);
      }
    };
    exports2.AndroidDispatcher = AndroidDispatcher;
    var AndroidDeviceDispatcher = class extends dispatcher_1.Dispatcher {
      static from(scope, device) {
        const result = dispatcher_1.existingDispatcher(device);
        return result || new AndroidDeviceDispatcher(scope, device);
      }
      constructor(scope, device) {
        super(scope, device, "AndroidDevice", {
          model: device.model,
          serial: device.serial
        }, true);
        for (const webView of device.webViews())
          this._dispatchEvent("webViewAdded", {webView});
        device.on(android_1.AndroidDevice.Events.WebViewAdded, (webView) => this._dispatchEvent("webViewAdded", {webView}));
        device.on(android_1.AndroidDevice.Events.WebViewRemoved, (pid) => this._dispatchEvent("webViewRemoved", {pid}));
      }
      async wait(params) {
        await this._object.send("wait", params);
      }
      async fill(params) {
        await this._object.send("click", {selector: params.selector});
        await this._object.send("fill", params);
      }
      async tap(params) {
        await this._object.send("click", params);
      }
      async drag(params) {
        await this._object.send("drag", params);
      }
      async fling(params) {
        await this._object.send("fling", params);
      }
      async longTap(params) {
        await this._object.send("longClick", params);
      }
      async pinchClose(params) {
        await this._object.send("pinchClose", params);
      }
      async pinchOpen(params) {
        await this._object.send("pinchOpen", params);
      }
      async scroll(params) {
        await this._object.send("scroll", params);
      }
      async swipe(params) {
        await this._object.send("swipe", params);
      }
      async info(params) {
        return {info: await this._object.send("info", params)};
      }
      async inputType(params) {
        const text = params.text;
        const keyCodes = [];
        for (let i = 0; i < text.length; ++i) {
          const code = keyMap.get(text[i].toUpperCase());
          if (code === void 0)
            throw new Error("No mapping for " + text[i] + " found");
          keyCodes.push(code);
        }
        await Promise.all(keyCodes.map((keyCode) => this._object.send("inputPress", {keyCode})));
      }
      async inputPress(params) {
        if (!keyMap.has(params.key))
          throw new Error("Unknown key: " + params.key);
        await this._object.send("inputPress", {keyCode: keyMap.get(params.key)});
      }
      async inputTap(params) {
        await this._object.send("inputClick", params);
      }
      async inputSwipe(params) {
        await this._object.send("inputSwipe", params);
      }
      async inputDrag(params) {
        await this._object.send("inputDrag", params);
      }
      async screenshot(params) {
        return {binary: (await this._object.screenshot()).toString("base64")};
      }
      async shell(params) {
        return {result: (await this._object.shell(params.command)).toString("base64")};
      }
      async open(params, metadata) {
        const socket = await this._object.open(params.command);
        return {socket: new AndroidSocketDispatcher(this._scope, socket)};
      }
      async installApk(params) {
        await this._object.installApk(Buffer.from(params.file, "base64"), {args: params.args});
      }
      async push(params) {
        await this._object.push(Buffer.from(params.file, "base64"), params.path, params.mode);
      }
      async launchBrowser(params) {
        const context = await this._object.launchBrowser(params.pkg, params);
        return {context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, context)};
      }
      async close(params) {
        await this._object.close();
      }
      async setDefaultTimeoutNoReply(params) {
        this._object.setDefaultTimeout(params.timeout);
      }
      async connectToWebView(params) {
        return {context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, await this._object.connectToWebView(params.pid, params.sdkLanguage))};
      }
    };
    exports2.AndroidDeviceDispatcher = AndroidDeviceDispatcher;
    var AndroidSocketDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, socket) {
        super(scope, socket, "AndroidSocket", {}, true);
        socket.on("data", (data) => this._dispatchEvent("data", {data: data.toString("base64")}));
        socket.on("close", () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      async write(params, metadata) {
        await this._object.write(Buffer.from(params.data, "base64"));
      }
      async close(params, metadata) {
        this._object.close();
      }
    };
    exports2.AndroidSocketDispatcher = AndroidSocketDispatcher;
    var keyMap = new Map([
      ["Unknown", 0],
      ["SoftLeft", 1],
      ["SoftRight", 2],
      ["Home", 3],
      ["Back", 4],
      ["Call", 5],
      ["EndCall", 6],
      ["0", 7],
      ["1", 8],
      ["2", 9],
      ["3", 10],
      ["4", 11],
      ["5", 12],
      ["6", 13],
      ["7", 14],
      ["8", 15],
      ["9", 16],
      ["Star", 17],
      ["*", 17],
      ["Pound", 18],
      ["#", 18],
      ["DialUp", 19],
      ["DialDown", 20],
      ["DialLeft", 21],
      ["DialRight", 22],
      ["DialCenter", 23],
      ["VolumeUp", 24],
      ["VolumeDown", 25],
      ["Power", 26],
      ["Camera", 27],
      ["Clear", 28],
      ["A", 29],
      ["B", 30],
      ["C", 31],
      ["D", 32],
      ["E", 33],
      ["F", 34],
      ["G", 35],
      ["H", 36],
      ["I", 37],
      ["J", 38],
      ["K", 39],
      ["L", 40],
      ["M", 41],
      ["N", 42],
      ["O", 43],
      ["P", 44],
      ["Q", 45],
      ["R", 46],
      ["S", 47],
      ["T", 48],
      ["U", 49],
      ["V", 50],
      ["W", 51],
      ["X", 52],
      ["Y", 53],
      ["Z", 54],
      ["Comma", 55],
      [",", 55],
      ["Period", 56],
      [".", 56],
      ["AltLeft", 57],
      ["AltRight", 58],
      ["ShiftLeft", 59],
      ["ShiftRight", 60],
      ["Tab", 61],
      ["	", 61],
      ["Space", 62],
      [" ", 62],
      ["Sym", 63],
      ["Explorer", 64],
      ["Envelop", 65],
      ["Enter", 66],
      ["Del", 67],
      ["Grave", 68],
      ["Minus", 69],
      ["-", 69],
      ["Equals", 70],
      ["=", 70],
      ["LeftBracket", 71],
      ["(", 71],
      ["RightBracket", 72],
      [")", 72],
      ["Backslash", 73],
      ["\\", 73],
      ["Semicolon", 74],
      [";", 74],
      ["Apostrophe", 75],
      ["`", 75],
      ["Slash", 76],
      ["/", 76],
      ["At", 77],
      ["@", 77],
      ["Num", 78],
      ["HeadsetHook", 79],
      ["Focus", 80],
      ["Plus", 81],
      ["Menu", 82],
      ["Notification", 83],
      ["Search", 84],
      ["AppSwitch", 187],
      ["Assist", 219],
      ["Cut", 277],
      ["Copy", 278],
      ["Paste", 279]
    ]);
  }
});

// node_modules/playwright/lib/dispatchers/browserDispatcher.js
var require_browserDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/browserDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BrowserDispatcher = void 0;
    var browser_1 = require_browser2();
    var browserContextDispatcher_1 = require_browserContextDispatcher();
    var cdpSessionDispatcher_1 = require_cdpSessionDispatcher();
    var dispatcher_1 = require_dispatcher();
    var BrowserDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, browser) {
        super(scope, browser, "Browser", {version: browser.version(), name: browser.options.name}, true);
        browser.on(browser_1.Browser.Events.Disconnected, () => this._didClose());
      }
      _didClose() {
        this._dispatchEvent("close");
        this._dispose();
      }
      async newContext(params, metadata) {
        const context = await this._object.newContext(params);
        if (params.storageState)
          await context.setStorageState(metadata, params.storageState);
        return {context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, context)};
      }
      async close() {
        await this._object.close();
      }
      async killForTests() {
        await this._object.killForTests();
      }
      async newBrowserCDPSession() {
        if (!this._object.options.isChromium)
          throw new Error(`CDP session is only available in Chromium`);
        const crBrowser = this._object;
        return {session: new cdpSessionDispatcher_1.CDPSessionDispatcher(this._scope, await crBrowser.newBrowserCDPSession())};
      }
      async startTracing(params) {
        if (!this._object.options.isChromium)
          throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        await crBrowser.startTracing(params.page ? params.page._object : void 0, params);
      }
      async stopTracing() {
        if (!this._object.options.isChromium)
          throw new Error(`Tracing is only available in Chromium`);
        const crBrowser = this._object;
        const buffer = await crBrowser.stopTracing();
        return {binary: buffer.toString("base64")};
      }
    };
    exports2.BrowserDispatcher = BrowserDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/browserTypeDispatcher.js
var require_browserTypeDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/browserTypeDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BrowserTypeDispatcher = void 0;
    var browserDispatcher_1 = require_browserDispatcher();
    var dispatcher_1 = require_dispatcher();
    var browserContextDispatcher_1 = require_browserContextDispatcher();
    var BrowserTypeDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, browserType) {
        super(scope, browserType, "BrowserType", {
          executablePath: browserType.executablePath(),
          name: browserType.name()
        }, true);
      }
      async launch(params, metadata) {
        const browser = await this._object.launch(metadata, params);
        return {browser: new browserDispatcher_1.BrowserDispatcher(this._scope, browser)};
      }
      async launchPersistentContext(params, metadata) {
        const browserContext = await this._object.launchPersistentContext(metadata, params.userDataDir, params);
        return {context: new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, browserContext)};
      }
      async connectOverCDP(params, metadata) {
        const browser = await this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);
        return {
          browser: new browserDispatcher_1.BrowserDispatcher(this._scope, browser),
          defaultContext: browser._defaultContext ? new browserContextDispatcher_1.BrowserContextDispatcher(this._scope, browser._defaultContext) : void 0
        };
      }
    };
    exports2.BrowserTypeDispatcher = BrowserTypeDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/electronDispatcher.js
var require_electronDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/electronDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ElectronApplicationDispatcher = exports2.ElectronDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var electron_1 = require_electron2();
    var browserContextDispatcher_1 = require_browserContextDispatcher();
    var jsHandleDispatcher_1 = require_jsHandleDispatcher();
    var elementHandlerDispatcher_1 = require_elementHandlerDispatcher();
    var ElectronDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, electron) {
        super(scope, electron, "Electron", {}, true);
      }
      async launch(params) {
        const electronApplication = await this._object.launch(params);
        return {electronApplication: new ElectronApplicationDispatcher(this._scope, electronApplication)};
      }
    };
    exports2.ElectronDispatcher = ElectronDispatcher;
    var ElectronApplicationDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, electronApplication) {
        super(scope, electronApplication, "ElectronApplication", {
          context: new browserContextDispatcher_1.BrowserContextDispatcher(scope, electronApplication.context())
        }, true);
        electronApplication.on(electron_1.ElectronApplication.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      async browserWindow(params) {
        const handle = await this._object.browserWindow(params.page.page());
        return {handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, handle)};
      }
      async evaluateExpression(params) {
        const handle = await this._object._nodeElectronHandlePromise;
        return {value: jsHandleDispatcher_1.serializeResult(await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, jsHandleDispatcher_1.parseArgument(params.arg)))};
      }
      async evaluateExpressionHandle(params) {
        const handle = await this._object._nodeElectronHandlePromise;
        const result = await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, jsHandleDispatcher_1.parseArgument(params.arg));
        return {handle: elementHandlerDispatcher_1.ElementHandleDispatcher.fromJSHandle(this._scope, result)};
      }
      async close() {
        await this._object.close();
      }
    };
    exports2.ElectronApplicationDispatcher = ElectronApplicationDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/selectorsDispatcher.js
var require_selectorsDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/selectorsDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.SelectorsDispatcher = void 0;
    var dispatcher_1 = require_dispatcher();
    var SelectorsDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, selectors2) {
        super(scope, selectors2, "Selectors", {});
      }
      async register(params) {
        await this._object.register(params.name, params.source, params.contentScript);
      }
    };
    exports2.SelectorsDispatcher = SelectorsDispatcher;
  }
});

// node_modules/playwright/lib/dispatchers/playwrightDispatcher.js
var require_playwrightDispatcher = __commonJS({
  "node_modules/playwright/lib/dispatchers/playwrightDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.PlaywrightDispatcher = void 0;
    var androidDispatcher_1 = require_androidDispatcher();
    var browserTypeDispatcher_1 = require_browserTypeDispatcher();
    var dispatcher_1 = require_dispatcher();
    var electronDispatcher_1 = require_electronDispatcher();
    var selectorsDispatcher_1 = require_selectorsDispatcher();
    var PlaywrightDispatcher = class extends dispatcher_1.Dispatcher {
      constructor(scope, playwright2, customSelectors, preLaunchedBrowser) {
        const descriptors = require_deviceDescriptors();
        const deviceDescriptors = Object.entries(descriptors).map(([name, descriptor]) => ({name, descriptor}));
        super(scope, playwright2, "Playwright", {
          chromium: new browserTypeDispatcher_1.BrowserTypeDispatcher(scope, playwright2.chromium),
          firefox: new browserTypeDispatcher_1.BrowserTypeDispatcher(scope, playwright2.firefox),
          webkit: new browserTypeDispatcher_1.BrowserTypeDispatcher(scope, playwright2.webkit),
          android: new androidDispatcher_1.AndroidDispatcher(scope, playwright2.android),
          electron: new electronDispatcher_1.ElectronDispatcher(scope, playwright2.electron),
          deviceDescriptors,
          selectors: customSelectors || new selectorsDispatcher_1.SelectorsDispatcher(scope, playwright2.selectors),
          preLaunchedBrowser
        }, false);
      }
    };
    exports2.PlaywrightDispatcher = PlaywrightDispatcher;
  }
});

// node_modules/playwright/lib/client/events.js
var require_events = __commonJS({
  "node_modules/playwright/lib/client/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Events = void 0;
    exports2.Events = {
      AndroidDevice: {
        WebView: "webview",
        Close: "close"
      },
      AndroidSocket: {
        Data: "data",
        Close: "close"
      },
      AndroidWebView: {
        Close: "close"
      },
      Browser: {
        Disconnected: "disconnected"
      },
      BrowserContext: {
        Close: "close",
        Page: "page",
        BackgroundPage: "backgroundpage",
        ServiceWorker: "serviceworker"
      },
      BrowserServer: {
        Close: "close"
      },
      Page: {
        Close: "close",
        Crash: "crash",
        Console: "console",
        Dialog: "dialog",
        Download: "download",
        FileChooser: "filechooser",
        DOMContentLoaded: "domcontentloaded",
        PageError: "pageerror",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished",
        FrameAttached: "frameattached",
        FrameDetached: "framedetached",
        FrameNavigated: "framenavigated",
        Load: "load",
        Popup: "popup",
        WebSocket: "websocket",
        Worker: "worker"
      },
      WebSocket: {
        Close: "close",
        Error: "socketerror",
        FrameReceived: "framereceived",
        FrameSent: "framesent"
      },
      Worker: {
        Close: "close"
      },
      ElectronApplication: {
        Close: "close",
        Window: "window"
      }
    };
  }
});

// node_modules/playwright/lib/client/accessibility.js
var require_accessibility2 = __commonJS({
  "node_modules/playwright/lib/client/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Accessibility = void 0;
    function axNodeFromProtocol(axNode) {
      const result = {
        ...axNode,
        value: axNode.valueNumber !== void 0 ? axNode.valueNumber : axNode.valueString,
        checked: axNode.checked === "checked" ? true : axNode.checked === "unchecked" ? false : axNode.checked,
        pressed: axNode.pressed === "pressed" ? true : axNode.pressed === "released" ? false : axNode.pressed,
        children: axNode.children ? axNode.children.map(axNodeFromProtocol) : void 0
      };
      delete result.valueNumber;
      delete result.valueString;
      return result;
    }
    var Accessibility = class {
      constructor(channel) {
        this._channel = channel;
      }
      async snapshot(options2 = {}) {
        const root = options2.root ? options2.root._elementChannel : void 0;
        const result = await this._channel.accessibilitySnapshot({interestingOnly: options2.interestingOnly, root});
        return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
      }
    };
    exports2.Accessibility = Accessibility;
  }
});

// node_modules/playwright/lib/client/channelOwner.js
var require_channelOwner = __commonJS({
  "node_modules/playwright/lib/client/channelOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ChannelOwner = void 0;
    var events_1 = require("events");
    var validator_1 = require_validator();
    var debugLogger_1 = require_debugLogger();
    var stackTrace_1 = require_stackTrace();
    var ChannelOwner = class extends events_1.EventEmitter {
      constructor(parent, type, guid, initializer) {
        super();
        this._objects = new Map();
        this.setMaxListeners(0);
        this._connection = parent instanceof ChannelOwner ? parent._connection : parent;
        this._type = type;
        this._guid = guid;
        this._parent = parent instanceof ChannelOwner ? parent : void 0;
        this._connection._objects.set(guid, this);
        if (this._parent) {
          this._parent._objects.set(guid, this);
          this._logger = this._parent._logger;
        }
        this._channel = this._createChannel(new events_1.EventEmitter(), "");
        this._initializer = initializer;
      }
      _dispose() {
        if (this._parent)
          this._parent._objects.delete(this._guid);
        this._connection._objects.delete(this._guid);
        for (const object of [...this._objects.values()])
          object._dispose();
        this._objects.clear();
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
        };
      }
      _createChannel(base, apiName) {
        const channel = new Proxy(base, {
          get: (obj, prop) => {
            if (prop === "debugScopeState")
              return (params) => this._connection.sendMessageToServer(this._guid, prop, params, apiName);
            if (typeof prop === "string") {
              const validator = scheme[paramsName(this._type, prop)];
              if (validator)
                return (params) => this._connection.sendMessageToServer(this._guid, prop, validator(params, ""), apiName);
            }
            return obj[prop];
          }
        });
        channel._object = this;
        return channel;
      }
      async _wrapApiCall(apiName, func, logger) {
        logger = logger || this._logger;
        try {
          logApiCall(logger, `=> ${apiName} started`);
          const channel = this._createChannel({}, apiName);
          const result = await func(channel);
          logApiCall(logger, `<= ${apiName} succeeded`);
          return result;
        } catch (e) {
          logApiCall(logger, `<= ${apiName} failed`);
          stackTrace_1.rewriteErrorMessage(e, `${apiName}: ` + e.message);
          throw e;
        }
      }
      _waitForEventInfoBefore(waitId, apiName) {
        this._connection.sendMessageToServer(this._guid, "waitForEventInfo", {info: {apiName, waitId, phase: "before"}}, void 0).catch(() => {
        });
      }
      _waitForEventInfoAfter(waitId, error3) {
        this._connection.sendMessageToServer(this._guid, "waitForEventInfo", {info: {waitId, phase: "after", error: error3}}, void 0).catch(() => {
        });
      }
      _waitForEventInfoLog(waitId, message) {
        this._connection.sendMessageToServer(this._guid, "waitForEventInfo", {info: {waitId, phase: "log", message}}, void 0).catch(() => {
        });
      }
      toJSON() {
        return {
          _type: this._type,
          _guid: this._guid
        };
      }
    };
    exports2.ChannelOwner = ChannelOwner;
    function logApiCall(logger, message) {
      if (logger && logger.isEnabled("api", "info"))
        logger.log("api", "info", message, [], {color: "cyan"});
      debugLogger_1.debugLogger.log("api", message);
    }
    function paramsName(type, method) {
      return type + method[0].toUpperCase() + method.substring(1) + "Params";
    }
    var tChannel = (name) => {
      return (arg, path) => {
        if (arg._object instanceof ChannelOwner && (name === "*" || arg._object._type === name))
          return {guid: arg._object._guid};
        throw new validator_1.ValidationError(`${path}: expected ${name}`);
      };
    };
    var scheme = validator_1.createScheme(tChannel);
  }
});

// node_modules/playwright/lib/client/jsHandle.js
var require_jsHandle = __commonJS({
  "node_modules/playwright/lib/client/jsHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.assertMaxArguments = exports2.parseResult = exports2.serializeArgument = exports2.JSHandle = void 0;
    var channelOwner_1 = require_channelOwner();
    var serializers_1 = require_serializers();
    var JSHandle = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._preview = this._initializer.preview;
        this._channel.on("previewUpdated", ({preview}) => this._preview = preview);
      }
      static from(handle) {
        return handle._object;
      }
      async evaluate(pageFunction, arg) {
        return this._wrapApiCall("jsHandle.evaluate", async (channel) => {
          const result = await channel.evaluateExpression({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg)});
          return parseResult(result.value);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        return this._wrapApiCall("jsHandle.evaluateHandle", async (channel) => {
          const result = await channel.evaluateExpressionHandle({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg)});
          return JSHandle.from(result.handle);
        });
      }
      async getProperty(propertyName) {
        return this._wrapApiCall("jsHandle.getProperty", async (channel) => {
          const result = await channel.getProperty({name: propertyName});
          return JSHandle.from(result.handle);
        });
      }
      async getProperties() {
        return this._wrapApiCall("jsHandle.getProperties", async (channel) => {
          const map = new Map();
          for (const {name, value} of (await channel.getPropertyList()).properties)
            map.set(name, JSHandle.from(value));
          return map;
        });
      }
      async jsonValue() {
        return this._wrapApiCall("jsHandle.jsonValue", async (channel) => {
          return parseResult((await channel.jsonValue()).value);
        });
      }
      asElement() {
        return null;
      }
      async dispose() {
        return this._wrapApiCall("jsHandle.dispose", async (channel) => {
          return await channel.dispose();
        });
      }
      toString() {
        return this._preview;
      }
    };
    exports2.JSHandle = JSHandle;
    function serializeArgument(arg) {
      const handles = [];
      const pushHandle = (channel) => {
        handles.push(channel);
        return handles.length - 1;
      };
      const value = serializers_1.serializeValue(arg, (value2) => {
        if (value2 instanceof JSHandle)
          return {h: pushHandle(value2._channel)};
        return {fallThrough: value2};
      }, new Set());
      return {value, handles};
    }
    exports2.serializeArgument = serializeArgument;
    function parseResult(value) {
      return serializers_1.parseSerializedValue(value, void 0);
    }
    exports2.parseResult = parseResult;
    function assertMaxArguments(count, max) {
      if (count > max)
        throw new Error("Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.");
    }
    exports2.assertMaxArguments = assertMaxArguments;
  }
});

// node_modules/playwright/lib/client/consoleMessage.js
var require_consoleMessage = __commonJS({
  "node_modules/playwright/lib/client/consoleMessage.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ConsoleMessage = void 0;
    var util = __importStar(require("util"));
    var jsHandle_1 = require_jsHandle();
    var channelOwner_1 = require_channelOwner();
    var ConsoleMessage = class extends channelOwner_1.ChannelOwner {
      static from(message) {
        return message._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      text() {
        return this._initializer.text;
      }
      args() {
        return this._initializer.args.map(jsHandle_1.JSHandle.from);
      }
      location() {
        return this._initializer.location;
      }
      [util.inspect.custom]() {
        return this.text();
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright/lib/client/dialog.js
var require_dialog2 = __commonJS({
  "node_modules/playwright/lib/client/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Dialog = void 0;
    var channelOwner_1 = require_channelOwner();
    var Dialog = class extends channelOwner_1.ChannelOwner {
      static from(dialog) {
        return dialog._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      message() {
        return this._initializer.message;
      }
      defaultValue() {
        return this._initializer.defaultValue;
      }
      async accept(promptText) {
        return this._wrapApiCall("dialog.accept", async (channel) => {
          await channel.accept({promptText});
        });
      }
      async dismiss() {
        return this._wrapApiCall("dialog.dismiss", async (channel) => {
          await channel.dismiss();
        });
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright/lib/client/download.js
var require_download2 = __commonJS({
  "node_modules/playwright/lib/client/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Download = void 0;
    var Download = class {
      constructor(url, suggestedFilename, artifact) {
        this._url = url;
        this._suggestedFilename = suggestedFilename;
        this._artifact = artifact;
      }
      url() {
        return this._url;
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
      async path() {
        return this._artifact.pathAfterFinished();
      }
      async saveAs(path) {
        return this._artifact.saveAs(path);
      }
      async failure() {
        return this._artifact.failure();
      }
      async createReadStream() {
        return this._artifact.createReadStream();
      }
      async delete() {
        return this._artifact.delete();
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = Object.create(null);
      this._extensions = Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = {"application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma", "es"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/mrb-consumer+xml": ["*xdf"], "application/mrb-publish+xml": ["*xdf"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["*xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-error+xml": ["xer"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"]};
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports2, module2) {
    module2.exports = {"application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"]};
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/playwright/lib/client/waiter.js
var require_waiter = __commonJS({
  "node_modules/playwright/lib/client/waiter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Waiter = void 0;
    var stackTrace_1 = require_stackTrace();
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    var Waiter = class {
      constructor(channelOwner, apiName) {
        this._failures = [];
        this._logs = [];
        this._waitId = utils_1.createGuid();
        this._channelOwner = channelOwner;
        this._channelOwner._waitForEventInfoBefore(this._waitId, apiName);
        this._dispose = [
          () => this._channelOwner._waitForEventInfoAfter(this._waitId, this._error)
        ];
      }
      static createForEvent(channelOwner, target, event) {
        return new Waiter(channelOwner, `${target}.waitForEvent(${event})`);
      }
      async waitForEvent(emitter, event, predicate) {
        const {promise, dispose} = waitForEvent(emitter, event, predicate);
        return this.waitForPromise(promise, dispose);
      }
      rejectOnEvent(emitter, event, error3, predicate) {
        const {promise, dispose} = waitForEvent(emitter, event, predicate);
        this._rejectOn(promise.then(() => {
          throw error3;
        }), dispose);
      }
      rejectOnTimeout(timeout, message) {
        if (!timeout)
          return;
        const {promise, dispose} = waitForTimeout(timeout);
        this._rejectOn(promise.then(() => {
          throw new errors_1.TimeoutError(message);
        }), dispose);
      }
      dispose() {
        for (const dispose of this._dispose)
          dispose();
      }
      async waitForPromise(promise, dispose) {
        try {
          const result = await Promise.race([promise, ...this._failures]);
          if (dispose)
            dispose();
          return result;
        } catch (e) {
          if (dispose)
            dispose();
          this._error = e.message;
          this.dispose();
          stackTrace_1.rewriteErrorMessage(e, e.message + formatLogRecording(this._logs) + kLoggingNote);
          throw e;
        }
      }
      log(s2) {
        this._logs.push(s2);
        this._channelOwner._waitForEventInfoLog(this._waitId, s2);
      }
      _rejectOn(promise, dispose) {
        this._failures.push(promise);
        if (dispose)
          this._dispose.push(dispose);
      }
    };
    exports2.Waiter = Waiter;
    function waitForEvent(emitter, event, predicate) {
      let listener;
      const promise = new Promise((resolve2, reject) => {
        listener = async (eventArg) => {
          try {
            if (predicate && !await predicate(eventArg))
              return;
            emitter.removeListener(event, listener);
            resolve2(eventArg);
          } catch (e) {
            emitter.removeListener(event, listener);
            reject(e);
          }
        };
        emitter.addListener(event, listener);
      });
      const dispose = () => emitter.removeListener(event, listener);
      return {promise, dispose};
    }
    function waitForTimeout(timeout) {
      let timeoutId;
      const promise = new Promise((resolve2) => timeoutId = setTimeout(resolve2, timeout));
      const dispose = () => clearTimeout(timeoutId);
      return {promise, dispose};
    }
    var kLoggingNote = `
Note: use DEBUG=pw:api environment variable to capture Playwright logs.`;
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
  }
});

// node_modules/playwright/lib/client/network.js
var require_network2 = __commonJS({
  "node_modules/playwright/lib/client/network.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.validateHeaders = exports2.WebSocket = exports2.Response = exports2.Route = exports2.Request = void 0;
    var url_1 = require("url");
    var channelOwner_1 = require_channelOwner();
    var frame_1 = require_frame();
    var fs_1 = __importDefault(require("fs"));
    var mime = __importStar(require_mime());
    var util = __importStar(require("util"));
    var utils_1 = require_utils();
    var events_1 = require_events();
    var waiter_1 = require_waiter();
    var Request2 = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._redirectedFrom = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._redirectedFrom = Request2.fromNullable(initializer.redirectedFrom);
        if (this._redirectedFrom)
          this._redirectedFrom._redirectedTo = this;
        this._headers = utils_1.headersArrayToObject(initializer.headers, true);
        this._postData = initializer.postData ? Buffer.from(initializer.postData, "base64") : null;
        this._timing = {
          startTime: 0,
          domainLookupStart: -1,
          domainLookupEnd: -1,
          connectStart: -1,
          secureConnectionStart: -1,
          connectEnd: -1,
          requestStart: -1,
          responseStart: -1,
          responseEnd: -1
        };
      }
      static from(request) {
        return request._object;
      }
      static fromNullable(request) {
        return request ? Request2.from(request) : null;
      }
      url() {
        return this._initializer.url;
      }
      resourceType() {
        return this._initializer.resourceType;
      }
      method() {
        return this._initializer.method;
      }
      postData() {
        return this._postData ? this._postData.toString("utf8") : null;
      }
      postDataBuffer() {
        return this._postData;
      }
      postDataJSON() {
        const postData = this.postData();
        if (!postData)
          return null;
        const contentType = this.headers()["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          const entries = {};
          const parsed = new url_1.URLSearchParams(postData);
          for (const [k, v] of parsed.entries())
            entries[k] = v;
          return entries;
        }
        try {
          return JSON.parse(postData);
        } catch (e) {
          throw new Error("POST data is not a valid JSON object: " + postData);
        }
      }
      headers() {
        return {...this._headers};
      }
      async response() {
        return this._wrapApiCall("request.response", async (channel) => {
          return Response3.fromNullable((await channel.response()).response);
        });
      }
      frame() {
        return frame_1.Frame.from(this._initializer.frame);
      }
      isNavigationRequest() {
        return this._initializer.isNavigationRequest;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      redirectedTo() {
        return this._redirectedTo;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      timing() {
        return this._timing;
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
    };
    exports2.Request = Request2;
    var Route = class extends channelOwner_1.ChannelOwner {
      static from(route) {
        return route._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      request() {
        return Request2.from(this._initializer.request);
      }
      async abort(errorCode) {
        return this._wrapApiCall("route.abort", async (channel) => {
          await channel.abort({errorCode});
        });
      }
      async fulfill(options2 = {}) {
        return this._wrapApiCall("route.fulfill", async (channel) => {
          let body = "";
          let isBase64 = false;
          let length = 0;
          if (options2.path) {
            const buffer = await util.promisify(fs_1.default.readFile)(options2.path);
            body = buffer.toString("base64");
            isBase64 = true;
            length = buffer.length;
          } else if (utils_1.isString(options2.body)) {
            body = options2.body;
            isBase64 = false;
            length = Buffer.byteLength(body);
          } else if (options2.body) {
            body = options2.body.toString("base64");
            isBase64 = true;
            length = options2.body.length;
          }
          const headers = {};
          for (const header of Object.keys(options2.headers || {}))
            headers[header.toLowerCase()] = String(options2.headers[header]);
          if (options2.contentType)
            headers["content-type"] = String(options2.contentType);
          else if (options2.path)
            headers["content-type"] = mime.getType(options2.path) || "application/octet-stream";
          if (length && !("content-length" in headers))
            headers["content-length"] = String(length);
          await channel.fulfill({
            status: options2.status || 200,
            headers: utils_1.headersObjectToArray(headers),
            body,
            isBase64
          });
        });
      }
      async continue(options2 = {}) {
        return this._wrapApiCall("route.continue", async (channel) => {
          const postDataBuffer = utils_1.isString(options2.postData) ? Buffer.from(options2.postData, "utf8") : options2.postData;
          await channel.continue({
            url: options2.url,
            method: options2.method,
            headers: options2.headers ? utils_1.headersObjectToArray(options2.headers) : void 0,
            postData: postDataBuffer ? postDataBuffer.toString("base64") : void 0
          });
        });
      }
    };
    exports2.Route = Route;
    var Response3 = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._headers = utils_1.headersArrayToObject(initializer.headers, true);
        this._request = Request2.from(this._initializer.request);
        this._request._headers = utils_1.headersArrayToObject(initializer.requestHeaders, true);
        Object.assign(this._request._timing, this._initializer.timing);
      }
      static from(response) {
        return response._object;
      }
      static fromNullable(response) {
        return response ? Response3.from(response) : null;
      }
      url() {
        return this._initializer.url;
      }
      ok() {
        return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return {...this._headers};
      }
      async finished() {
        const result = await this._channel.finished();
        if (result.error)
          return new Error(result.error);
        return null;
      }
      async body() {
        return this._wrapApiCall("response.body", async (channel) => {
          return Buffer.from((await channel.body()).binary, "base64");
        });
      }
      async text() {
        const content = await this.body();
        return content.toString("utf8");
      }
      async json() {
        const content = await this.text();
        return JSON.parse(content);
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
    };
    exports2.Response = Response3;
    var WebSocket = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._isClosed = false;
        this._page = parent;
        this._channel.on("frameSent", (event) => {
          const payload = event.opcode === 2 ? Buffer.from(event.data, "base64") : event.data;
          this.emit(events_1.Events.WebSocket.FrameSent, {payload});
        });
        this._channel.on("frameReceived", (event) => {
          const payload = event.opcode === 2 ? Buffer.from(event.data, "base64") : event.data;
          this.emit(events_1.Events.WebSocket.FrameReceived, {payload});
        });
        this._channel.on("socketError", ({error: error3}) => this.emit(events_1.Events.WebSocket.Error, error3));
        this._channel.on("close", () => {
          this._isClosed = true;
          this.emit(events_1.Events.WebSocket.Close, this);
        });
      }
      static from(webSocket) {
        return webSocket._object;
      }
      url() {
        return this._initializer.url;
      }
      isClosed() {
        return this._isClosed;
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, "webSocket", event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.WebSocket.Error)
          waiter.rejectOnEvent(this, events_1.Events.WebSocket.Error, new Error("Socket error"));
        if (event !== events_1.Events.WebSocket.Close)
          waiter.rejectOnEvent(this, events_1.Events.WebSocket.Close, new Error("Socket closed"));
        waiter.rejectOnEvent(this._page, events_1.Events.Page.Close, new Error("Page closed"));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
      }
    };
    exports2.WebSocket = WebSocket;
    function validateHeaders(headers) {
      for (const key of Object.keys(headers)) {
        const value = headers[key];
        if (!Object.is(value, void 0) && !utils_1.isString(value))
          throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      }
    }
    exports2.validateHeaders = validateHeaders;
  }
});

// node_modules/playwright/lib/client/types.js
var require_types2 = __commonJS({
  "node_modules/playwright/lib/client/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.kLifecycleEvents = void 0;
    exports2.kLifecycleEvents = new Set(["load", "domcontentloaded", "networkidle"]);
  }
});

// node_modules/playwright/lib/client/clientHelper.js
var require_clientHelper = __commonJS({
  "node_modules/playwright/lib/client/clientHelper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.globToRegex = exports2.urlMatches = exports2.parsedURL = exports2.evaluationScript = exports2.envObjectToArray = exports2.deprecate = void 0;
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var utils_1 = require_utils();
    var deprecatedHits = new Set();
    function deprecate(methodName, message) {
      if (deprecatedHits.has(methodName))
        return;
      deprecatedHits.add(methodName);
      console.warn(message);
    }
    exports2.deprecate = deprecate;
    function envObjectToArray(env2) {
      const result = [];
      for (const name in env2) {
        if (!Object.is(env2[name], void 0))
          result.push({name, value: String(env2[name])});
      }
      return result;
    }
    exports2.envObjectToArray = envObjectToArray;
    async function evaluationScript(fun, arg, addSourceUrl = true) {
      if (typeof fun === "function") {
        const source = fun.toString();
        const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
        return `(${source})(${argString})`;
      }
      if (arg !== void 0)
        throw new Error("Cannot evaluate a string with arguments");
      if (utils_1.isString(fun))
        return fun;
      if (fun.content !== void 0)
        return fun.content;
      if (fun.path !== void 0) {
        let source = await util.promisify(fs_1.default.readFile)(fun.path, "utf8");
        if (addSourceUrl)
          source += "//# sourceURL=" + fun.path.replace(/\n/g, "");
        return source;
      }
      throw new Error("Either path or content property must be present");
    }
    exports2.evaluationScript = evaluationScript;
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    exports2.parsedURL = parsedURL;
    function urlMatches(urlString, match) {
      if (match === void 0 || match === "")
        return true;
      if (utils_1.isString(match))
        match = globToRegex(match);
      if (utils_1.isRegExp(match))
        return match.test(urlString);
      if (typeof match === "string" && match === urlString)
        return true;
      const url = parsedURL(urlString);
      if (!url)
        return false;
      if (typeof match === "string")
        return url.pathname === match;
      if (typeof match !== "function")
        throw new Error("url parameter should be string, RegExp or function");
      return match(url);
    }
    exports2.urlMatches = urlMatches;
    var escapeGlobChars = new Set(["/", "$", "^", "+", ".", "(", ")", "=", "!", "|"]);
    function globToRegex(glob) {
      const tokens = ["^"];
      let inGroup;
      for (let i = 0; i < glob.length; ++i) {
        const c = glob[i];
        if (escapeGlobChars.has(c)) {
          tokens.push("\\" + c);
          continue;
        }
        if (c === "*") {
          const beforeDeep = glob[i - 1];
          let starCount = 1;
          while (glob[i + 1] === "*") {
            starCount++;
            i++;
          }
          const afterDeep = glob[i + 1];
          const isDeep = starCount > 1 && (beforeDeep === "/" || beforeDeep === void 0) && (afterDeep === "/" || afterDeep === void 0);
          if (isDeep) {
            tokens.push("((?:[^/]*(?:/|$))*)");
            i++;
          } else {
            tokens.push("([^/]*)");
          }
          continue;
        }
        switch (c) {
          case "?":
            tokens.push(".");
            break;
          case "{":
            inGroup = true;
            tokens.push("(");
            break;
          case "}":
            inGroup = false;
            tokens.push(")");
            break;
          case ",":
            if (inGroup) {
              tokens.push("|");
              break;
            }
            tokens.push("\\" + c);
            break;
          default:
            tokens.push(c);
        }
      }
      tokens.push("$");
      return new RegExp(tokens.join(""));
    }
    exports2.globToRegex = globToRegex;
  }
});

// node_modules/playwright/lib/client/frame.js
var require_frame = __commonJS({
  "node_modules/playwright/lib/client/frame.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.verifyLoadState = exports2.Frame = void 0;
    var utils_1 = require_utils();
    var channelOwner_1 = require_channelOwner();
    var elementHandle_1 = require_elementHandle();
    var jsHandle_1 = require_jsHandle();
    var fs_1 = __importDefault(require("fs"));
    var network = __importStar(require_network2());
    var util = __importStar(require("util"));
    var events_1 = require("events");
    var waiter_1 = require_waiter();
    var events_2 = require_events();
    var types_1 = require_types2();
    var clientHelper_1 = require_clientHelper();
    var fsReadFileAsync = util.promisify(fs_1.default.readFile.bind(fs_1.default));
    var Frame = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._parentFrame = null;
        this._url = "";
        this._name = "";
        this._detached = false;
        this._childFrames = new Set();
        this._eventEmitter = new events_1.EventEmitter();
        this._eventEmitter.setMaxListeners(0);
        this._parentFrame = Frame.fromNullable(initializer.parentFrame);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._name = initializer.name;
        this._url = initializer.url;
        this._loadStates = new Set(initializer.loadStates);
        this._channel.on("loadstate", (event) => {
          if (event.add) {
            this._loadStates.add(event.add);
            this._eventEmitter.emit("loadstate", event.add);
          }
          if (event.remove)
            this._loadStates.delete(event.remove);
        });
        this._channel.on("navigated", (event) => {
          this._url = event.url;
          this._name = event.name;
          this._eventEmitter.emit("navigated", event);
          if (!event.error && this._page)
            this._page.emit(events_2.Events.Page.FrameNavigated, this);
        });
      }
      static from(frame) {
        return frame._object;
      }
      static fromNullable(frame) {
        return frame ? Frame.from(frame) : null;
      }
      _apiName(method) {
        return this._page._isPageCall ? "page." + method : "frame." + method;
      }
      page() {
        return this._page;
      }
      async goto(url, options2 = {}) {
        return this._wrapApiCall(this._apiName("goto"), async (channel) => {
          const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return network.Response.fromNullable((await channel.goto({url, ...options2, waitUntil})).response);
        });
      }
      _setupNavigationWaiter(name, options2) {
        const waiter = new waiter_1.Waiter(this, name);
        waiter.rejectOnEvent(this._page, events_2.Events.Page.Close, new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, events_2.Events.Page.Crash, new Error("Navigation failed because page crashed!"));
        waiter.rejectOnEvent(this._page, events_2.Events.Page.FrameDetached, new Error("Navigating frame was detached!"), (frame) => frame === this);
        const timeout = this._page._timeoutSettings.navigationTimeout(options2);
        waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
        return waiter;
      }
      async waitForNavigation(options2 = {}) {
        return this._wrapApiCall(this._apiName("waitForNavigation"), async (channel) => {
          const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          const waiter = this._setupNavigationWaiter(this._apiName("waitForNavigation"), options2);
          const toUrl = typeof options2.url === "string" ? ` to "${options2.url}"` : "";
          waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
          const navigatedEvent = await waiter.waitForEvent(this._eventEmitter, "navigated", (event) => {
            if (event.error)
              return true;
            waiter.log(`  navigated to "${event.url}"`);
            return clientHelper_1.urlMatches(event.url, options2.url);
          });
          if (navigatedEvent.error) {
            const e = new Error(navigatedEvent.error);
            e.stack = "";
            await waiter.waitForPromise(Promise.reject(e));
          }
          if (!this._loadStates.has(waitUntil)) {
            await waiter.waitForEvent(this._eventEmitter, "loadstate", (s2) => {
              waiter.log(`  "${s2}" event fired`);
              return s2 === waitUntil;
            });
          }
          const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;
          const response = request ? await waiter.waitForPromise(request._finalRequest().response()) : null;
          waiter.dispose();
          return response;
        });
      }
      async waitForLoadState(state = "load", options2 = {}) {
        state = verifyLoadState("state", state);
        if (this._loadStates.has(state))
          return;
        return this._wrapApiCall(this._apiName("waitForLoadState"), async (channel) => {
          const waiter = this._setupNavigationWaiter(this._apiName("waitForLoadState"), options2);
          await waiter.waitForEvent(this._eventEmitter, "loadstate", (s2) => {
            waiter.log(`  "${s2}" event fired`);
            return s2 === state;
          });
          waiter.dispose();
        });
      }
      async waitForURL(url, options2 = {}) {
        if (clientHelper_1.urlMatches(this.url(), url))
          return await this.waitForLoadState(options2 === null || options2 === void 0 ? void 0 : options2.waitUntil, options2);
        await this.waitForNavigation({url, ...options2});
      }
      async frameElement() {
        return this._wrapApiCall(this._apiName("frameElement"), async (channel) => {
          return elementHandle_1.ElementHandle.from((await channel.frameElement()).element);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall(this._apiName("evaluateHandle"), async (channel) => {
          const result = await channel.evaluateExpressionHandle({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.JSHandle.from(result.handle);
        });
      }
      async _evaluateHandleInUtility(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall(this._apiName("_evaluateHandleInUtility"), async (channel) => {
          const result = await channel.evaluateExpressionHandle({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg), world: "utility"});
          return jsHandle_1.JSHandle.from(result.handle);
        });
      }
      async evaluate(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall(this._apiName("evaluate"), async (channel) => {
          const result = await channel.evaluateExpression({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async _evaluateInUtility(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall(this._apiName("evaluate"), async (channel) => {
          const result = await channel.evaluateExpression({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg), world: "utility"});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async $(selector) {
        return this._wrapApiCall(this._apiName("$"), async (channel) => {
          const result = await channel.querySelector({selector});
          return elementHandle_1.ElementHandle.fromNullable(result.element);
        });
      }
      async waitForSelector(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("waitForSelector"), async (channel) => {
          if (options2.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options2.waitFor && options2.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const result = await channel.waitForSelector({selector, ...options2});
          return elementHandle_1.ElementHandle.fromNullable(result.element);
        });
      }
      async dispatchEvent(selector, type, eventInit, options2 = {}) {
        return this._wrapApiCall(this._apiName("dispatchEvent"), async (channel) => {
          await channel.dispatchEvent({selector, type, eventInit: jsHandle_1.serializeArgument(eventInit), ...options2});
        });
      }
      async $eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._wrapApiCall(this._apiName("$eval"), async (channel) => {
          const result = await channel.evalOnSelector({selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async $$eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._wrapApiCall(this._apiName("$$eval"), async (channel) => {
          const result = await channel.evalOnSelectorAll({selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async $$(selector) {
        return this._wrapApiCall(this._apiName("$$"), async (channel) => {
          const result = await channel.querySelectorAll({selector});
          return result.elements.map((e) => elementHandle_1.ElementHandle.from(e));
        });
      }
      async content() {
        return this._wrapApiCall(this._apiName("content"), async (channel) => {
          return (await channel.content()).value;
        });
      }
      async setContent(html, options2 = {}) {
        return this._wrapApiCall(this._apiName("setContent"), async (channel) => {
          const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          await channel.setContent({html, ...options2, waitUntil});
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      isDetached() {
        return this._detached;
      }
      async addScriptTag(options2 = {}) {
        return this._wrapApiCall(this._apiName("addScriptTag"), async (channel) => {
          const copy = {...options2};
          if (copy.path) {
            copy.content = (await fsReadFileAsync(copy.path)).toString();
            copy.content += "//# sourceURL=" + copy.path.replace(/\n/g, "");
          }
          return elementHandle_1.ElementHandle.from((await channel.addScriptTag({...copy})).element);
        });
      }
      async addStyleTag(options2 = {}) {
        return this._wrapApiCall(this._apiName("addStyleTag"), async (channel) => {
          const copy = {...options2};
          if (copy.path) {
            copy.content = (await fsReadFileAsync(copy.path)).toString();
            copy.content += "/*# sourceURL=" + copy.path.replace(/\n/g, "") + "*/";
          }
          return elementHandle_1.ElementHandle.from((await channel.addStyleTag({...copy})).element);
        });
      }
      async click(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("click"), async (channel) => {
          return await channel.click({selector, ...options2});
        });
      }
      async dblclick(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("dblclick"), async (channel) => {
          return await channel.dblclick({selector, ...options2});
        });
      }
      async tap(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("tap"), async (channel) => {
          return await channel.tap({selector, ...options2});
        });
      }
      async fill(selector, value, options2 = {}) {
        return this._wrapApiCall(this._apiName("fill"), async (channel) => {
          return await channel.fill({selector, value, ...options2});
        });
      }
      async focus(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("focus"), async (channel) => {
          await channel.focus({selector, ...options2});
        });
      }
      async textContent(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("textContent"), async (channel) => {
          const value = (await channel.textContent({selector, ...options2})).value;
          return value === void 0 ? null : value;
        });
      }
      async innerText(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("innerText"), async (channel) => {
          return (await channel.innerText({selector, ...options2})).value;
        });
      }
      async innerHTML(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("innerHTML"), async (channel) => {
          return (await channel.innerHTML({selector, ...options2})).value;
        });
      }
      async getAttribute(selector, name, options2 = {}) {
        return this._wrapApiCall(this._apiName("getAttribute"), async (channel) => {
          const value = (await channel.getAttribute({selector, name, ...options2})).value;
          return value === void 0 ? null : value;
        });
      }
      async isChecked(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("isChecked"), async (channel) => {
          return (await channel.isChecked({selector, ...options2})).value;
        });
      }
      async isDisabled(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("isDisabled"), async (channel) => {
          return (await channel.isDisabled({selector, ...options2})).value;
        });
      }
      async isEditable(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("isEditable"), async (channel) => {
          return (await channel.isEditable({selector, ...options2})).value;
        });
      }
      async isEnabled(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("isEnabled"), async (channel) => {
          return (await channel.isEnabled({selector, ...options2})).value;
        });
      }
      async isHidden(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("isHidden"), async (channel) => {
          return (await channel.isHidden({selector, ...options2})).value;
        });
      }
      async isVisible(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("isVisible"), async (channel) => {
          return (await channel.isVisible({selector, ...options2})).value;
        });
      }
      async hover(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("hover"), async (channel) => {
          await channel.hover({selector, ...options2});
        });
      }
      async selectOption(selector, values, options2 = {}) {
        return this._wrapApiCall(this._apiName("selectOption"), async (channel) => {
          return (await channel.selectOption({selector, ...elementHandle_1.convertSelectOptionValues(values), ...options2})).values;
        });
      }
      async setInputFiles(selector, files, options2 = {}) {
        return this._wrapApiCall(this._apiName("setInputFiles"), async (channel) => {
          await channel.setInputFiles({selector, files: await elementHandle_1.convertInputFiles(files), ...options2});
        });
      }
      async type(selector, text, options2 = {}) {
        return this._wrapApiCall(this._apiName("type"), async (channel) => {
          await channel.type({selector, text, ...options2});
        });
      }
      async press(selector, key, options2 = {}) {
        return this._wrapApiCall(this._apiName("press"), async (channel) => {
          await channel.press({selector, key, ...options2});
        });
      }
      async check(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("check"), async (channel) => {
          await channel.check({selector, ...options2});
        });
      }
      async uncheck(selector, options2 = {}) {
        return this._wrapApiCall(this._apiName("uncheck"), async (channel) => {
          await channel.uncheck({selector, ...options2});
        });
      }
      async waitForTimeout(timeout) {
        return this._wrapApiCall(this._apiName("waitForTimeout"), async (channel) => {
          await new Promise((fulfill) => setTimeout(fulfill, timeout));
        });
      }
      async waitForFunction(pageFunction, arg, options2 = {}) {
        return this._wrapApiCall(this._apiName("waitForFunction"), async (channel) => {
          if (typeof options2.polling === "string")
            utils_1.assert(options2.polling === "raf", "Unknown polling option: " + options2.polling);
          const result = await channel.waitForFunction({
            ...options2,
            pollingInterval: options2.polling === "raf" ? void 0 : options2.polling,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: jsHandle_1.serializeArgument(arg)
          });
          return jsHandle_1.JSHandle.from(result.handle);
        });
      }
      async title() {
        return this._wrapApiCall(this._apiName("title"), async (channel) => {
          return (await channel.title()).value;
        });
      }
    };
    exports2.Frame = Frame;
    function verifyLoadState(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!types_1.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle)`);
      return waitUntil;
    }
    exports2.verifyLoadState = verifyLoadState;
  }
});

// node_modules/playwright/lib/client/elementHandle.js
var require_elementHandle = __commonJS({
  "node_modules/playwright/lib/client/elementHandle.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.determineScreenshotType = exports2.convertInputFiles = exports2.convertSelectOptionValues = exports2.ElementHandle = void 0;
    var frame_1 = require_frame();
    var jsHandle_1 = require_jsHandle();
    var fs_1 = __importDefault(require("fs"));
    var mime = __importStar(require_mime());
    var path_1 = __importDefault(require("path"));
    var util = __importStar(require("util"));
    var utils_1 = require_utils();
    var fsWriteFileAsync = util.promisify(fs_1.default.writeFile.bind(fs_1.default));
    var ElementHandle = class extends jsHandle_1.JSHandle {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._elementChannel = this._channel;
      }
      static from(handle) {
        return handle._object;
      }
      static fromNullable(handle) {
        return handle ? ElementHandle.from(handle) : null;
      }
      asElement() {
        return this;
      }
      async ownerFrame() {
        return this._wrapApiCall("elementHandle.ownerFrame", async (channel) => {
          return frame_1.Frame.fromNullable((await channel.ownerFrame()).frame);
        });
      }
      async contentFrame() {
        return this._wrapApiCall("elementHandle.contentFrame", async (channel) => {
          return frame_1.Frame.fromNullable((await channel.contentFrame()).frame);
        });
      }
      async getAttribute(name) {
        return this._wrapApiCall("elementHandle.getAttribute", async (channel) => {
          const value = (await channel.getAttribute({name})).value;
          return value === void 0 ? null : value;
        });
      }
      async textContent() {
        return this._wrapApiCall("elementHandle.textContent", async (channel) => {
          const value = (await channel.textContent()).value;
          return value === void 0 ? null : value;
        });
      }
      async innerText() {
        return this._wrapApiCall("elementHandle.innerText", async (channel) => {
          return (await channel.innerText()).value;
        });
      }
      async innerHTML() {
        return this._wrapApiCall("elementHandle.innerHTML", async (channel) => {
          return (await channel.innerHTML()).value;
        });
      }
      async isChecked() {
        return this._wrapApiCall("elementHandle.isChecked", async (channel) => {
          return (await channel.isChecked()).value;
        });
      }
      async isDisabled() {
        return this._wrapApiCall("elementHandle.isDisabled", async (channel) => {
          return (await channel.isDisabled()).value;
        });
      }
      async isEditable() {
        return this._wrapApiCall("elementHandle.isEditable", async (channel) => {
          return (await channel.isEditable()).value;
        });
      }
      async isEnabled() {
        return this._wrapApiCall("elementHandle.isEnabled", async (channel) => {
          return (await channel.isEnabled()).value;
        });
      }
      async isHidden() {
        return this._wrapApiCall("elementHandle.isHidden", async (channel) => {
          return (await channel.isHidden()).value;
        });
      }
      async isVisible() {
        return this._wrapApiCall("elementHandle.isVisible", async (channel) => {
          return (await channel.isVisible()).value;
        });
      }
      async dispatchEvent(type, eventInit = {}) {
        return this._wrapApiCall("elementHandle.dispatchEvent", async (channel) => {
          await channel.dispatchEvent({type, eventInit: jsHandle_1.serializeArgument(eventInit)});
        });
      }
      async scrollIntoViewIfNeeded(options2 = {}) {
        return this._wrapApiCall("elementHandle.scrollIntoViewIfNeeded", async (channel) => {
          await channel.scrollIntoViewIfNeeded(options2);
        });
      }
      async hover(options2 = {}) {
        return this._wrapApiCall("elementHandle.hover", async (channel) => {
          await channel.hover(options2);
        });
      }
      async click(options2 = {}) {
        return this._wrapApiCall("elementHandle.click", async (channel) => {
          return await channel.click(options2);
        });
      }
      async dblclick(options2 = {}) {
        return this._wrapApiCall("elementHandle.dblclick", async (channel) => {
          return await channel.dblclick(options2);
        });
      }
      async tap(options2 = {}) {
        return this._wrapApiCall("elementHandle.tap", async (channel) => {
          return await channel.tap(options2);
        });
      }
      async selectOption(values, options2 = {}) {
        return this._wrapApiCall("elementHandle.selectOption", async (channel) => {
          const result = await channel.selectOption({...convertSelectOptionValues(values), ...options2});
          return result.values;
        });
      }
      async fill(value, options2 = {}) {
        return this._wrapApiCall("elementHandle.fill", async (channel) => {
          return await channel.fill({value, ...options2});
        });
      }
      async selectText(options2 = {}) {
        return this._wrapApiCall("elementHandle.selectText", async (channel) => {
          await channel.selectText(options2);
        });
      }
      async setInputFiles(files, options2 = {}) {
        return this._wrapApiCall("elementHandle.setInputFiles", async (channel) => {
          await channel.setInputFiles({files: await convertInputFiles(files), ...options2});
        });
      }
      async focus() {
        return this._wrapApiCall("elementHandle.focus", async (channel) => {
          await channel.focus();
        });
      }
      async type(text, options2 = {}) {
        return this._wrapApiCall("elementHandle.type", async (channel) => {
          await channel.type({text, ...options2});
        });
      }
      async press(key, options2 = {}) {
        return this._wrapApiCall("elementHandle.press", async (channel) => {
          await channel.press({key, ...options2});
        });
      }
      async check(options2 = {}) {
        return this._wrapApiCall("elementHandle.check", async (channel) => {
          return await channel.check(options2);
        });
      }
      async uncheck(options2 = {}) {
        return this._wrapApiCall("elementHandle.uncheck", async (channel) => {
          return await channel.uncheck(options2);
        });
      }
      async boundingBox() {
        return this._wrapApiCall("elementHandle.boundingBox", async (channel) => {
          const value = (await channel.boundingBox()).value;
          return value === void 0 ? null : value;
        });
      }
      async screenshot(options2 = {}) {
        return this._wrapApiCall("elementHandle.screenshot", async (channel) => {
          const copy = {...options2};
          if (!copy.type)
            copy.type = determineScreenshotType(options2);
          const result = await channel.screenshot(copy);
          const buffer = Buffer.from(result.binary, "base64");
          if (options2.path) {
            await utils_1.mkdirIfNeeded(options2.path);
            await fsWriteFileAsync(options2.path, buffer);
          }
          return buffer;
        });
      }
      async $(selector) {
        return this._wrapApiCall("elementHandle.$", async (channel) => {
          return ElementHandle.fromNullable((await channel.querySelector({selector})).element);
        });
      }
      async $$(selector) {
        return this._wrapApiCall("elementHandle.$$", async (channel) => {
          const result = await channel.querySelectorAll({selector});
          return result.elements.map((h) => ElementHandle.from(h));
        });
      }
      async $eval(selector, pageFunction, arg) {
        return this._wrapApiCall("elementHandle.$eval", async (channel) => {
          const result = await channel.evalOnSelector({selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async $$eval(selector, pageFunction, arg) {
        return this._wrapApiCall("elementHandle.$$eval", async (channel) => {
          const result = await channel.evalOnSelectorAll({selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async waitForElementState(state, options2 = {}) {
        return this._wrapApiCall("elementHandle.waitForElementState", async (channel) => {
          return await channel.waitForElementState({state, ...options2});
        });
      }
      async waitForSelector(selector, options2 = {}) {
        return this._wrapApiCall("elementHandle.waitForSelector", async (channel) => {
          const result = await channel.waitForSelector({selector, ...options2});
          return ElementHandle.fromNullable(result.element);
        });
      }
    };
    exports2.ElementHandle = ElementHandle;
    function convertSelectOptionValues(values) {
      if (values === null)
        return {};
      if (!Array.isArray(values))
        values = [values];
      if (!values.length)
        return {};
      for (let i = 0; i < values.length; i++)
        utils_1.assert(values[i] !== null, `options[${i}]: expected object, got null`);
      if (values[0] instanceof ElementHandle)
        return {elements: values.map((v) => v._elementChannel)};
      if (utils_1.isString(values[0]))
        return {options: values.map((value) => ({value}))};
      return {options: values};
    }
    exports2.convertSelectOptionValues = convertSelectOptionValues;
    async function convertInputFiles(files) {
      const items = Array.isArray(files) ? files : [files];
      const filePayloads = await Promise.all(items.map(async (item) => {
        if (typeof item === "string") {
          return {
            name: path_1.default.basename(item),
            mimeType: mime.getType(item) || "application/octet-stream",
            buffer: (await util.promisify(fs_1.default.readFile)(item)).toString("base64")
          };
        } else {
          return {
            name: item.name,
            mimeType: item.mimeType,
            buffer: item.buffer.toString("base64")
          };
        }
      }));
      return filePayloads;
    }
    exports2.convertInputFiles = convertInputFiles;
    function determineScreenshotType(options2) {
      if (options2.path) {
        const mimeType = mime.getType(options2.path);
        if (mimeType === "image/png")
          return "png";
        else if (mimeType === "image/jpeg")
          return "jpeg";
        throw new Error(`path: unsupported mime type "${mimeType}"`);
      }
      return options2.type;
    }
    exports2.determineScreenshotType = determineScreenshotType;
  }
});

// node_modules/playwright/lib/client/worker.js
var require_worker = __commonJS({
  "node_modules/playwright/lib/client/worker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Worker = void 0;
    var events_1 = require_events();
    var channelOwner_1 = require_channelOwner();
    var jsHandle_1 = require_jsHandle();
    var Worker = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("close", () => {
          if (this._page)
            this._page._workers.delete(this);
          if (this._context)
            this._context._serviceWorkers.delete(this);
          this.emit(events_1.Events.Worker.Close, this);
        });
      }
      static from(worker) {
        return worker._object;
      }
      url() {
        return this._initializer.url;
      }
      async evaluate(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall("worker.evaluate", async (channel) => {
          const result = await channel.evaluateExpression({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._wrapApiCall("worker.evaluateHandle", async (channel) => {
          const result = await channel.evaluateExpressionHandle({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.JSHandle.from(result.handle);
        });
      }
    };
    exports2.Worker = Worker;
  }
});

// node_modules/playwright/lib/client/input.js
var require_input2 = __commonJS({
  "node_modules/playwright/lib/client/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = void 0;
    var Keyboard = class {
      constructor(channel) {
        this._channel = channel;
      }
      async down(key) {
        await this._channel.keyboardDown({key});
      }
      async up(key) {
        await this._channel.keyboardUp({key});
      }
      async insertText(text) {
        await this._channel.keyboardInsertText({text});
      }
      async type(text, options2 = {}) {
        await this._channel.keyboardType({text, ...options2});
      }
      async press(key, options2 = {}) {
        await this._channel.keyboardPress({key, ...options2});
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(channel) {
        this._channel = channel;
      }
      async move(x, y, options2 = {}) {
        await this._channel.mouseMove({x, y, ...options2});
      }
      async down(options2 = {}) {
        await this._channel.mouseDown({...options2});
      }
      async up(options2 = {}) {
        await this._channel.mouseUp(options2);
      }
      async click(x, y, options2 = {}) {
        await this._channel.mouseClick({x, y, ...options2});
      }
      async dblclick(x, y, options2 = {}) {
        await this.click(x, y, {...options2, clickCount: 2});
      }
    };
    exports2.Mouse = Mouse;
    var Touchscreen = class {
      constructor(channel) {
        this._channel = channel;
      }
      async tap(x, y) {
        await this._channel.touchscreenTap({x, y});
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright/lib/client/fileChooser.js
var require_fileChooser2 = __commonJS({
  "node_modules/playwright/lib/client/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
      async setFiles(files, options2) {
        return this._page._wrapApiCall("fileChooser.setFiles", async () => {
          return this._elementHandle.setInputFiles(files, options2);
        });
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/playwright/lib/client/coverage.js
var require_coverage = __commonJS({
  "node_modules/playwright/lib/client/coverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Coverage = void 0;
    var Coverage = class {
      constructor(channel) {
        this._channel = channel;
      }
      async startJSCoverage(options2 = {}) {
        await this._channel.startJSCoverage(options2);
      }
      async stopJSCoverage() {
        return (await this._channel.stopJSCoverage()).entries;
      }
      async startCSSCoverage(options2 = {}) {
        await this._channel.startCSSCoverage(options2);
      }
      async stopCSSCoverage() {
        return (await this._channel.stopCSSCoverage()).entries;
      }
    };
    exports2.Coverage = Coverage;
  }
});

// node_modules/playwright/lib/client/video.js
var require_video = __commonJS({
  "node_modules/playwright/lib/client/video.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Video = void 0;
    var Video = class {
      constructor(page) {
        this._artifact = null;
        this._artifactCallback = (artifact) => {
        };
        this._isRemote = false;
        const browser = page.context()._browser;
        this._isRemote = !!browser && browser._isRemote;
        this._artifact = Promise.race([
          new Promise((f) => this._artifactCallback = f),
          page._closedOrCrashedPromise.then(() => null)
        ]);
      }
      _artifactReady(artifact) {
        artifact._isRemote = this._isRemote;
        this._artifactCallback(artifact);
      }
      async path() {
        if (this._isRemote)
          throw new Error(`Path is not available when using browserType.connect(). Use saveAs() to save a local copy.`);
        const artifact = await this._artifact;
        if (!artifact)
          throw new Error("Page did not produce any video frames");
        return artifact._initializer.absolutePath;
      }
      async saveAs(path) {
        const artifact = await this._artifact;
        if (!artifact)
          throw new Error("Page did not produce any video frames");
        return artifact.saveAs(path);
      }
      async delete() {
        const artifact = await this._artifact;
        if (artifact)
          await artifact.delete();
      }
    };
    exports2.Video = Video;
  }
});

// node_modules/playwright/lib/client/stream.js
var require_stream2 = __commonJS({
  "node_modules/playwright/lib/client/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Stream = void 0;
    var stream_1 = require("stream");
    var channelOwner_1 = require_channelOwner();
    var Stream2 = class extends channelOwner_1.ChannelOwner {
      static from(Stream3) {
        return Stream3._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      stream() {
        return new StreamImpl(this._channel);
      }
    };
    exports2.Stream = Stream2;
    var StreamImpl = class extends stream_1.Readable {
      constructor(channel) {
        super();
        this._channel = channel;
      }
      async _read(size) {
        const result = await this._channel.read({size});
        if (result.binary)
          this.push(Buffer.from(result.binary, "base64"));
        else
          this.push(null);
      }
      _destroy(error3, callback) {
        this._channel.close().catch((e) => null);
        super._destroy(error3, callback);
      }
    };
  }
});

// node_modules/playwright/lib/client/artifact.js
var require_artifact2 = __commonJS({
  "node_modules/playwright/lib/client/artifact.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Artifact = void 0;
    var fs = __importStar(require("fs"));
    var stream_1 = require_stream2();
    var utils_1 = require_utils();
    var channelOwner_1 = require_channelOwner();
    var Artifact = class extends channelOwner_1.ChannelOwner {
      constructor() {
        super(...arguments);
        this._isRemote = false;
        this._apiName = "";
      }
      static from(channel) {
        return channel._object;
      }
      async pathAfterFinished() {
        if (this._isRemote)
          throw new Error(`Path is not available when using browserType.connect(). Use saveAs() to save a local copy.`);
        return this._wrapApiCall(`${this._apiName}.path`, async (channel) => {
          return (await channel.pathAfterFinished()).value || null;
        });
      }
      async saveAs(path) {
        return this._wrapApiCall(`${this._apiName}.saveAs`, async (channel) => {
          if (!this._isRemote) {
            await channel.saveAs({path});
            return;
          }
          const result = await channel.saveAsStream();
          const stream = stream_1.Stream.from(result.stream);
          await utils_1.mkdirIfNeeded(path);
          await new Promise((resolve2, reject) => {
            stream.stream().pipe(fs.createWriteStream(path)).on("finish", resolve2).on("error", reject);
          });
        });
      }
      async failure() {
        return this._wrapApiCall(`${this._apiName}.failure`, async (channel) => {
          return (await channel.failure()).error || null;
        });
      }
      async createReadStream() {
        return this._wrapApiCall(`${this._apiName}.createReadStream`, async (channel) => {
          const result = await channel.stream();
          if (!result.stream)
            return null;
          const stream = stream_1.Stream.from(result.stream);
          return stream.stream();
        });
      }
      async delete() {
        return this._wrapApiCall(`${this._apiName}.delete`, async (channel) => {
          return channel.delete();
        });
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright/lib/client/page.js
var require_page2 = __commonJS({
  "node_modules/playwright/lib/client/page.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BindingCall = exports2.Page = void 0;
    var events_1 = require_events();
    var utils_1 = require_utils();
    var timeoutSettings_1 = require_timeoutSettings();
    var serializers_1 = require_serializers();
    var accessibility_1 = require_accessibility2();
    var channelOwner_1 = require_channelOwner();
    var consoleMessage_1 = require_consoleMessage();
    var dialog_1 = require_dialog2();
    var download_1 = require_download2();
    var elementHandle_1 = require_elementHandle();
    var worker_1 = require_worker();
    var frame_1 = require_frame();
    var input_1 = require_input2();
    var jsHandle_1 = require_jsHandle();
    var network_1 = require_network2();
    var fileChooser_1 = require_fileChooser2();
    var buffer_1 = require("buffer");
    var coverage_1 = require_coverage();
    var waiter_1 = require_waiter();
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var util = __importStar(require("util"));
    var clientHelper_1 = require_clientHelper();
    var utils_2 = require_utils();
    var errors_1 = require_errors();
    var video_1 = require_video();
    var artifact_1 = require_artifact2();
    var fsWriteFileAsync = util.promisify(fs_1.default.writeFile.bind(fs_1.default));
    var mkdirAsync = util.promisify(fs_1.default.mkdir);
    var Page = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._frames = new Set();
        this._workers = new Set();
        this._closed = false;
        this._routes = [];
        this._bindings = new Map();
        this._isPageCall = false;
        this._video = null;
        this._browserContext = parent;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(this._browserContext._timeoutSettings);
        this.accessibility = new accessibility_1.Accessibility(this._channel);
        this.keyboard = new input_1.Keyboard(this._channel);
        this.mouse = new input_1.Mouse(this._channel);
        this.touchscreen = new input_1.Touchscreen(this._channel);
        this._mainFrame = frame_1.Frame.from(initializer.mainFrame);
        this._mainFrame._page = this;
        this._frames.add(this._mainFrame);
        this._viewportSize = initializer.viewportSize || null;
        this._closed = initializer.isClosed;
        this._opener = Page.fromNullable(initializer.opener);
        this._channel.on("bindingCall", ({binding}) => this._onBinding(BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("console", ({message}) => this.emit(events_1.Events.Page.Console, consoleMessage_1.ConsoleMessage.from(message)));
        this._channel.on("crash", () => this._onCrash());
        this._channel.on("dialog", ({dialog}) => {
          if (!this.emit(events_1.Events.Page.Dialog, dialog_1.Dialog.from(dialog)))
            dialog.dismiss().catch(() => {
            });
        });
        this._channel.on("domcontentloaded", () => this.emit(events_1.Events.Page.DOMContentLoaded, this));
        this._channel.on("download", ({url, suggestedFilename, artifact}) => {
          const artifactObject = artifact_1.Artifact.from(artifact);
          artifactObject._isRemote = !!this._browserContext._browser && this._browserContext._browser._isRemote;
          this.emit(events_1.Events.Page.Download, new download_1.Download(url, suggestedFilename, artifactObject));
        });
        this._channel.on("fileChooser", ({element, isMultiple}) => this.emit(events_1.Events.Page.FileChooser, new fileChooser_1.FileChooser(this, elementHandle_1.ElementHandle.from(element), isMultiple)));
        this._channel.on("frameAttached", ({frame}) => this._onFrameAttached(frame_1.Frame.from(frame)));
        this._channel.on("frameDetached", ({frame}) => this._onFrameDetached(frame_1.Frame.from(frame)));
        this._channel.on("load", () => this.emit(events_1.Events.Page.Load, this));
        this._channel.on("pageError", ({error: error3}) => this.emit(events_1.Events.Page.PageError, serializers_1.parseError(error3)));
        this._channel.on("request", ({request}) => this.emit(events_1.Events.Page.Request, network_1.Request.from(request)));
        this._channel.on("requestFailed", ({request, failureText, responseEndTiming}) => this._onRequestFailed(network_1.Request.from(request), responseEndTiming, failureText));
        this._channel.on("requestFinished", ({request, responseEndTiming}) => this._onRequestFinished(network_1.Request.from(request), responseEndTiming));
        this._channel.on("response", ({response}) => this.emit(events_1.Events.Page.Response, network_1.Response.from(response)));
        this._channel.on("route", ({route, request}) => this._onRoute(network_1.Route.from(route), network_1.Request.from(request)));
        this._channel.on("video", ({artifact}) => {
          const artifactObject = artifact_1.Artifact.from(artifact);
          this._forceVideo()._artifactReady(artifactObject);
        });
        this._channel.on("webSocket", ({webSocket}) => this.emit(events_1.Events.Page.WebSocket, network_1.WebSocket.from(webSocket)));
        this._channel.on("worker", ({worker}) => this._onWorker(worker_1.Worker.from(worker)));
        this.coverage = new coverage_1.Coverage(this._channel);
        this._closedOrCrashedPromise = Promise.race([
          new Promise((f) => this.once(events_1.Events.Page.Close, f)),
          new Promise((f) => this.once(events_1.Events.Page.Crash, f))
        ]);
      }
      static from(page) {
        return page._object;
      }
      static fromNullable(page) {
        return page ? Page.from(page) : null;
      }
      _onRequestFailed(request, responseEndTiming, failureText) {
        request._failureText = failureText || null;
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(events_1.Events.Page.RequestFailed, request);
      }
      _onRequestFinished(request, responseEndTiming) {
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(events_1.Events.Page.RequestFinished, request);
      }
      _onFrameAttached(frame) {
        frame._page = this;
        this._frames.add(frame);
        if (frame._parentFrame)
          frame._parentFrame._childFrames.add(frame);
        this.emit(events_1.Events.Page.FrameAttached, frame);
      }
      _onFrameDetached(frame) {
        this._frames.delete(frame);
        frame._detached = true;
        if (frame._parentFrame)
          frame._parentFrame._childFrames.delete(frame);
        this.emit(events_1.Events.Page.FrameDetached, frame);
      }
      _onRoute(route, request) {
        for (const {url, handler: handler2} of this._routes) {
          if (clientHelper_1.urlMatches(request.url(), url)) {
            handler2(route, request);
            return;
          }
        }
        this._browserContext._onRoute(route, request);
      }
      async _onBinding(bindingCall) {
        const func = this._bindings.get(bindingCall._initializer.name);
        if (func) {
          await bindingCall.call(func);
          return;
        }
        await this._browserContext._onBinding(bindingCall);
      }
      _onWorker(worker) {
        this._workers.add(worker);
        worker._page = this;
        this.emit(events_1.Events.Page.Worker, worker);
      }
      _onClose() {
        this._closed = true;
        this._browserContext._pages.delete(this);
        this.emit(events_1.Events.Page.Close, this);
      }
      _onCrash() {
        this.emit(events_1.Events.Page.Crash, this);
      }
      context() {
        return this._browserContext;
      }
      async opener() {
        if (!this._opener || this._opener.isClosed())
          return null;
        return this._opener;
      }
      mainFrame() {
        return this._mainFrame;
      }
      frame(frameSelector) {
        const name = utils_2.isString(frameSelector) ? frameSelector : frameSelector.name;
        const url = utils_2.isObject(frameSelector) ? frameSelector.url : void 0;
        utils_1.assert(name || url, "Either name or url matcher should be specified");
        return this.frames().find((f) => {
          if (name)
            return f.name() === name;
          return clientHelper_1.urlMatches(f.url(), url);
        }) || null;
      }
      frames() {
        return [...this._frames];
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._channel.setDefaultNavigationTimeoutNoReply({timeout});
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({timeout});
      }
      _forceVideo() {
        if (!this._video)
          this._video = new video_1.Video(this);
        return this._video;
      }
      video() {
        if (!this._browserContext._options.recordVideo)
          return null;
        return this._forceVideo();
      }
      _attributeToPage(func) {
        try {
          this._isPageCall = true;
          return func();
        } finally {
          this._isPageCall = false;
        }
      }
      async $(selector) {
        return this._attributeToPage(() => this._mainFrame.$(selector));
      }
      async waitForSelector(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.waitForSelector(selector, options2));
      }
      async dispatchEvent(selector, type, eventInit, options2) {
        return this._attributeToPage(() => this._mainFrame.dispatchEvent(selector, type, eventInit, options2));
      }
      async evaluateHandle(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._attributeToPage(() => this._mainFrame.evaluateHandle(pageFunction, arg));
      }
      async $eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._attributeToPage(() => this._mainFrame.$eval(selector, pageFunction, arg));
      }
      async $$eval(selector, pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 3);
        return this._attributeToPage(() => this._mainFrame.$$eval(selector, pageFunction, arg));
      }
      async $$(selector) {
        return this._attributeToPage(() => this._mainFrame.$$(selector));
      }
      async addScriptTag(options2 = {}) {
        return this._attributeToPage(() => this._mainFrame.addScriptTag(options2));
      }
      async addStyleTag(options2 = {}) {
        return this._attributeToPage(() => this._mainFrame.addStyleTag(options2));
      }
      async exposeFunction(name, callback) {
        return this._wrapApiCall("page.exposeFunction", async (channel) => {
          await channel.exposeBinding({name});
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      async exposeBinding(name, callback, options2 = {}) {
        return this._wrapApiCall("page.exposeBinding", async (channel) => {
          await channel.exposeBinding({name, needsHandle: options2.handle});
          this._bindings.set(name, callback);
        });
      }
      async setExtraHTTPHeaders(headers) {
        return this._wrapApiCall("page.setExtraHTTPHeaders", async (channel) => {
          network_1.validateHeaders(headers);
          await channel.setExtraHTTPHeaders({headers: utils_2.headersObjectToArray(headers)});
        });
      }
      url() {
        return this._attributeToPage(() => this._mainFrame.url());
      }
      async content() {
        return this._attributeToPage(() => this._mainFrame.content());
      }
      async setContent(html, options2) {
        return this._attributeToPage(() => this._mainFrame.setContent(html, options2));
      }
      async goto(url, options2) {
        return this._attributeToPage(() => this._mainFrame.goto(url, options2));
      }
      async reload(options2 = {}) {
        return this._wrapApiCall("page.reload", async (channel) => {
          const waitUntil = frame_1.verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return network_1.Response.fromNullable((await channel.reload({...options2, waitUntil})).response);
        });
      }
      async waitForLoadState(state, options2) {
        return this._attributeToPage(() => this._mainFrame.waitForLoadState(state, options2));
      }
      async waitForNavigation(options2) {
        return this._attributeToPage(() => this._mainFrame.waitForNavigation(options2));
      }
      async waitForURL(url, options2) {
        return this._attributeToPage(() => this._mainFrame.waitForURL(url, options2));
      }
      async waitForRequest(urlOrPredicate, options2 = {}) {
        return this._wrapApiCall("page.waitForRequest", async (channel) => {
          const predicate = (request) => {
            if (utils_2.isString(urlOrPredicate) || utils_2.isRegExp(urlOrPredicate))
              return clientHelper_1.urlMatches(request.url(), urlOrPredicate);
            return urlOrPredicate(request);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : void 0;
          return this._waitForEvent(events_1.Events.Page.Request, {predicate, timeout: options2.timeout}, logLine);
        });
      }
      async waitForResponse(urlOrPredicate, options2 = {}) {
        return this._wrapApiCall("page.waitForResponse", async (channel) => {
          const predicate = (response) => {
            if (utils_2.isString(urlOrPredicate) || utils_2.isRegExp(urlOrPredicate))
              return clientHelper_1.urlMatches(response.url(), urlOrPredicate);
            return urlOrPredicate(response);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : void 0;
          return this._waitForEvent(events_1.Events.Page.Response, {predicate, timeout: options2.timeout}, logLine);
        });
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        return this._wrapApiCall("page.waitForEvent", async (channel) => {
          return this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
        });
      }
      async _waitForEvent(event, optionsOrPredicate, logLine) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, "page", event);
        if (logLine)
          waiter.log(logLine);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.Page.Crash)
          waiter.rejectOnEvent(this, events_1.Events.Page.Crash, new Error("Page crashed"));
        if (event !== events_1.Events.Page.Close)
          waiter.rejectOnEvent(this, events_1.Events.Page.Close, new Error("Page closed"));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
      }
      async goBack(options2 = {}) {
        return this._wrapApiCall("page.goBack", async (channel) => {
          const waitUntil = frame_1.verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return network_1.Response.fromNullable((await channel.goBack({...options2, waitUntil})).response);
        });
      }
      async goForward(options2 = {}) {
        return this._wrapApiCall("page.goForward", async (channel) => {
          const waitUntil = frame_1.verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
          return network_1.Response.fromNullable((await channel.goForward({...options2, waitUntil})).response);
        });
      }
      async emulateMedia(options2 = {}) {
        return this._wrapApiCall("page.emulateMedia", async (channel) => {
          await channel.emulateMedia({
            media: options2.media === null ? "null" : options2.media,
            colorScheme: options2.colorScheme === null ? "null" : options2.colorScheme
          });
        });
      }
      async setViewportSize(viewportSize) {
        return this._wrapApiCall("page.setViewportSize", async (channel) => {
          this._viewportSize = viewportSize;
          await channel.setViewportSize({viewportSize});
        });
      }
      viewportSize() {
        return this._viewportSize;
      }
      async evaluate(pageFunction, arg) {
        jsHandle_1.assertMaxArguments(arguments.length, 2);
        return this._attributeToPage(() => this._mainFrame.evaluate(pageFunction, arg));
      }
      async addInitScript(script, arg) {
        return this._wrapApiCall("page.addInitScript", async (channel) => {
          const source = await clientHelper_1.evaluationScript(script, arg);
          await channel.addInitScript({source});
        });
      }
      async route(url, handler2) {
        return this._wrapApiCall("page.route", async (channel) => {
          this._routes.push({url, handler: handler2});
          if (this._routes.length === 1)
            await channel.setNetworkInterceptionEnabled({enabled: true});
        });
      }
      async unroute(url, handler2) {
        return this._wrapApiCall("page.unroute", async (channel) => {
          this._routes = this._routes.filter((route) => route.url !== url || handler2 && route.handler !== handler2);
          if (this._routes.length === 0)
            await channel.setNetworkInterceptionEnabled({enabled: false});
        });
      }
      async screenshot(options2 = {}) {
        return this._wrapApiCall("page.screenshot", async (channel) => {
          const copy = {...options2};
          if (!copy.type)
            copy.type = elementHandle_1.determineScreenshotType(options2);
          const result = await channel.screenshot(copy);
          const buffer = buffer_1.Buffer.from(result.binary, "base64");
          if (options2.path) {
            await utils_2.mkdirIfNeeded(options2.path);
            await fsWriteFileAsync(options2.path, buffer);
          }
          return buffer;
        });
      }
      async title() {
        return this._attributeToPage(() => this._mainFrame.title());
      }
      async bringToFront() {
        return this._wrapApiCall("page.bringToFront", async (channel) => {
          await channel.bringToFront();
        });
      }
      async close(options2 = {runBeforeUnload: void 0}) {
        try {
          await this._wrapApiCall("page.close", async (channel) => {
            await channel.close(options2);
            if (this._ownedContext)
              await this._ownedContext.close();
          });
        } catch (e) {
          if (errors_1.isSafeCloseError(e))
            return;
          throw e;
        }
      }
      isClosed() {
        return this._closed;
      }
      async click(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.click(selector, options2));
      }
      async dblclick(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.dblclick(selector, options2));
      }
      async tap(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.tap(selector, options2));
      }
      async fill(selector, value, options2) {
        return this._attributeToPage(() => this._mainFrame.fill(selector, value, options2));
      }
      async focus(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.focus(selector, options2));
      }
      async textContent(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.textContent(selector, options2));
      }
      async innerText(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.innerText(selector, options2));
      }
      async innerHTML(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.innerHTML(selector, options2));
      }
      async getAttribute(selector, name, options2) {
        return this._attributeToPage(() => this._mainFrame.getAttribute(selector, name, options2));
      }
      async isChecked(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.isChecked(selector, options2));
      }
      async isDisabled(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.isDisabled(selector, options2));
      }
      async isEditable(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.isEditable(selector, options2));
      }
      async isEnabled(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.isEnabled(selector, options2));
      }
      async isHidden(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.isHidden(selector, options2));
      }
      async isVisible(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.isVisible(selector, options2));
      }
      async hover(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.hover(selector, options2));
      }
      async selectOption(selector, values, options2) {
        return this._attributeToPage(() => this._mainFrame.selectOption(selector, values, options2));
      }
      async setInputFiles(selector, files, options2) {
        return this._attributeToPage(() => this._mainFrame.setInputFiles(selector, files, options2));
      }
      async type(selector, text, options2) {
        return this._attributeToPage(() => this._mainFrame.type(selector, text, options2));
      }
      async press(selector, key, options2) {
        return this._attributeToPage(() => this._mainFrame.press(selector, key, options2));
      }
      async check(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.check(selector, options2));
      }
      async uncheck(selector, options2) {
        return this._attributeToPage(() => this._mainFrame.uncheck(selector, options2));
      }
      async waitForTimeout(timeout) {
        return this._attributeToPage(() => this._mainFrame.waitForTimeout(timeout));
      }
      async waitForFunction(pageFunction, arg, options2) {
        return this._attributeToPage(() => this._mainFrame.waitForFunction(pageFunction, arg, options2));
      }
      workers() {
        return [...this._workers];
      }
      on(event, listener) {
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({intercepted: true});
        super.on(event, listener);
        return this;
      }
      addListener(event, listener) {
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({intercepted: true});
        super.addListener(event, listener);
        return this;
      }
      off(event, listener) {
        super.off(event, listener);
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({intercepted: false});
        return this;
      }
      removeListener(event, listener) {
        super.removeListener(event, listener);
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({intercepted: false});
        return this;
      }
      async pause() {
        return this.context()._wrapApiCall("page.pause", async (channel) => {
          await channel.pause();
        });
      }
      async pdf(options2 = {}) {
        return this._wrapApiCall("page.pdf", async (channel) => {
          const transportOptions = {...options2};
          if (transportOptions.margin)
            transportOptions.margin = {...transportOptions.margin};
          if (typeof options2.width === "number")
            transportOptions.width = options2.width + "px";
          if (typeof options2.height === "number")
            transportOptions.height = options2.height + "px";
          for (const margin of ["top", "right", "bottom", "left"]) {
            const index2 = margin;
            if (options2.margin && typeof options2.margin[index2] === "number")
              transportOptions.margin[index2] = transportOptions.margin[index2] + "px";
          }
          const result = await channel.pdf(transportOptions);
          const buffer = buffer_1.Buffer.from(result.pdf, "base64");
          if (options2.path) {
            await mkdirAsync(path_1.default.dirname(options2.path), {recursive: true});
            await fsWriteFileAsync(options2.path, buffer);
          }
          return buffer;
        });
      }
    };
    exports2.Page = Page;
    var BindingCall = class extends channelOwner_1.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      async call(func) {
        try {
          const frame = frame_1.Frame.from(this._initializer.frame);
          const source = {
            context: frame._page.context(),
            page: frame._page,
            frame
          };
          let result;
          if (this._initializer.handle)
            result = await func(source, jsHandle_1.JSHandle.from(this._initializer.handle));
          else
            result = await func(source, ...this._initializer.args.map(jsHandle_1.parseResult));
          this._channel.resolve({result: jsHandle_1.serializeArgument(result)}).catch(() => {
          });
        } catch (e) {
          this._channel.reject({error: serializers_1.serializeError(e)}).catch(() => {
          });
        }
      }
    };
    exports2.BindingCall = BindingCall;
    function trimEnd(s2) {
      if (s2.length > 50)
        s2 = s2.substring(0, 50) + "\u2026";
      return s2;
    }
    function trimUrl(param) {
      if (utils_2.isRegExp(param))
        return `/${trimEnd(param.source)}/${param.flags}`;
      if (utils_2.isString(param))
        return `"${trimEnd(param)}"`;
    }
  }
});

// node_modules/playwright/lib/client/cdpSession.js
var require_cdpSession = __commonJS({
  "node_modules/playwright/lib/client/cdpSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CDPSession = void 0;
    var channelOwner_1 = require_channelOwner();
    var CDPSession = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("event", ({method, params}) => {
          this.emit(method, params);
        });
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      static from(cdpSession) {
        return cdpSession._object;
      }
      async send(method, params) {
        return this._wrapApiCall("cdpSession.send", async (channel) => {
          const result = await channel.send({method, params});
          return result.result;
        });
      }
      async detach() {
        return this._wrapApiCall("cdpSession.detach", async (channel) => {
          return channel.detach();
        });
      }
    };
    exports2.CDPSession = CDPSession;
  }
});

// node_modules/playwright/lib/client/tracing.js
var require_tracing2 = __commonJS({
  "node_modules/playwright/lib/client/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Tracing = void 0;
    var artifact_1 = require_artifact2();
    var Tracing = class {
      constructor(channel) {
        this._context = channel;
      }
      async start(options2 = {}) {
        await this._context._wrapApiCall("tracing.start", async (channel) => {
          return await channel.tracingStart(options2);
        });
      }
      async stop() {
        await this._context._wrapApiCall("tracing.stop", async (channel) => {
          await channel.tracingStop();
        });
      }
      async export(path) {
        var _a;
        const result = await this._context._wrapApiCall("tracing.export", async (channel) => {
          return await channel.tracingExport();
        });
        const artifact = artifact_1.Artifact.from(result.artifact);
        if ((_a = this._context.browser()) === null || _a === void 0 ? void 0 : _a._isRemote)
          artifact._isRemote = true;
        await artifact.saveAs(path);
        await artifact.delete();
      }
    };
    exports2.Tracing = Tracing;
  }
});

// node_modules/playwright/lib/client/browserContext.js
var require_browserContext2 = __commonJS({
  "node_modules/playwright/lib/client/browserContext.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.prepareBrowserContextParams = exports2.BrowserContext = void 0;
    var page_1 = require_page2();
    var network = __importStar(require_network2());
    var util = __importStar(require("util"));
    var fs_1 = __importDefault(require("fs"));
    var channelOwner_1 = require_channelOwner();
    var clientHelper_1 = require_clientHelper();
    var browser_1 = require_browser3();
    var worker_1 = require_worker();
    var events_1 = require_events();
    var timeoutSettings_1 = require_timeoutSettings();
    var waiter_1 = require_waiter();
    var utils_1 = require_utils();
    var errors_1 = require_errors();
    var cdpSession_1 = require_cdpSession();
    var tracing_1 = require_tracing2();
    var fsWriteFileAsync = util.promisify(fs_1.default.writeFile.bind(fs_1.default));
    var fsReadFileAsync = util.promisify(fs_1.default.readFile.bind(fs_1.default));
    var BrowserContext = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        var _a;
        super(parent, type, guid, initializer);
        this._pages = new Set();
        this._routes = [];
        this._browser = null;
        this._bindings = new Map();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._options = {
          sdkLanguage: "javascript"
        };
        this._backgroundPages = new Set();
        this._serviceWorkers = new Set();
        if (parent instanceof browser_1.Browser)
          this._browser = parent;
        this._isChromium = ((_a = this._browser) === null || _a === void 0 ? void 0 : _a._name) === "chromium";
        this._tracing = new tracing_1.Tracing(this);
        this._channel.on("bindingCall", ({binding}) => this._onBinding(page_1.BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("page", ({page}) => this._onPage(page_1.Page.from(page)));
        this._channel.on("route", ({route, request}) => this._onRoute(network.Route.from(route), network.Request.from(request)));
        this._channel.on("backgroundPage", ({page}) => {
          const backgroundPage = page_1.Page.from(page);
          this._backgroundPages.add(backgroundPage);
          this.emit(events_1.Events.BrowserContext.BackgroundPage, backgroundPage);
        });
        this._channel.on("serviceWorker", ({worker}) => {
          const serviceWorker = worker_1.Worker.from(worker);
          serviceWorker._context = this;
          this._serviceWorkers.add(serviceWorker);
          this.emit(events_1.Events.BrowserContext.ServiceWorker, serviceWorker);
        });
        this._closedPromise = new Promise((f) => this.once(events_1.Events.BrowserContext.Close, f));
      }
      static from(context) {
        return context._object;
      }
      static fromNullable(context) {
        return context ? BrowserContext.from(context) : null;
      }
      _onPage(page) {
        this._pages.add(page);
        this.emit(events_1.Events.BrowserContext.Page, page);
        if (page._opener && !page._opener.isClosed())
          page._opener.emit(events_1.Events.Page.Popup, page);
      }
      _onRoute(route, request) {
        for (const {url, handler: handler2} of this._routes) {
          if (clientHelper_1.urlMatches(request.url(), url)) {
            handler2(route, request);
            return;
          }
        }
        route.continue().catch(() => {
        });
      }
      async _onBinding(bindingCall) {
        const func = this._bindings.get(bindingCall._initializer.name);
        if (!func)
          return;
        await bindingCall.call(func);
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._channel.setDefaultNavigationTimeoutNoReply({timeout});
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({timeout});
      }
      browser() {
        return this._browser;
      }
      pages() {
        return [...this._pages];
      }
      async newPage() {
        return this._wrapApiCall("browserContext.newPage", async (channel) => {
          if (this._ownerPage)
            throw new Error("Please use browser.newContext()");
          return page_1.Page.from((await channel.newPage()).page);
        });
      }
      async cookies(urls) {
        if (!urls)
          urls = [];
        if (urls && typeof urls === "string")
          urls = [urls];
        return this._wrapApiCall("browserContext.cookies", async (channel) => {
          return (await channel.cookies({urls})).cookies;
        });
      }
      async addCookies(cookies) {
        return this._wrapApiCall("browserContext.addCookies", async (channel) => {
          await channel.addCookies({cookies});
        });
      }
      async clearCookies() {
        return this._wrapApiCall("browserContext.clearCookies", async (channel) => {
          await channel.clearCookies();
        });
      }
      async grantPermissions(permissions, options2) {
        return this._wrapApiCall("browserContext.grantPermissions", async (channel) => {
          await channel.grantPermissions({permissions, ...options2});
        });
      }
      async clearPermissions() {
        return this._wrapApiCall("browserContext.clearPermissions", async (channel) => {
          await channel.clearPermissions();
        });
      }
      async setGeolocation(geolocation) {
        return this._wrapApiCall("browserContext.setGeolocation", async (channel) => {
          await channel.setGeolocation({geolocation: geolocation || void 0});
        });
      }
      async setExtraHTTPHeaders(headers) {
        return this._wrapApiCall("browserContext.setExtraHTTPHeaders", async (channel) => {
          network.validateHeaders(headers);
          await channel.setExtraHTTPHeaders({headers: utils_1.headersObjectToArray(headers)});
        });
      }
      async setOffline(offline) {
        return this._wrapApiCall("browserContext.setOffline", async (channel) => {
          await channel.setOffline({offline});
        });
      }
      async setHTTPCredentials(httpCredentials) {
        if (!utils_1.isUnderTest())
          clientHelper_1.deprecate(`context.setHTTPCredentials`, `warning: method |context.setHTTPCredentials()| is deprecated. Instead of changing credentials, create another browser context with new credentials.`);
        return this._wrapApiCall("browserContext.setHTTPCredentials", async (channel) => {
          await channel.setHTTPCredentials({httpCredentials: httpCredentials || void 0});
        });
      }
      async addInitScript(script, arg) {
        return this._wrapApiCall("browserContext.addInitScript", async (channel) => {
          const source = await clientHelper_1.evaluationScript(script, arg);
          await channel.addInitScript({source});
        });
      }
      async exposeBinding(name, callback, options2 = {}) {
        return this._wrapApiCall("browserContext.exposeBinding", async (channel) => {
          await channel.exposeBinding({name, needsHandle: options2.handle});
          this._bindings.set(name, callback);
        });
      }
      async exposeFunction(name, callback) {
        return this._wrapApiCall("browserContext.exposeFunction", async (channel) => {
          await channel.exposeBinding({name});
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      async route(url, handler2) {
        return this._wrapApiCall("browserContext.route", async (channel) => {
          this._routes.push({url, handler: handler2});
          if (this._routes.length === 1)
            await channel.setNetworkInterceptionEnabled({enabled: true});
        });
      }
      async unroute(url, handler2) {
        return this._wrapApiCall("browserContext.unroute", async (channel) => {
          this._routes = this._routes.filter((route) => route.url !== url || handler2 && route.handler !== handler2);
          if (this._routes.length === 0)
            await channel.setNetworkInterceptionEnabled({enabled: false});
        });
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, "browserContext", event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.BrowserContext.Close)
          waiter.rejectOnEvent(this, events_1.Events.BrowserContext.Close, new Error("Context closed"));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
      }
      async storageState(options2 = {}) {
        return await this._wrapApiCall("browserContext.storageState", async (channel) => {
          const state = await channel.storageState();
          if (options2.path) {
            await utils_1.mkdirIfNeeded(options2.path);
            await fsWriteFileAsync(options2.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
      backgroundPages() {
        return [...this._backgroundPages];
      }
      serviceWorkers() {
        return [...this._serviceWorkers];
      }
      async newCDPSession(page) {
        return this._wrapApiCall("browserContext.newCDPSession", async (channel) => {
          const result = await channel.newCDPSession({page: page._channel});
          return cdpSession_1.CDPSession.from(result.session);
        });
      }
      _onClose() {
        if (this._browser)
          this._browser._contexts.delete(this);
        this.emit(events_1.Events.BrowserContext.Close, this);
      }
      async close() {
        try {
          await this._wrapApiCall("browserContext.close", async (channel) => {
            await channel.close();
            await this._closedPromise;
          });
        } catch (e) {
          if (errors_1.isSafeCloseError(e))
            return;
          throw e;
        }
      }
      async _enableRecorder(params) {
        await this._channel.recorderSupplementEnable(params);
      }
    };
    exports2.BrowserContext = BrowserContext;
    async function prepareBrowserContextParams(options2) {
      if (options2.videoSize && !options2.videosPath)
        throw new Error(`"videoSize" option requires "videosPath" to be specified`);
      if (options2.extraHTTPHeaders)
        network.validateHeaders(options2.extraHTTPHeaders);
      const contextParams = {
        sdkLanguage: "javascript",
        ...options2,
        viewport: options2.viewport === null ? void 0 : options2.viewport,
        noDefaultViewport: options2.viewport === null,
        extraHTTPHeaders: options2.extraHTTPHeaders ? utils_1.headersObjectToArray(options2.extraHTTPHeaders) : void 0,
        storageState: typeof options2.storageState === "string" ? JSON.parse(await fsReadFileAsync(options2.storageState, "utf8")) : options2.storageState
      };
      if (!contextParams.recordVideo && options2.videosPath) {
        contextParams.recordVideo = {
          dir: options2.videosPath,
          size: options2.videoSize
        };
      }
      return contextParams;
    }
    exports2.prepareBrowserContextParams = prepareBrowserContextParams;
  }
});

// node_modules/playwright/lib/client/browser.js
var require_browser3 = __commonJS({
  "node_modules/playwright/lib/client/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Browser = void 0;
    var browserContext_1 = require_browserContext2();
    var channelOwner_1 = require_channelOwner();
    var events_1 = require_events();
    var errors_1 = require_errors();
    var cdpSession_1 = require_cdpSession();
    var Browser = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._contexts = new Set();
        this._isConnected = true;
        this._isRemote = false;
        this._name = initializer.name;
        this._channel.on("close", () => this._didClose());
        this._closedPromise = new Promise((f) => this.once(events_1.Events.Browser.Disconnected, f));
      }
      static from(browser) {
        return browser._object;
      }
      static fromNullable(browser) {
        return browser ? Browser.from(browser) : null;
      }
      async newContext(options2 = {}) {
        return this._wrapApiCall("browser.newContext", async (channel) => {
          const contextOptions = await browserContext_1.prepareBrowserContextParams(options2);
          const context = browserContext_1.BrowserContext.from((await channel.newContext(contextOptions)).context);
          context._options = contextOptions;
          this._contexts.add(context);
          context._logger = options2.logger || this._logger;
          return context;
        });
      }
      contexts() {
        return [...this._contexts];
      }
      version() {
        return this._initializer.version;
      }
      async newPage(options2 = {}) {
        const context = await this.newContext(options2);
        const page = await context.newPage();
        page._ownedContext = context;
        context._ownerPage = page;
        return page;
      }
      isConnected() {
        return this._isConnected;
      }
      async newBrowserCDPSession() {
        return this._wrapApiCall("browser.newBrowserCDPSession", async (channel) => {
          return cdpSession_1.CDPSession.from((await channel.newBrowserCDPSession()).session);
        });
      }
      async startTracing(page, options2 = {}) {
        return this._wrapApiCall("browser.startTracing", async (channel) => {
          await channel.startTracing({...options2, page: page ? page._channel : void 0});
        });
      }
      async stopTracing() {
        return this._wrapApiCall("browser.stopTracing", async (channel) => {
          return Buffer.from((await channel.stopTracing()).binary, "base64");
        });
      }
      async close() {
        try {
          await this._wrapApiCall("browser.close", async (channel) => {
            await channel.close();
            await this._closedPromise;
          });
        } catch (e) {
          if (errors_1.isSafeCloseError(e))
            return;
          throw e;
        }
      }
      _didClose() {
        this._isConnected = false;
        this.emit(events_1.Events.Browser.Disconnected, this);
      }
    };
    exports2.Browser = Browser;
  }
});

// node_modules/playwright/lib/client/browserType.js
var require_browserType2 = __commonJS({
  "node_modules/playwright/lib/client/browserType.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BrowserType = void 0;
    var browser_1 = require_browser3();
    var browserContext_1 = require_browserContext2();
    var channelOwner_1 = require_channelOwner();
    var ws_1 = __importDefault(require_ws());
    var connection_1 = require_connection();
    var serializers_1 = require_serializers();
    var events_1 = require_events();
    var timeoutSettings_1 = require_timeoutSettings();
    var clientHelper_1 = require_clientHelper();
    var utils_1 = require_utils();
    var errors_1 = require_errors();
    var BrowserType = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
      }
      static from(browserType) {
        return browserType._object;
      }
      executablePath() {
        if (!this._initializer.executablePath)
          throw new Error("Browser is not supported on current platform");
        return this._initializer.executablePath;
      }
      name() {
        return this._initializer.name;
      }
      async launch(options2 = {}) {
        const logger = options2.logger;
        return this._wrapApiCall("browserType.launch", async (channel) => {
          utils_1.assert(!options2.userDataDir, "userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead");
          utils_1.assert(!options2.port, "Cannot specify a port without launching as a server.");
          const launchOptions = {
            ...options2,
            ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
            env: options2.env ? clientHelper_1.envObjectToArray(options2.env) : void 0
          };
          const browser = browser_1.Browser.from((await channel.launch(launchOptions)).browser);
          browser._logger = logger;
          return browser;
        }, logger);
      }
      async launchServer(options2 = {}) {
        if (!this._serverLauncher)
          throw new Error("Launching server is not supported");
        return this._serverLauncher.launchServer(options2);
      }
      async launchPersistentContext(userDataDir, options2 = {}) {
        return this._wrapApiCall("browserType.launchPersistentContext", async (channel) => {
          utils_1.assert(!options2.port, "Cannot specify a port without launching as a server.");
          const contextParams = await browserContext_1.prepareBrowserContextParams(options2);
          const persistentParams = {
            ...contextParams,
            ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
            env: options2.env ? clientHelper_1.envObjectToArray(options2.env) : void 0,
            channel: options2.channel,
            userDataDir
          };
          const result = await channel.launchPersistentContext(persistentParams);
          const context = browserContext_1.BrowserContext.from(result.context);
          context._options = contextParams;
          context._logger = options2.logger;
          return context;
        }, options2.logger);
      }
      async connect(params) {
        const logger = params.logger;
        return this._wrapApiCall("browserType.connect", async () => {
          const connection = new connection_1.Connection();
          const ws = new ws_1.default(params.wsEndpoint, [], {
            perMessageDeflate: false,
            maxPayload: 256 * 1024 * 1024,
            handshakeTimeout: this._timeoutSettings.timeout(params),
            headers: params.headers
          });
          const waitForNextTask = params.slowMo ? (cb) => setTimeout(cb, params.slowMo) : utils_1.makeWaitForNextTask();
          connection.onmessage = (message) => {
            if (ws.readyState !== ws_1.default.OPEN) {
              setTimeout(() => {
                connection.dispatch({id: message.id, error: serializers_1.serializeError(new Error(errors_1.kBrowserClosedError))});
              }, 0);
              return;
            }
            ws.send(JSON.stringify(message));
          };
          ws.addEventListener("message", (event) => {
            waitForNextTask(() => {
              try {
                connection.dispatch(JSON.parse(event.data));
              } catch (e) {
                ws.close();
              }
            });
          });
          return await new Promise(async (fulfill, reject) => {
            if (params.__testHookBeforeCreateBrowser) {
              try {
                await params.__testHookBeforeCreateBrowser();
              } catch (e) {
                reject(e);
              }
            }
            ws.addEventListener("open", async () => {
              const prematureCloseListener = (event) => {
                reject(new Error("Server disconnected: " + event.reason));
              };
              ws.addEventListener("close", prematureCloseListener);
              const playwright2 = await connection.waitForObjectWithKnownName("Playwright");
              if (!playwright2._initializer.preLaunchedBrowser) {
                reject(new Error("Malformed endpoint. Did you use launchServer method?"));
                ws.close();
                return;
              }
              const browser = browser_1.Browser.from(playwright2._initializer.preLaunchedBrowser);
              browser._logger = logger;
              browser._isRemote = true;
              const closeListener = () => {
                for (const context of browser.contexts()) {
                  for (const page of context.pages())
                    page._onClose();
                  context._onClose();
                }
                browser._didClose();
              };
              ws.removeEventListener("close", prematureCloseListener);
              ws.addEventListener("close", closeListener);
              browser.on(events_1.Events.Browser.Disconnected, () => {
                playwright2._cleanup();
                ws.removeEventListener("close", closeListener);
                ws.close();
              });
              fulfill(browser);
            });
            ws.addEventListener("error", (event) => {
              ws.close();
              reject(new Error(event.message + ". Most likely ws endpoint is incorrect"));
            });
          });
        }, logger);
      }
      async connectOverCDP(params) {
        if (this.name() !== "chromium")
          throw new Error("Connecting over CDP is only supported in Chromium.");
        const logger = params.logger;
        return this._wrapApiCall("browserType.connectOverCDP", async (channel) => {
          const headers = params.headers ? utils_1.headersObjectToArray(params.headers) : void 0;
          const result = await channel.connectOverCDP({
            sdkLanguage: "javascript",
            endpointURL: "endpointURL" in params ? params.endpointURL : params.wsEndpoint,
            headers,
            slowMo: params.slowMo,
            timeout: params.timeout
          });
          const browser = browser_1.Browser.from(result.browser);
          if (result.defaultContext)
            browser._contexts.add(browserContext_1.BrowserContext.from(result.defaultContext));
          browser._isRemote = true;
          browser._logger = logger;
          return browser;
        }, logger);
      }
    };
    exports2.BrowserType = BrowserType;
  }
});

// node_modules/playwright/lib/client/selectors.js
var require_selectors2 = __commonJS({
  "node_modules/playwright/lib/client/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.sharedSelectors = exports2.SelectorsOwner = exports2.Selectors = void 0;
    var clientHelper_1 = require_clientHelper();
    var channelOwner_1 = require_channelOwner();
    var Selectors = class {
      constructor() {
        this._channels = new Set();
        this._registrations = [];
      }
      async register(name, script, options2 = {}) {
        const source = await clientHelper_1.evaluationScript(script, void 0, false);
        const params = {...options2, name, source};
        for (const channel of this._channels)
          await channel._channel.register(params);
        this._registrations.push(params);
      }
      _addChannel(channel) {
        this._channels.add(channel);
        for (const params of this._registrations) {
          channel._channel.register(params).catch((e) => {
          });
        }
      }
      _removeChannel(channel) {
        this._channels.delete(channel);
      }
    };
    exports2.Selectors = Selectors;
    var SelectorsOwner = class extends channelOwner_1.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
    };
    exports2.SelectorsOwner = SelectorsOwner;
    exports2.sharedSelectors = new Selectors();
  }
});

// node_modules/playwright/lib/client/electron.js
var require_electron3 = __commonJS({
  "node_modules/playwright/lib/client/electron.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.ElectronApplication = exports2.Electron = void 0;
    var timeoutSettings_1 = require_timeoutSettings();
    var browserContext_1 = require_browserContext2();
    var channelOwner_1 = require_channelOwner();
    var clientHelper_1 = require_clientHelper();
    var events_1 = require_events();
    var jsHandle_1 = require_jsHandle();
    var waiter_1 = require_waiter();
    var Electron = class extends channelOwner_1.ChannelOwner {
      static from(electron) {
        return electron._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      async launch(options2 = {}) {
        return this._wrapApiCall("electron.launch", async (channel) => {
          const params = {
            sdkLanguage: "javascript",
            ...options2,
            env: clientHelper_1.envObjectToArray(options2.env ? options2.env : process.env)
          };
          return ElectronApplication.from((await channel.launch(params)).electronApplication);
        });
      }
    };
    exports2.Electron = Electron;
    var ElectronApplication = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._windows = new Set();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._context = browserContext_1.BrowserContext.from(initializer.context);
        for (const page of this._context._pages)
          this._onPage(page);
        this._context.on(events_1.Events.BrowserContext.Page, (page) => this._onPage(page));
        this._channel.on("close", () => this.emit(events_1.Events.ElectronApplication.Close));
      }
      static from(electronApplication) {
        return electronApplication._object;
      }
      _onPage(page) {
        this._windows.add(page);
        this.emit(events_1.Events.ElectronApplication.Window, page);
        page.once(events_1.Events.Page.Close, () => this._windows.delete(page));
      }
      windows() {
        return [...this._windows];
      }
      async firstWindow() {
        return this._wrapApiCall("electronApplication.firstWindow", async (channel) => {
          if (this._windows.size)
            return this._windows.values().next().value;
          return this.waitForEvent("window");
        });
      }
      context() {
        return this._context;
      }
      async close() {
        await this._channel.close();
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, "electronApplication", event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.ElectronApplication.Close)
          waiter.rejectOnEvent(this, events_1.Events.ElectronApplication.Close, new Error("Electron application closed"));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
      }
      async browserWindow(page) {
        return this._wrapApiCall("electronApplication.browserWindow", async (channel) => {
          const result = await channel.browserWindow({page: page._channel});
          return jsHandle_1.JSHandle.from(result.handle);
        });
      }
      async evaluate(pageFunction, arg) {
        return this._wrapApiCall("electronApplication.evaluate", async (channel) => {
          const result = await channel.evaluateExpression({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.parseResult(result.value);
        });
      }
      async evaluateHandle(pageFunction, arg) {
        return this._wrapApiCall("electronApplication.evaluateHandle", async (channel) => {
          const result = await channel.evaluateExpressionHandle({expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: jsHandle_1.serializeArgument(arg)});
          return jsHandle_1.JSHandle.from(result.handle);
        });
      }
    };
    exports2.ElectronApplication = ElectronApplication;
  }
});

// node_modules/playwright/lib/client/android.js
var require_android2 = __commonJS({
  "node_modules/playwright/lib/client/android.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.AndroidWebView = exports2.AndroidInput = exports2.AndroidSocket = exports2.AndroidDevice = exports2.Android = void 0;
    var fs_1 = __importDefault(require("fs"));
    var util = __importStar(require("util"));
    var utils_1 = require_utils();
    var events_1 = require_events();
    var browserContext_1 = require_browserContext2();
    var channelOwner_1 = require_channelOwner();
    var timeoutSettings_1 = require_timeoutSettings();
    var waiter_1 = require_waiter();
    var events_2 = require("events");
    var Android = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
      }
      static from(android) {
        return android._object;
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({timeout});
      }
      async devices() {
        return this._wrapApiCall("android.devices", async (channel) => {
          const {devices: devices2} = await channel.devices();
          return devices2.map((d) => AndroidDevice.from(d));
        });
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._webViews = new Map();
        this.input = new AndroidInput(this);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(parent._timeoutSettings);
        this._channel.on("webViewAdded", ({webView}) => this._onWebViewAdded(webView));
        this._channel.on("webViewRemoved", ({pid}) => this._onWebViewRemoved(pid));
      }
      static from(androidDevice) {
        return androidDevice._object;
      }
      _onWebViewAdded(webView) {
        const view = new AndroidWebView(this, webView);
        this._webViews.set(webView.pid, view);
        this.emit(events_1.Events.AndroidDevice.WebView, view);
      }
      _onWebViewRemoved(pid) {
        const view = this._webViews.get(pid);
        this._webViews.delete(pid);
        if (view)
          view.emit(events_1.Events.AndroidWebView.Close);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({timeout});
      }
      serial() {
        return this._initializer.serial;
      }
      model() {
        return this._initializer.model;
      }
      webViews() {
        return [...this._webViews.values()];
      }
      async webView(selector, options2) {
        const webView = [...this._webViews.values()].find((v) => v.pkg() === selector.pkg);
        if (webView)
          return webView;
        return this.waitForEvent("webview", {
          ...options2,
          predicate: (view) => view.pkg() === selector.pkg
        });
      }
      async wait(selector, options2) {
        await this._wrapApiCall("androidDevice.wait", async (channel) => {
          await channel.wait({selector: toSelectorChannel(selector), ...options2});
        });
      }
      async fill(selector, text, options2) {
        await this._wrapApiCall("androidDevice.fill", async (channel) => {
          await channel.fill({selector: toSelectorChannel(selector), text, ...options2});
        });
      }
      async press(selector, key, options2) {
        await this.tap(selector, options2);
        await this.input.press(key);
      }
      async tap(selector, options2) {
        await this._wrapApiCall("androidDevice.tap", async (channel) => {
          await channel.tap({selector: toSelectorChannel(selector), ...options2});
        });
      }
      async drag(selector, dest, options2) {
        await this._wrapApiCall("androidDevice.drag", async (channel) => {
          await channel.drag({selector: toSelectorChannel(selector), dest, ...options2});
        });
      }
      async fling(selector, direction, options2) {
        await this._wrapApiCall("androidDevice.fling", async (channel) => {
          await channel.fling({selector: toSelectorChannel(selector), direction, ...options2});
        });
      }
      async longTap(selector, options2) {
        await this._wrapApiCall("androidDevice.longTap", async (channel) => {
          await channel.longTap({selector: toSelectorChannel(selector), ...options2});
        });
      }
      async pinchClose(selector, percent, options2) {
        await this._wrapApiCall("androidDevice.pinchClose", async (channel) => {
          await channel.pinchClose({selector: toSelectorChannel(selector), percent, ...options2});
        });
      }
      async pinchOpen(selector, percent, options2) {
        await this._wrapApiCall("androidDevice.pinchOpen", async (channel) => {
          await channel.pinchOpen({selector: toSelectorChannel(selector), percent, ...options2});
        });
      }
      async scroll(selector, direction, percent, options2) {
        await this._wrapApiCall("androidDevice.scroll", async (channel) => {
          await channel.scroll({selector: toSelectorChannel(selector), direction, percent, ...options2});
        });
      }
      async swipe(selector, direction, percent, options2) {
        await this._wrapApiCall("androidDevice.swipe", async (channel) => {
          await channel.swipe({selector: toSelectorChannel(selector), direction, percent, ...options2});
        });
      }
      async info(selector) {
        return await this._wrapApiCall("androidDevice.info", async (channel) => {
          return (await channel.info({selector: toSelectorChannel(selector)})).info;
        });
      }
      async screenshot(options2 = {}) {
        return await this._wrapApiCall("androidDevice.screenshot", async (channel) => {
          const {binary} = await channel.screenshot();
          const buffer = Buffer.from(binary, "base64");
          if (options2.path)
            await util.promisify(fs_1.default.writeFile)(options2.path, buffer);
          return buffer;
        });
      }
      async close() {
        return this._wrapApiCall("androidDevice.close", async (channel) => {
          await channel.close();
          this.emit(events_1.Events.AndroidDevice.Close);
        });
      }
      async shell(command) {
        return this._wrapApiCall("androidDevice.shell", async (channel) => {
          const {result} = await channel.shell({command});
          return Buffer.from(result, "base64");
        });
      }
      async open(command) {
        return this._wrapApiCall("androidDevice.open", async (channel) => {
          return AndroidSocket.from((await channel.open({command})).socket);
        });
      }
      async installApk(file, options2) {
        return this._wrapApiCall("androidDevice.installApk", async (channel) => {
          await channel.installApk({file: await loadFile(file), args: options2 && options2.args});
        });
      }
      async push(file, path, options2) {
        return this._wrapApiCall("androidDevice.push", async (channel) => {
          await channel.push({file: await loadFile(file), path, mode: options2 ? options2.mode : void 0});
        });
      }
      async launchBrowser(options2 = {}) {
        return this._wrapApiCall("androidDevice.launchBrowser", async (channel) => {
          const contextOptions = await browserContext_1.prepareBrowserContextParams(options2);
          const {context} = await channel.launchBrowser(contextOptions);
          return browserContext_1.BrowserContext.from(context);
        });
      }
      async waitForEvent(event, optionsOrPredicate = {}) {
        const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
        const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
        const waiter = waiter_1.Waiter.createForEvent(this, "androidDevice", event);
        waiter.rejectOnTimeout(timeout, `Timeout while waiting for event "${event}"`);
        if (event !== events_1.Events.AndroidDevice.Close)
          waiter.rejectOnEvent(this, events_1.Events.AndroidDevice.Close, new Error("Device closed"));
        const result = await waiter.waitForEvent(this, event, predicate);
        waiter.dispose();
        return result;
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    var AndroidSocket = class extends channelOwner_1.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("data", ({data}) => this.emit(events_1.Events.AndroidSocket.Data, Buffer.from(data, "base64")));
        this._channel.on("close", () => this.emit(events_1.Events.AndroidSocket.Close));
      }
      async write(data) {
        return this._wrapApiCall("androidDevice.write", async (channel) => {
          await channel.write({data: data.toString("base64")});
        });
      }
      async close() {
        return this._wrapApiCall("androidDevice.close", async (channel) => {
          await channel.close();
        });
      }
    };
    exports2.AndroidSocket = AndroidSocket;
    async function loadFile(file) {
      if (utils_1.isString(file))
        return (await util.promisify(fs_1.default.readFile)(file)).toString("base64");
      return file.toString("base64");
    }
    var AndroidInput = class {
      constructor(device) {
        this._device = device;
      }
      async type(text) {
        return this._device._wrapApiCall("androidDevice.inputType", async (channel) => {
          await channel.inputType({text});
        });
      }
      async press(key) {
        return this._device._wrapApiCall("androidDevice.inputPress", async (channel) => {
          await channel.inputPress({key});
        });
      }
      async tap(point) {
        return this._device._wrapApiCall("androidDevice.inputTap", async (channel) => {
          await channel.inputTap({point});
        });
      }
      async swipe(from, segments, steps) {
        return this._device._wrapApiCall("androidDevice.inputSwipe", async (channel) => {
          await channel.inputSwipe({segments, steps});
        });
      }
      async drag(from, to, steps) {
        return this._device._wrapApiCall("androidDevice.inputDragAndDrop", async (channel) => {
          await channel.inputDrag({from, to, steps});
        });
      }
    };
    exports2.AndroidInput = AndroidInput;
    function toSelectorChannel(selector) {
      const {checkable, checked, clazz, clickable, depth, desc, enabled, focusable, focused, hasChild, hasDescendant, longClickable, pkg: pkg2, res, scrollable, selected, text} = selector;
      const toRegex = (value) => {
        if (value === void 0)
          return void 0;
        if (value instanceof RegExp)
          return value.source;
        return "^" + value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") + "$";
      };
      return {
        checkable,
        checked,
        clazz: toRegex(clazz),
        pkg: toRegex(pkg2),
        desc: toRegex(desc),
        res: toRegex(res),
        text: toRegex(text),
        clickable,
        depth,
        enabled,
        focusable,
        focused,
        hasChild: hasChild ? {selector: toSelectorChannel(hasChild.selector)} : void 0,
        hasDescendant: hasDescendant ? {selector: toSelectorChannel(hasDescendant.selector), maxDepth: hasDescendant.maxDepth} : void 0,
        longClickable,
        scrollable,
        selected
      };
    }
    var AndroidWebView = class extends events_2.EventEmitter {
      constructor(device, data) {
        super();
        this._device = device;
        this._data = data;
      }
      pid() {
        return this._data.pid;
      }
      pkg() {
        return this._data.pkg;
      }
      async page() {
        if (!this._pagePromise)
          this._pagePromise = this._fetchPage();
        return this._pagePromise;
      }
      async _fetchPage() {
        return this._device._wrapApiCall("androidWebView.page", async (channel) => {
          const {context} = await channel.connectToWebView({pid: this._data.pid, sdkLanguage: "javascript"});
          return browserContext_1.BrowserContext.from(context).pages()[0];
        });
      }
    };
    exports2.AndroidWebView = AndroidWebView;
  }
});

// node_modules/playwright/lib/client/playwright.js
var require_playwright2 = __commonJS({
  "node_modules/playwright/lib/client/playwright.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Playwright = void 0;
    var browserType_1 = require_browserType2();
    var channelOwner_1 = require_channelOwner();
    var selectors_1 = require_selectors2();
    var electron_1 = require_electron3();
    var errors_1 = require_errors();
    var android_1 = require_android2();
    var Playwright = class extends channelOwner_1.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this.chromium = browserType_1.BrowserType.from(initializer.chromium);
        this.firefox = browserType_1.BrowserType.from(initializer.firefox);
        this.webkit = browserType_1.BrowserType.from(initializer.webkit);
        this._android = android_1.Android.from(initializer.android);
        this._electron = electron_1.Electron.from(initializer.electron);
        this.devices = {};
        for (const {name, descriptor} of initializer.deviceDescriptors)
          this.devices[name] = descriptor;
        this.selectors = selectors_1.sharedSelectors;
        this.errors = {TimeoutError: errors_1.TimeoutError};
        this._selectorsOwner = selectors_1.SelectorsOwner.from(initializer.selectors);
        this.selectors._addChannel(this._selectorsOwner);
      }
      _cleanup() {
        this.selectors._removeChannel(this._selectorsOwner);
      }
    };
    exports2.Playwright = Playwright;
  }
});

// node_modules/playwright/lib/client/connection.js
var require_connection = __commonJS({
  "node_modules/playwright/lib/client/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Connection = void 0;
    var browser_1 = require_browser3();
    var browserContext_1 = require_browserContext2();
    var browserType_1 = require_browserType2();
    var channelOwner_1 = require_channelOwner();
    var elementHandle_1 = require_elementHandle();
    var frame_1 = require_frame();
    var jsHandle_1 = require_jsHandle();
    var network_1 = require_network2();
    var page_1 = require_page2();
    var worker_1 = require_worker();
    var consoleMessage_1 = require_consoleMessage();
    var dialog_1 = require_dialog2();
    var serializers_1 = require_serializers();
    var cdpSession_1 = require_cdpSession();
    var playwright_1 = require_playwright2();
    var electron_1 = require_electron3();
    var stream_1 = require_stream2();
    var debugLogger_1 = require_debugLogger();
    var selectors_1 = require_selectors2();
    var utils_1 = require_utils();
    var android_1 = require_android2();
    var stackTrace_1 = require_stackTrace();
    var artifact_1 = require_artifact2();
    var Root2 = class extends channelOwner_1.ChannelOwner {
      constructor(connection) {
        super(connection, "", "", {});
      }
    };
    var Connection = class {
      constructor() {
        this._objects = new Map();
        this._waitingForObject = new Map();
        this.onmessage = (message) => {
        };
        this._lastId = 0;
        this._callbacks = new Map();
        this._rootObject = new Root2(this);
      }
      async waitForObjectWithKnownName(guid) {
        if (this._objects.has(guid))
          return this._objects.get(guid);
        return new Promise((f) => this._waitingForObject.set(guid, f));
      }
      getObjectWithKnownName(guid) {
        return this._objects.get(guid);
      }
      async sendMessageToServer(guid, method, params, apiName) {
        const {stack, frames} = stackTrace_1.captureStackTrace();
        const id = ++this._lastId;
        const converted = {id, guid, method, params};
        debugLogger_1.debugLogger.log("channel:command", converted);
        this.onmessage({...converted, metadata: {stack: frames, apiName}});
        try {
          return await new Promise((resolve2, reject) => this._callbacks.set(id, {resolve: resolve2, reject}));
        } catch (e) {
          const innerStack = (process.env.PWDEBUGIMPL || utils_1.isUnderTest()) && e.stack ? e.stack.substring(e.stack.indexOf(e.message) + e.message.length) : "";
          e.stack = e.message + innerStack + "\n" + stack;
          throw e;
        }
      }
      _debugScopeState() {
        return this._rootObject._debugScopeState();
      }
      dispatch(message) {
        const {id, guid, method, params, result, error: error3} = message;
        if (id) {
          debugLogger_1.debugLogger.log("channel:response", message);
          const callback = this._callbacks.get(id);
          if (!callback)
            throw new Error(`Cannot find command to respond: ${id}`);
          this._callbacks.delete(id);
          if (error3)
            callback.reject(serializers_1.parseError(error3));
          else
            callback.resolve(this._replaceGuidsWithChannels(result));
          return;
        }
        debugLogger_1.debugLogger.log("channel:event", message);
        if (method === "__create__") {
          this._createRemoteObject(guid, params.type, params.guid, params.initializer);
          return;
        }
        if (method === "__dispose__") {
          const object2 = this._objects.get(guid);
          if (!object2)
            throw new Error(`Cannot find object to dispose: ${guid}`);
          object2._dispose();
          return;
        }
        const object = this._objects.get(guid);
        if (!object)
          throw new Error(`Cannot find object to emit "${method}": ${guid}`);
        object._channel.emit(method, this._replaceGuidsWithChannels(params));
      }
      _replaceGuidsWithChannels(payload) {
        if (!payload)
          return payload;
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceGuidsWithChannels(p));
        if (payload.guid && this._objects.has(payload.guid))
          return this._objects.get(payload.guid)._channel;
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceGuidsWithChannels(payload[key]);
          return result;
        }
        return payload;
      }
      _createRemoteObject(parentGuid, type, guid, initializer) {
        const parent = this._objects.get(parentGuid);
        if (!parent)
          throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
        let result;
        initializer = this._replaceGuidsWithChannels(initializer);
        switch (type) {
          case "Android":
            result = new android_1.Android(parent, type, guid, initializer);
            break;
          case "AndroidSocket":
            result = new android_1.AndroidSocket(parent, type, guid, initializer);
            break;
          case "AndroidDevice":
            result = new android_1.AndroidDevice(parent, type, guid, initializer);
            break;
          case "Artifact":
            result = new artifact_1.Artifact(parent, type, guid, initializer);
            break;
          case "BindingCall":
            result = new page_1.BindingCall(parent, type, guid, initializer);
            break;
          case "Browser":
            result = new browser_1.Browser(parent, type, guid, initializer);
            break;
          case "BrowserContext":
            result = new browserContext_1.BrowserContext(parent, type, guid, initializer);
            break;
          case "BrowserType":
            result = new browserType_1.BrowserType(parent, type, guid, initializer);
            break;
          case "CDPSession":
            result = new cdpSession_1.CDPSession(parent, type, guid, initializer);
            break;
          case "ConsoleMessage":
            result = new consoleMessage_1.ConsoleMessage(parent, type, guid, initializer);
            break;
          case "Dialog":
            result = new dialog_1.Dialog(parent, type, guid, initializer);
            break;
          case "Electron":
            result = new electron_1.Electron(parent, type, guid, initializer);
            break;
          case "ElectronApplication":
            result = new electron_1.ElectronApplication(parent, type, guid, initializer);
            break;
          case "ElementHandle":
            result = new elementHandle_1.ElementHandle(parent, type, guid, initializer);
            break;
          case "Frame":
            result = new frame_1.Frame(parent, type, guid, initializer);
            break;
          case "JSHandle":
            result = new jsHandle_1.JSHandle(parent, type, guid, initializer);
            break;
          case "Page":
            result = new page_1.Page(parent, type, guid, initializer);
            break;
          case "Playwright":
            result = new playwright_1.Playwright(parent, type, guid, initializer);
            break;
          case "Request":
            result = new network_1.Request(parent, type, guid, initializer);
            break;
          case "Response":
            result = new network_1.Response(parent, type, guid, initializer);
            break;
          case "Route":
            result = new network_1.Route(parent, type, guid, initializer);
            break;
          case "Stream":
            result = new stream_1.Stream(parent, type, guid, initializer);
            break;
          case "Selectors":
            result = new selectors_1.SelectorsOwner(parent, type, guid, initializer);
            break;
          case "WebSocket":
            result = new network_1.WebSocket(parent, type, guid, initializer);
            break;
          case "Worker":
            result = new worker_1.Worker(parent, type, guid, initializer);
            break;
          default:
            throw new Error("Missing type " + type);
        }
        const callback = this._waitingForObject.get(guid);
        if (callback) {
          callback(result);
          this._waitingForObject.delete(guid);
        }
        return result;
      }
    };
    exports2.Connection = Connection;
  }
});

// node_modules/playwright/lib/remote/playwrightServer.js
var require_playwrightServer = __commonJS({
  "node_modules/playwright/lib/remote/playwrightServer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {"default": mod};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.PlaywrightServer = void 0;
    var debug_1 = __importDefault(require_src());
    var http2 = __importStar(require("http"));
    var ws = __importStar(require_ws());
    var dispatcher_1 = require_dispatcher();
    var playwrightDispatcher_1 = require_playwrightDispatcher();
    var playwright_1 = require_playwright();
    var processLauncher_1 = require_processLauncher();
    var selectors_1 = require_selectors();
    var debugLog = debug_1.default("pw:server");
    var PlaywrightServer = class {
      constructor(delegate) {
        this._clientsCount = 0;
        this._delegate = delegate;
      }
      static async startDefault(port = 0) {
        const cleanup = async () => {
          await processLauncher_1.gracefullyCloseAll().catch((e) => {
          });
          selectors_1.serverSelectors.unregisterAll();
        };
        const delegate = {
          path: "/ws",
          allowMultipleClients: false,
          onClose: cleanup,
          onConnect: (rootScope) => {
            new playwrightDispatcher_1.PlaywrightDispatcher(rootScope, playwright_1.createPlaywright());
            return cleanup;
          }
        };
        const server = new PlaywrightServer(delegate);
        return server.listen(port);
      }
      async listen(port = 0) {
        const server = http2.createServer((request, response) => {
          response.end("Running");
        });
        server.on("error", (error3) => debugLog(error3));
        const path = this._delegate.path;
        const wsEndpoint = await new Promise((resolve2) => {
          server.listen(port, () => {
            const address = server.address();
            const wsEndpoint2 = typeof address === "string" ? `${address}${path}` : `ws://127.0.0.1:${address.port}${path}`;
            resolve2(wsEndpoint2);
          });
        });
        debugLog("Listening at " + wsEndpoint);
        this._wsServer = new ws.Server({server, path});
        this._wsServer.on("connection", async (socket) => {
          if (this._clientsCount && !this._delegate.allowMultipleClients) {
            socket.close();
            return;
          }
          this._clientsCount++;
          debugLog("Incoming connection");
          const connection = new dispatcher_1.DispatcherConnection();
          connection.onmessage = (message) => {
            if (socket.readyState !== ws.CLOSING)
              socket.send(JSON.stringify(message));
          };
          socket.on("message", (message) => {
            connection.dispatch(JSON.parse(Buffer.from(message).toString()));
          });
          const scope = connection.rootDispatcher();
          const onDisconnect = this._delegate.onConnect(scope);
          const disconnect = () => {
            this._clientsCount--;
            connection.onmessage = () => {
            };
            onDisconnect();
          };
          socket.on("close", () => {
            debugLog("Client closed");
            disconnect();
          });
          socket.on("error", (error3) => {
            debugLog("Client error " + error3);
            disconnect();
          });
        });
        return wsEndpoint;
      }
      async close() {
        if (!this._wsServer)
          return;
        debugLog("Closing server");
        await new Promise((f) => this._wsServer.close(f));
        await new Promise((f) => this._wsServer.options.server.close(f));
        await this._delegate.onClose();
      }
    };
    exports2.PlaywrightServer = PlaywrightServer;
  }
});

// node_modules/playwright/lib/browserServerImpl.js
var require_browserServerImpl = __commonJS({
  "node_modules/playwright/lib/browserServerImpl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.BrowserServerLauncherImpl = void 0;
    var ws_1 = require_ws();
    var browserDispatcher_1 = require_browserDispatcher();
    var clientHelper_1 = require_clientHelper();
    var utils_1 = require_utils();
    var selectorsDispatcher_1 = require_selectorsDispatcher();
    var selectors_1 = require_selectors();
    var instrumentation_1 = require_instrumentation();
    var playwrightDispatcher_1 = require_playwrightDispatcher();
    var playwrightServer_1 = require_playwrightServer();
    var BrowserServerLauncherImpl = class {
      constructor(playwright2, browserType) {
        this._playwright = playwright2;
        this._browserType = browserType;
      }
      async launchServer(options2 = {}) {
        const browser = await this._browserType.launch(instrumentation_1.internalCallMetadata(), {
          ...options2,
          ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
          ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
          env: options2.env ? clientHelper_1.envObjectToArray(options2.env) : void 0
        }, toProtocolLogger(options2.logger));
        const delegate = {
          path: "/" + utils_1.createGuid(),
          allowMultipleClients: true,
          onClose: () => {
          },
          onConnect: this._onConnect.bind(this, browser)
        };
        const server = new playwrightServer_1.PlaywrightServer(delegate);
        const wsEndpoint = await server.listen(options2.port);
        const browserServer = new ws_1.EventEmitter();
        browserServer.process = () => browser.options.browserProcess.process;
        browserServer.wsEndpoint = () => wsEndpoint;
        browserServer.close = () => browser.options.browserProcess.close();
        browserServer.kill = () => browser.options.browserProcess.kill();
        browser.options.browserProcess.onclose = async (exitCode, signal) => {
          server.close();
          browserServer.emit("close", exitCode, signal);
        };
        return browserServer;
      }
      _onConnect(browser, scope) {
        const selectors2 = new selectors_1.Selectors();
        const selectorsDispatcher = new selectorsDispatcher_1.SelectorsDispatcher(scope, selectors2);
        const browserDispatcher = new ConnectedBrowser(scope, browser, selectors2);
        new playwrightDispatcher_1.PlaywrightDispatcher(scope, this._playwright, selectorsDispatcher, browserDispatcher);
        return () => {
          browserDispatcher.close().catch((e) => {
          });
        };
      }
    };
    exports2.BrowserServerLauncherImpl = BrowserServerLauncherImpl;
    var ConnectedBrowser = class extends browserDispatcher_1.BrowserDispatcher {
      constructor(scope, browser, selectors2) {
        super(scope, browser);
        this._contexts = [];
        this._closed = false;
        this._selectors = selectors2;
      }
      async newContext(params, metadata) {
        if (params.recordVideo) {
          params.recordVideo.dir = this._object.options.downloadsPath;
        }
        const result = await super.newContext(params, metadata);
        const dispatcher = result.context;
        dispatcher._object._setSelectors(this._selectors);
        this._contexts.push(dispatcher);
        return result;
      }
      async close() {
        await Promise.all(this._contexts.map((context) => context.close({}, instrumentation_1.internalCallMetadata())));
        this._didClose();
      }
      _didClose() {
        if (!this._closed) {
          this._closed = true;
          super._didClose();
        }
      }
    };
    function toProtocolLogger(logger) {
      return logger ? (direction, message) => {
        if (logger.isEnabled("protocol", "verbose"))
          logger.log("protocol", "verbose", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message), [], {});
      } : void 0;
    }
  }
});

// node_modules/playwright/lib/inprocess.js
var require_inprocess = __commonJS({
  "node_modules/playwright/lib/inprocess.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var dispatcher_1 = require_dispatcher();
    var playwright_1 = require_playwright();
    var playwrightDispatcher_1 = require_playwrightDispatcher();
    var connection_1 = require_connection();
    var browserServerImpl_1 = require_browserServerImpl();
    function setupInProcess() {
      const playwright2 = playwright_1.createPlaywright();
      const clientConnection = new connection_1.Connection();
      const dispatcherConnection = new dispatcher_1.DispatcherConnection();
      dispatcherConnection.onmessage = (message) => clientConnection.dispatch(message);
      clientConnection.onmessage = (message) => dispatcherConnection.dispatch(message);
      new playwrightDispatcher_1.PlaywrightDispatcher(dispatcherConnection.rootDispatcher(), playwright2);
      const playwrightAPI = clientConnection.getObjectWithKnownName("Playwright");
      playwrightAPI.chromium._serverLauncher = new browserServerImpl_1.BrowserServerLauncherImpl(playwright2, playwright2.chromium);
      playwrightAPI.firefox._serverLauncher = new browserServerImpl_1.BrowserServerLauncherImpl(playwright2, playwright2.firefox);
      playwrightAPI.webkit._serverLauncher = new browserServerImpl_1.BrowserServerLauncherImpl(playwright2, playwright2.webkit);
      dispatcherConnection.onmessage = (message) => setImmediate(() => clientConnection.dispatch(message));
      clientConnection.onmessage = (message) => setImmediate(() => dispatcherConnection.dispatch(message));
      playwrightAPI._toImpl = (x) => dispatcherConnection._dispatchers.get(x._guid)._object;
      return playwrightAPI;
    }
    module2.exports = setupInProcess();
  }
});

// node_modules/playwright/index.js
var require_playwright3 = __commonJS({
  "node_modules/playwright/index.js"(exports2, module2) {
    module2.exports = require_inprocess();
  }
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    var isES5 = function() {
      "use strict";
      return this === void 0;
    }();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = function(o) {
        var ret2 = [];
        for (var key in o) {
          if (has.call(o, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      };
      ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
      };
      ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
      };
      ObjectFreeze = function(obj) {
        return obj;
      };
      ObjectGetPrototypeOf = function(obj) {
        try {
          return Object(obj).constructor.prototype;
        } catch (e) {
          return proto;
        }
      };
      ArrayIsArray = function(obj) {
        try {
          return str.call(obj) === "[object Array]";
        } catch (e) {
          return false;
        }
      };
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// node_modules/bluebird/js/release/util.js
var require_util = __commonJS({
  "node_modules/bluebird/js/release/util.js"(exports, module) {
    "use strict";
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = {e: {}};
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    var inherits = function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      T.prototype = Parent.prototype;
      Child.prototype = new T();
      return Child.prototype;
    };
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError))
        return maybeError;
      return new Error(safeToString(maybeError));
    }
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i;
      for (i = 0; i < len; ++i) {
        ret2[i] = target[i];
      }
      ret2[i] = appendee;
      return ret2;
    }
    function getDataPropertyOrDefault(obj, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
      }
    }
    function notEnumerableProp(obj, name, value) {
      if (isPrimitive(obj))
        return obj;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj, name, descriptor);
      return obj;
    }
    function thrower(r) {
      throw r;
    }
    var inheritedDataKeys = function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
          if (excludedPrototypes[i] === val) {
            return true;
          }
        }
        return false;
      };
      if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
          var ret2 = [];
          var visitedKeys = Object.create(null);
          while (obj != null && !isExcludedProto(obj)) {
            var keys;
            try {
              keys = getKeys(obj);
            } catch (e) {
              return ret2;
            }
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (visitedKeys[key])
                continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj = es5.getPrototypeOf(obj);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
          if (isExcludedProto(obj))
            return [];
          var ret2 = [];
          enumeration:
            for (var key in obj) {
              if (hasProp.call(obj, key)) {
                ret2.push(key);
              } else {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (hasProp.call(excludedPrototypes[i], key)) {
                    continue enumeration;
                  }
                }
                ret2.push(key);
              }
            }
          return ret2;
        };
      }
    }();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
      try {
        if (typeof fn === "function") {
          var keys = es5.names(fn.prototype);
          var hasMethods = es5.isES5 && keys.length > 1;
          var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = obj;
      var receiver = new FakeConstructor();
      function ic() {
        return typeof receiver.foo;
      }
      ic();
      ic();
      return obj;
      eval(obj);
    }
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    function filledRange(count, prefix, suffix) {
      var ret2 = new Array(count);
      for (var i = 0; i < count; ++i) {
        ret2[i] = prefix + i + suffix;
      }
      return ret2;
    }
    function safeToString(obj) {
      try {
        return obj + "";
      } catch (e) {
        return "[no string representation]";
      }
    }
    function isError(obj) {
      return obj instanceof Error || obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
    }
    function markAsOriginatingFromRejection(e) {
      try {
        notEnumerableProp(e, "isOperational", true);
      } catch (ignore) {
      }
    }
    function originatesFromRejection(e) {
      if (e == null)
        return false;
      return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
    }
    function canAttachTrace(obj) {
      return isError(obj) && es5.propertyIsWritable(obj, "stack");
    }
    var ensureErrorObject = function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          return new Error(safeToString(value));
        };
      }
    }();
    function classString(obj) {
      return {}.toString.call(obj);
    }
    function copyDescriptors(from, to, filter) {
      var keys = es5.names(from);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
          try {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    var asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      }
      return null;
    };
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
      } : function(v) {
        var ret2 = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
          return ArrayFrom(v);
        }
        return null;
      };
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if (classString(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e) {
        }
      }
    }
    var reflectHandler;
    function contextBind(ctx, cb) {
      if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
        return cb;
      }
      if (ctx.domain !== null) {
        cb = ctx.domain.bind(cb);
      }
      var async = ctx.async;
      if (async !== null) {
        var old = cb;
        cb = function() {
          var $_len = arguments.length + 2;
          var args = new Array($_len);
          for (var $_i = 2; $_i < $_len; ++$_i) {
            args[$_i] = arguments[$_i - 2];
          }
          ;
          args[0] = old;
          args[1] = this;
          return async.runInAsyncScope.apply(async, args);
        };
      }
      return cb;
    }
    var ret = {
      setReflectHandler: function(fn) {
        reflectHandler = fn;
      },
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      contextBind
    };
    ret.isRecentNode = ret.isNode && function() {
      var version;
      if (process.versions && process.versions.node) {
        version = process.versions.node.split(".").map(Number);
      } else if (process.version) {
        version = process.version.split(".").map(Number);
      }
      return version[0] === 0 && version[1] > 10 || version[0] > 0;
    }();
    ret.nodeSupportsAsyncResource = ret.isNode && function() {
      var supportsAsync = false;
      try {
        var res = require("async_hooks").AsyncResource;
        supportsAsync = typeof res.prototype.runInAsyncScope === "function";
      } catch (e) {
        supportsAsync = false;
      }
      return supportsAsync;
    }();
    if (ret.isNode)
      ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e) {
      ret.lastLineError = e;
    }
    module.exports = ret;
  }
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var schedule;
    var noAsyncScheduler = function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    };
    var NativePromise = util.getNativePromise();
    if (util.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
      } : function(fn) {
        ProcessNextTick.call(process, fn);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = function(fn) {
        nativePromise.then(fn);
      };
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement) {
      schedule = function() {
        var div = document.createElement("div");
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
          if (toggleScheduled)
            return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        };
        return function schedule2(fn) {
          var o = new MutationObserver(function() {
            o.disconnect();
            fn();
          });
          o.observe(div, opts);
          scheduleToggle();
        };
      }();
    } else if (typeof setImmediate !== "undefined") {
      schedule = function(fn) {
        setImmediate(fn);
      };
    } else if (typeof setTimeout !== "undefined") {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS({
  "node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    "use strict";
    function arrayMove(src2, srcIndex, dst, dstIndex, len) {
      for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src2[j + srcIndex];
        src2[j + srcIndex] = void 0;
      }
    }
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size) {
      return this._capacity < size;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this[i] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn, receiver, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
      }
      var j = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j + 0 & wrapMask] = fn;
      this[j + 1 & wrapMask] = receiver;
      this[j + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size) {
      if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS({
  "node_modules/bluebird/js/release/async.js"(exports2, module2) {
    "use strict";
    var firstLineError;
    try {
      throw new Error();
    } catch (e) {
      firstLineError = e;
    }
    var schedule = require_schedule();
    var Queue = require_queue();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    Async.prototype.setScheduler = function(fn) {
      var prev = this._schedule;
      this._schedule = fn;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e, isNode2) {
      if (isNode2) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e);
      }
    };
    Async.prototype.throwLater = function(fn, arg) {
      if (arguments.length === 1) {
        arg = fn;
        fn = function() {
          throw arg;
        };
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn(arg);
        }, 0);
      } else
        try {
          this._schedule(function() {
            fn(arg);
          });
        } catch (e) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    };
    function AsyncInvokeLater(fn, receiver, arg) {
      this._lateQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncInvoke(fn, receiver, arg) {
      this._normalQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
    function _drainQueue(queue) {
      while (queue.length() > 0) {
        _drainQueueStep(queue);
      }
    }
    function _drainQueueStep(queue) {
      var fn = queue.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
      } else {
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
      }
    }
    Async.prototype._drainQueues = function() {
      _drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      _drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// node_modules/bluebird/js/release/errors.js
var require_errors2 = __commonJS({
  "node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    "use strict";
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util = require_util();
    var inherits2 = util.inherits;
    var notEnumerableProp2 = util.notEnumerableProp;
    function subError(nameProperty, defaultMessage) {
      function SubError(message) {
        if (!(this instanceof SubError))
          return new SubError(message);
        notEnumerableProp2(this, "message", typeof message === "string" ? message : defaultMessage);
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      inherits2(SubError, Error);
      return SubError;
    }
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (var i = 0; i < methods.length; ++i) {
      if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
      }
    }
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i2 = 0; i2 < this.length; ++i2) {
        var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
          lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var util = require_util();
      var errorObj2 = util.errorObj;
      var isObject2 = util.isObject;
      function tryConvertToPromise(obj, context) {
        if (isObject2(obj)) {
          if (obj instanceof Promise2)
            return obj;
          var then = getThen(obj);
          if (then === errorObj2) {
            if (context)
              context._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context)
              context._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
              var ret2 = new Promise2(INTERNAL);
              obj._then(ret2._fulfill, ret2._reject, void 0, ret2, null);
              return ret2;
            }
            return doThenable(obj, then, context);
          }
        }
        return obj;
      }
      function doGetThen(obj) {
        return obj.then;
      }
      function getThen(obj) {
        try {
          return doGetThen(obj);
        } catch (e) {
          errorObj2.e = e;
          return errorObj2;
        }
      }
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj) {
        try {
          return hasProp.call(obj, "_promise0");
        } catch (e) {
          return false;
        }
      }
      function doThenable(x, then, context) {
        var promise = new Promise2(INTERNAL);
        var ret2 = promise;
        if (context)
          context._pushContext();
        promise._captureStackTrace();
        if (context)
          context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve2, reject);
        synchronous = false;
        if (promise && result === errorObj2) {
          promise._rejectCallback(result.e, true, true);
          promise = null;
        }
        function resolve2(value) {
          if (!promise)
            return;
          promise._resolveCallback(value);
          promise = null;
        }
        function reject(reason) {
          if (!promise)
            return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        return ret2;
      }
      return tryConvertToPromise;
    };
  }
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
      var util = require_util();
      var isArray = util.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
          case -6:
            return new Map();
        }
      }
      function PromiseArray(values) {
        var promise = this._promise = new Promise2(INTERNAL);
        if (values instanceof Promise2) {
          promise._propagateFrom(values, 3);
          values.suppressUnhandledRejections();
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      util.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = function init2(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise2) {
          values = values._target();
          var bitField = values._bitField;
          ;
          this._values = values;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values._then(init2, this._reject, void 0, this, resolveValueIfEmpty);
          } else if ((bitField & 33554432) !== 0) {
            values = values._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values._reason());
          } else {
            return this._cancel();
          }
        }
        values = util.asArray(values);
        if (values === null) {
          var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values);
      };
      PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
          var maybePromise = tryConvertToPromise(values[i], result);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i);
              this._values[i] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
              isResolved = this._promiseCancelled(i);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
          }
        }
        if (!isResolved)
          result._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable())
          return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index2) {
        this._values[index2] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved())
          return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise2) {
          values.cancel();
        } else {
          for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise2) {
              values[i].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "node_modules/bluebird/js/release/context.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace = contextStack.pop();
          var ret2 = trace._promiseCreated;
          trace._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces)
          return new Context();
      }
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null)
            ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, Context, enableAsyncHooks, disableAsyncHooks) {
      var async = Promise2._async;
      var Warning = require_errors2().Warning;
      var util = require_util();
      var es52 = require_es5();
      var canAttachTrace2 = util.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
      var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      var deferUnhandledRejectionCheck;
      (function() {
        var promises = [];
        function unhandledRejectionCheck() {
          for (var i = 0; i < promises.length; ++i) {
            promises[i]._notifyUnhandledRejection();
          }
          unhandledRejectionClear();
        }
        function unhandledRejectionClear() {
          promises.length = 0;
        }
        deferUnhandledRejectionCheck = function(promise) {
          promises.push(promise);
          setTimeout(unhandledRejectionCheck, 1);
        };
        es52.defineProperty(Promise2, "_unhandledRejectionCheck", {
          value: unhandledRejectionCheck
        });
        es52.defineProperty(Promise2, "_unhandledRejectionClear", {
          value: unhandledRejectionClear
        });
      })();
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0)
          return;
        this._setRejectionIsUnhandled();
        deferUnhandledRejectionCheck(this);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn) {
        var context = Promise2._getContext();
        possiblyUnhandledRejection = util.contextBind(context, fn);
      };
      Promise2.onUnhandledRejectionHandled = function(fn) {
        var context = Promise2._getContext();
        unhandledRejectionHandled = util.contextBind(context, fn);
      };
      var disableLongStackTraces = function() {
      };
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
          config.longStackTraces = true;
          disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
            Context.deactivateLongStackTraces();
            config.longStackTraces = false;
          };
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
          Context.activateLongStackTraces();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config.longStackTraces && longStackTracesIsSupported();
      };
      var legacyHandlers = {
        unhandledrejection: {
          before: function() {
            var ret2 = util.global.onunhandledrejection;
            util.global.onunhandledrejection = null;
            return ret2;
          },
          after: function(fn) {
            util.global.onunhandledrejection = fn;
          }
        },
        rejectionhandled: {
          before: function() {
            var ret2 = util.global.onrejectionhandled;
            util.global.onrejectionhandled = null;
            return ret2;
          },
          after: function(fn) {
            util.global.onrejectionhandled = fn;
          }
        }
      };
      var fireDomEvent = function() {
        var dispatch = function(legacy, e) {
          if (legacy) {
            var fn;
            try {
              fn = legacy.before();
              return !util.global.dispatchEvent(e);
            } finally {
              legacy.after(fn);
            }
          } else {
            return !util.global.dispatchEvent(e);
          }
        };
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              name = name.toLowerCase();
              var eventData = {
                detail: event2,
                cancelable: true
              };
              var domEvent = new CustomEvent(name, eventData);
              es52.defineProperty(domEvent, "promise", {value: event2.promise});
              es52.defineProperty(domEvent, "reason", {value: event2.reason});
              return dispatch(legacyHandlers[name], domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              name = name.toLowerCase();
              var domEvent = new Event(name, {
                cancelable: true
              });
              domEvent.detail = event2;
              es52.defineProperty(domEvent, "promise", {value: event2.promise});
              es52.defineProperty(domEvent, "reason", {value: event2.reason});
              return dispatch(legacyHandlers[name], domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event2) {
              name = name.toLowerCase();
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(name, false, true, event2);
              return dispatch(legacyHandlers[name], domEvent);
            };
          }
        } catch (e) {
        }
        return function() {
          return false;
        };
      }();
      var fireGlobalEvent = function() {
        if (util.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method)
              return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      }();
      function generatePromiseLifecycleEventObject(name, promise) {
        return {promise};
      }
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return {promise, child};
        },
        warning: function(name, warning) {
          return {warning};
        },
        unhandledRejection: function(name, reason, promise) {
          return {reason, promise};
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
          async.throwLater(e);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
          async.throwLater(e);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      };
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config.warnings = !!warningsOption;
          wForgottenReturn = config.warnings;
          if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error("cannot enable cancellation after promises are in use");
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        if ("asyncHooks" in opts && util.nodeSupportsAsyncResource) {
          var prev = config.asyncHooks;
          var cur = !!opts.asyncHooks;
          if (prev !== cur) {
            config.asyncHooks = cur;
            if (cur) {
              enableAsyncHooks();
            } else {
              disableAsyncHooks();
            }
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve2, reject) {
        try {
          executor(resolve2, reject);
        } catch (e) {
          return e;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler2) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._dereferenceTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve2, reject) {
        var promise = this;
        try {
          executor(resolve2, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e) {
          return e;
        }
      }
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable())
          return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      function longStackTracesAttachExtraTrace(error3, ignoreSelf) {
        if (canAttachTrace2(error3)) {
          var trace = this._trace;
          if (trace !== void 0) {
            if (ignoreSelf)
              trace = trace._parent;
          }
          if (trace !== void 0) {
            trace.attachExtraTrace(error3);
          } else if (!error3.__stackCleaned__) {
            var parsed = parseStackAndMessage(error3);
            util.notEnumerableProp(error3, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error3, "__stackCleaned__", true);
          }
        }
      }
      function longStackTracesDereferenceTrace() {
        this._trace = void 0;
      }
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined())
            return;
          if ((promise._bitField & 65535) === 0)
            return;
          if (name)
            name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
              var line = stack[i];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i = 0; i < traceLines.length; ++i) {
                if (traceLines[i] === firstUserLine) {
                  if (i > 0) {
                    creatorLine = "\n" + traceLines[i - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement)
          message += " Use " + replacement + " instead.";
        return warn(message);
      }
      function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings)
          return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
          stacks[i].push("From previous event:");
          stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
          stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
          if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
            stacks.splice(i, 1);
            i--;
          }
        }
      }
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
          var prev = stacks[i];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
              commonRootMeetPoint = j;
              break;
            }
          }
          for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      function cleanStack(stack) {
        var ret2 = [];
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      function stackFramesAsArray(error3) {
        var stack = error3.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i > 0 && error3.name != "SyntaxError") {
          stack = stack.slice(i);
        }
        return stack;
      }
      function parseStackAndMessage(error3) {
        var stack = error3.stack;
        var message = error3.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error3) : ["    (No stack trace)"];
        return {
          message,
          stack: error3.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      function formatAndLogError(error3, title, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util.isObject(error3)) {
            var stack = error3.stack;
            message = title + formatStack(stack, error3);
          } else {
            message = title + String(error3);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e) {
          async.throwLater(e);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
          str = "[function " + (obj.name || "anonymous") + "]";
        } else {
          str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj);
              str = newStr;
            } catch (e) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      var shouldIgnore = function() {
        return false;
      };
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported())
          return;
        var firstStackLines = (firstLineError.stack || "").split("\n");
        var lastStackLines = (lastLineError.stack || "").split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
          var result = parseLineInfo(firstStackLines[i]);
          if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
          }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
          var result = parseLineInfo(lastStackLines[i]);
          if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = function(line) {
          if (bluebirdFramePattern.test(line))
            return true;
          var info = parseLineInfo(line);
          if (info) {
            if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        };
      }
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32)
          this.uncycle();
      }
      util.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2)
          return;
        var nodes = [];
        var stackToIndex = {};
        for (var i = 0, node = this; node !== void 0; ++i) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
          var stack = nodes[i].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i;
          }
        }
        for (var i = 0; i < length; ++i) {
          var currentStack = nodes[i].stack;
          var index2 = stackToIndex[currentStack];
          if (index2 !== void 0 && index2 !== i) {
            if (index2 > 0) {
              nodes[index2 - 1]._parent = void 0;
              nodes[index2 - 1]._length = 1;
            }
            nodes[i]._parent = void 0;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
            if (index2 < length - 1) {
              cycleEdgeNode._parent = nodes[index2 + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
              nodes[j]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error3) {
        if (error3.__stackCleaned__)
          return;
        this.uncycle();
        var parsed = parseStackAndMessage(error3);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace = this;
        while (trace !== void 0) {
          stacks.push(cleanStack(trace.stack.split("\n")));
          trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error3, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error3, "__stackCleaned__", true);
      };
      var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error3) {
          if (typeof stack === "string")
            return stack;
          if (error3.name !== void 0 && error3.message !== void 0) {
            return error3.toString();
          }
          return formatNonError(error3);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
          };
          return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return function captureStackTrace3(o) {
            o.stack = new Error().stack;
          };
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e) {
          hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return function captureStackTrace3(o) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e) {
              o.stack = e.stack;
            }
            Error.stackTraceLimit -= 6;
          };
        }
        formatStack = function(stack, error3) {
          if (typeof stack === "string")
            return stack;
          if ((typeof error3 === "object" || typeof error3 === "function") && error3.name !== void 0 && error3.message !== void 0) {
            return error3.toString();
          }
          return formatNonError(error3);
        };
        return null;
      }([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
          console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
          printWarning = function(message, isSoft) {
            var color = isSoft ? "[33m" : "[31m";
            console.warn(color + message + "[0m\n");
          };
        } else if (!util.isNode && typeof new Error().stack === "string") {
          printWarning = function(message, isSoft) {
            console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
          };
        }
      }
      var config = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false,
        asyncHooks: false
      };
      if (longStackTraces)
        Promise2.longStackTraces();
      return {
        asyncHooks: function() {
          return config.asyncHooks;
        },
        longStackTraces: function() {
          return config.longStackTraces;
        },
        warnings: function() {
          return config.warnings;
        },
        cancellation: function() {
          return config.cancellation;
        },
        monitoring: function() {
          return config.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn,
        deprecated,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(NEXT_FILTER) {
      var util = require_util();
      var getKeys = require_es5().keys;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function catchFilter(instances, cb, promise) {
        return function(e) {
          var boundTo = promise._boundValue();
          predicateLoop:
            for (var i = 0; i < instances.length; ++i) {
              var item = instances[i];
              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e instanceof item) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch2(item).call(boundTo, e);
                if (matchesPredicate === errorObj2) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                  var key = keys[j];
                  if (item[key] != e[key]) {
                    continue predicateLoop;
                  }
                }
                return tryCatch2(cb).call(boundTo, e);
              }
            }
          return NEXT_FILTER;
        };
      }
      return catchFilter;
    };
  }
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
      var util = require_util();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util.errorObj;
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      function PassThroughHandlerContext(promise, type, handler2) {
        this.promise = promise;
        this.type = type;
        this.handler = handler2;
        this.called = false;
        this.cancelPromise = null;
      }
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      function fail(reason) {
        if (checkCancel(this, reason))
          return;
        errorObj2.e = reason;
        return errorObj2;
      }
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler2 = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler2.call(promise._boundValue()) : handler2.call(promise._boundValue(), reasonOrValue);
          if (ret2 === NEXT_FILTER) {
            return ret2;
          } else if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                }
              }
              return maybePromise._then(succeed, fail, void 0, this, void 0);
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      Promise2.prototype._passThrough = function(handler2, type, success, fail2) {
        if (typeof handler2 !== "function")
          return this.then();
        return this._then(success, fail2, void 0, new PassThroughHandlerContext(this, type, handler2), void 0);
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler2) {
        return this._passThrough(handler2, 0, finallyHandler, finallyHandler);
      };
      Promise2.prototype.tap = function(handler2) {
        return this._passThrough(handler2, 1, finallyHandler);
      };
      Promise2.prototype.tapCatch = function(handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
          return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
        } else {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return Promise2.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
            }
          }
          catchInstances.length = j;
          var handler2 = arguments[i];
          return this._passThrough(catchFilter(catchInstances, handler2, this), 1, void 0, finallyHandler);
        }
      };
      return PassThroughHandlerContext;
    };
  }
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var maybeWrapAsError2 = util.maybeWrapAsError;
    var errors2 = require_errors2();
    var OperationalError = errors2.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj) {
      return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
    }
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj) {
      var ret2;
      if (isUntypedError(obj)) {
        ret2 = new OperationalError(obj);
        ret2.name = obj.name;
        ret2.message = obj.message;
        ret2.stack = obj.stack;
        var keys = es52.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj[key];
          }
        }
        return ret2;
      }
      util.markAsOriginatingFromRejection(obj);
      return obj;
    }
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null)
          return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    module2.exports = nodebackForPromise;
  }
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "node_modules/bluebird/js/release/method.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      Promise2.method = function(fn) {
        if (typeof fn !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret2);
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
        } else {
          value = tryCatch2(fn)();
        }
        var promiseCreated = ret2._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret2);
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
      var calledBind = false;
      var rejectThis = function(_, e) {
        this._reject(e);
      };
      var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
      };
      var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context.target);
        }
      };
      var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued)
          this._reject(e);
      };
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug.propagateFromFunction();
          Promise2.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL, targetRejected, void 0, ret2, context);
          maybePromise._then(bindingResolved, bindingRejected, void 0, ret2, context);
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj) {
        if (obj !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug.cancellation())
          return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing())
              promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable())
          return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0)
          this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
          for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e === errorObj2) {
                this._attachExtraTrace(e.e);
                async.throwLater(e.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      function thrower2() {
        throw this.reason;
      }
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(returner, void 0, void 0, {value}, void 0);
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(thrower2, void 0, void 0, {reason}, void 0);
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(void 0, thrower2, void 0, {reason}, void 0);
        } else {
          var _reason = arguments[1];
          var handler2 = function() {
            throw _reason;
          };
          return this.caught(reason, handler2);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(void 0, returner, void 0, {value}, void 0);
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2)
            _value.suppressUnhandledRejections();
          var handler2 = function() {
            return _value;
          };
          return this.caught(value, handler2);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "node_modules/bluebird/js/release/join.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async) {
      var util = require_util();
      var canEvaluate2 = util.canEvaluate;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var reject;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = function(i2) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
          };
          var promiseSetter = function(i2) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
          };
          var generateHolderClass = function(total) {
            var props = new Array(total);
            for (var i2 = 0; i2 < props.length; ++i2) {
              props[i2] = "this.p" + (i2 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          };
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i = 0; i < 8; ++i) {
            holderClasses.push(generateHolderClass(i + 1));
            thenCallbacks.push(thenCallback(i + 1));
            promiseSetters.push(promiseSetter(i + 1));
          }
          reject = function(reason) {
            this._reject(reason);
          };
        }
      }
      Promise2.join = function() {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
          fn = arguments[last];
          if (true) {
            if (last <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last - 1];
              var holder = new HolderClass(fn);
              var callbacks = thenCallbacks;
              for (var i2 = 0; i2 < last; ++i2) {
                var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(callbacks[i2], reject, void 0, ret2, holder);
                    promiseSetters[i2](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i2].call(ret2, maybePromise._value(), holder);
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i2].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var context = Promise2._getContext();
                  holder.fn = util.contextBind(context, holder.fn);
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn)
          args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn !== void 0 ? ret2.spread(fn) : ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    "use strict";
    var cr = Object.create;
    if (cr) {
      callerCache = cr(null);
      getterCache = cr(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util = require_util();
      var canEvaluate2 = util.canEvaluate;
      var isIdentifier2 = util.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys = Object.keys(cache);
              for (var i = 0; i < 256; ++i)
                delete cache[keys[i]];
              cache[" size"] = keys.length - 256;
            }
          }
          return ret2;
        };
        getMethodCaller = function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
          return getCompiled(name, makeGetter, getterCache);
        };
      }
      function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null)
          fn = obj[methodName];
        if (typeof fn !== "function") {
          var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn;
      }
      function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
      }
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(maybeCaller, void 0, void 0, args, void 0);
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj) {
        return obj[this];
      }
      function indexedGetter(obj) {
        var index2 = +this;
        if (index2 < 0)
          index2 = Math.max(0, index2 + obj.length);
        return obj[index2];
      }
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
      var errors2 = require_errors2();
      var TypeError2 = errors2.TypeError;
      var util = require_util();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i = 0; i < yieldHandlers2.length; ++i) {
          traceParent._pushContext();
          var result = tryCatch2(yieldHandlers2[i])(value);
          traceParent._popContext();
          if (result === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result, traceParent);
          if (maybePromise instanceof Promise2)
            return maybePromise;
        }
        return null;
      }
      function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
          var internal = new Promise2(INTERNAL);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      util.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved())
          return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError("generator .return() sentinel");
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result = tryCatch2(this._generator["return"]).call(this._generator, void 0);
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result.e, false);
          }
        }
        var value = result.value;
        if (result.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
            if (maybePromise === null) {
              this._promiseRejected(new TypeError2("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options2) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options2).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack);
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
      };
      Promise2.spawn = function(generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/map.js
var require_map = __commonJS({
  "node_modules/bluebird/js/release/map.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var context = Promise2._getContext();
        this._callback = util.contextBind(context, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
        if (util.isArray(promises)) {
          for (var i = 0; i < promises.length; ++i) {
            var maybePromise = promises[i];
            if (maybePromise instanceof Promise2) {
              maybePromise.suppressUnhandledRejections();
            }
          }
        }
      }
      util.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index2) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index2 < 0) {
          index2 = index2 * -1 - 1;
          values[index2] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved())
              return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values[index2] = value;
            this._queue.push(index2);
            return false;
          }
          if (preservedValues !== null)
            preservedValues[index2] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver, value, index2, length);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(ret2, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1)
                this._inFlight++;
              values[index2] = maybePromise;
              maybePromise._proxy(this, (index2 + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values[index2] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values, preservedValues);
          } else {
            this._resolve(values);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
          if (this._isResolved())
            return;
          var index2 = queue.pop();
          this._promiseFulfilled(values[index2], index2);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret2 = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
          if (booleans[i])
            ret2[j++] = values[i];
        }
        ret2.length = j;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map(promises, fn, options2, _filter) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var limit = 0;
        if (options2 !== void 0) {
          if (typeof options2 === "object" && options2 !== null) {
            if (typeof options2.concurrency !== "number") {
              return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options2.concurrency)));
            }
            limit = options2.concurrency;
          } else {
            return Promise2.reject(new TypeError("options argument must be an object but it is " + util.classString(options2)));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
      }
      Promise2.prototype.map = function(fn, options2) {
        return map(this, fn, options2, null);
      };
      Promise2.map = function(promises, fn, options2, _filter) {
        return map(promises, fn, options2, _filter);
      };
    };
  }
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var util = require_util();
      var async = Promise2._async;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val))
          return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options2) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options2 !== void 0 && Object(options2).spread) {
            adapter = spreadAdapter;
          }
          this._then(adapter, errorAdapter, void 0, this, nodeback);
        }
        return this;
      };
    };
  }
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var THIS = {};
      var util = require_util();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util.withAppended;
      var maybeWrapAsError2 = util.maybeWrapAsError;
      var canEvaluate2 = util.canEvaluate;
      var TypeError2 = require_errors2().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = {__isPromisified__: true};
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      };
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      function isPromisified(fn) {
        try {
          return fn.__isPromisified__ === true;
        } catch (e) {
          return false;
        }
      }
      function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
      }
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i = 0; i < ret2.length; i += 2) {
          var key = ret2[i];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret2.length; j += 2) {
              if (ret2[j] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret2 = [];
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var value = obj[key];
          var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
      };
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i = likelyArgumentCount - 1; i >= min; --i) {
            ret2.push(i);
          }
          for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret2.push(i);
          }
          return ret2;
        };
        var argumentSequence = function(argumentCount) {
          return util.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount2) {
          return util.filledRange(Math.max(parameterCount2, 3), "_arg", "");
        };
        var parameterCount = function(fn) {
          if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
          }
          return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver === THIS;
          function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
              ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise2, fn, receiver, withAppended2, maybeWrapAsError2, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
      }
      function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function() {
          return this;
        }();
        var method = callback;
        if (typeof method === "string") {
          callback = fn;
        }
        function promisified() {
          var _receiver = receiver;
          if (receiver === THIS)
            _receiver = this;
          var promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
          var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn2 = nodebackForPromise(promise, multiArgs);
          try {
            cb.apply(_receiver, withAppended2(arguments, fn2));
          } catch (e) {
            promise._rejectCallback(maybeWrapAsError2(e), true, true);
          }
          if (!promise._isFateSealed())
            promise._setAsyncGuaranteed();
          return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
        for (var i = 0, len = methods.length; i < len; i += 2) {
          var key = methods[i];
          var fn = methods[i + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn, function() {
              return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
          }
        }
        util.toFastProperties(obj);
        return obj;
      }
      function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs);
      }
      Promise2.promisify = function(fn, options2) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
          return fn;
        }
        options2 = Object(options2);
        var receiver = options2.context === void 0 ? THIS : options2.context;
        var multiArgs = !!options2.multiArgs;
        var ret2 = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options2) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options2 = Object(options2);
        var multiArgs = !!options2.multiArgs;
        var suffix = options2.suffix;
        if (typeof suffix !== "string")
          suffix = defaultSuffix;
        var filter = options2.filter;
        if (typeof filter !== "function")
          filter = defaultFilter;
        var promisifier = options2.promisifier;
        if (typeof promisifier !== "function")
          promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
          var value = target[keys[i]];
          if (keys[i] !== "constructor" && util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
      };
    };
  }
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "node_modules/bluebird/js/release/props.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util = require_util();
      var isObject2 = util.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function")
        Es6Map = Map;
      var mapToEntries = function() {
        var index2 = 0;
        var size = 0;
        function extractEntry(value, key) {
          this[index2] = value;
          this[index2 + size] = key;
          index2++;
        }
        return function mapToEntries2(map) {
          size = map.size;
          index2 = 0;
          var ret2 = new Array(map.size * 2);
          map.forEach(extractEntry, ret2);
          return ret2;
        };
      }();
      var entriesToMap = function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
          var key = entries[length + i];
          var value = entries[i];
          ret2.set(key, value);
        }
        return ret2;
      };
      function PropertiesPromiseArray(obj) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj instanceof Es6Map) {
          entries = mapToEntries(obj);
          isMap = true;
        } else {
          var keys = es52.keys(obj);
          var len = keys.length;
          entries = new Array(len * 2);
          for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, isMap ? -6 : -3);
      }
      util.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index2) {
        this._values[index2] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
              val[this._values[i + keyOffset]] = this._values[i];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject2(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(Promise2.props, void 0, void 0, void 0, void 0);
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "node_modules/bluebird/js/release/race.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
      var util = require_util();
      var raceLater = function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      };
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject = ret2._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
          var val = promises[i];
          if (val === void 0 && !(i in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
        }
        return ret2;
      }
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var context = Promise2._getContext();
        this._fn = util.contextBind(context, fn);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      util.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue)
          return this._cancel();
        if (this._isResolved())
          return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i = 0;
        } else {
          value = Promise2.resolve(values[0]);
          i = 1;
        }
        this._currentCancellable = value;
        for (var j = i; j < length; ++j) {
          var maybePromise = values[j];
          if (maybePromise instanceof Promise2) {
            maybePromise.suppressUnhandledRejections();
          }
        }
        if (!value.isRejected()) {
          for (; i < length; ++i) {
            var ctx = {
              accum: null,
              value: values[i],
              index: i,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
            if ((i & 127) === 0) {
              value._setNoAsyncGuarantee();
            }
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
      };
      Promise2.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
      }
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret2, promiseCreated, array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce", promise);
        return ret2;
      }
    };
  }
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, debug) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util = require_util();
      function SettledPromiseArray(values) {
        this.constructor$(values);
      }
      util.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index2, inspection) {
        this._values[index2] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index2) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index2, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index2) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index2, ret2);
      };
      Promise2.settle = function(promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.allSettled = function(promises) {
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "node_modules/bluebird/js/release/some.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util = require_util();
      var RangeError2 = require_errors2().RangeError;
      var AggregateError = require_errors2().AggregateError;
      var isArray = util.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      util.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e = new AggregateError();
          for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
              e.push(this._values[i]);
            }
          }
          if (e.length > 0) {
            this._reject(e);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      Promise2.some = function(promises, howMany) {
        return some(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, debug) {
      var util = require_util();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = function(value) {
        return delay(+this).thenReturn(value);
      };
      var delay = Promise2.delay = function(ms, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          if (debug.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms);
          if (debug.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms) {
        return delay(ms, this);
      };
      var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      };
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      Promise2.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, ms));
        if (debug.cancellation()) {
          parent = this.then();
          ret2 = parent._then(successClear, failureClear, void 0, handleWrapper, void 0);
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(successClear, failureClear, void 0, handleWrapper, void 0);
        }
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "node_modules/bluebird/js/release/using.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
      var util = require_util();
      var TypeError2 = require_errors2().TypeError;
      var inherits2 = require_util().inherits;
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var NULL = {};
      function thrower2(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL);
        function iterator() {
          if (i >= len)
            return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
            } catch (e) {
              return thrower2(e);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(iterator, thrower2, null, null, null);
            }
          }
          iterator();
        }
        iterator();
        return ret2;
      }
      function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
      }
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== void 0)
          context._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== void 0)
          context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
      };
      function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
      }
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
          var item = this[i];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2)
          return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
          var resource = input[i];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i
              }, void 0);
            }
          }
          resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
          reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i2 = 0; i2 < inspections.length; ++i2) {
            var inspection = inspections[i2];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i2] = inspection.value();
          }
          promise._pushContext();
          fn = tryCatch2(fn);
          var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(ret2, promiseCreated, "Promise.using", promise);
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
          return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "node_modules/bluebird/js/release/any.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "node_modules/bluebird/js/release/each.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
      }
      Promise2.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
      };
      Promise2.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn, options2) {
        return PromiseMap(this, fn, options2, INTERNAL);
      };
      Promise2.filter = function(promises, fn, options2) {
        return PromiseMap(promises, fn, options2, INTERNAL);
      };
    };
  }
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler2 = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util = require_util();
      util.setReflectHandler(reflectHandler2);
      var getDomain = function() {
        var domain = process.domain;
        if (domain === void 0) {
          return null;
        }
        return domain;
      };
      var getContextDefault = function() {
        return null;
      };
      var getContextDomain = function() {
        return {
          domain: getDomain(),
          async: null
        };
      };
      var AsyncResource = util.isNode && util.nodeSupportsAsyncResource ? require("async_hooks").AsyncResource : null;
      var getContextAsyncHooks = function() {
        return {
          domain: getDomain(),
          async: new AsyncResource("Bluebird::Promise")
        };
      };
      var getContext2 = util.isNode ? getContextDomain : getContextDefault;
      util.notEnumerableProp(Promise2, "_getContext", getContext2);
      var enableAsyncHooks = function() {
        getContext2 = getContextAsyncHooks;
        util.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
      };
      var disableAsyncHooks = function() {
        getContext2 = getContextDomain;
        util.notEnumerableProp(Promise2, "_getContext", getContextDomain);
      };
      var es52 = require_es5();
      var Async = require_async();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", {value: async});
      var errors2 = require_errors2();
      var TypeError2 = Promise2.TypeError = errors2.TypeError;
      Promise2.RangeError = errors2.RangeError;
      var CancellationError = Promise2.CancellationError = errors2.CancellationError;
      Promise2.TimeoutError = errors2.TimeoutError;
      Promise2.OperationalError = errors2.OperationalError;
      Promise2.RejectionError = errors2.OperationalError;
      Promise2.AggregateError = errors2.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
      var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug = require_debuggability()(Promise2, Context, enableAsyncHooks, disableAsyncHooks);
      var CapturedTrace = debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      function check(self2, executor) {
        if (self2 == null || self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(executor));
        }
      }
      function Promise2(executor) {
        if (executor !== INTERNAL) {
          check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          if (typeof fn !== "function") {
            throw new TypeError2("The last argument to .catch() must be a function, got " + util.toString(fn));
          }
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(reflectHandler2, reflectHandler2, void 0, this, void 0);
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
        if (result === errorObj2) {
          ret2._rejectCallback(result.e, true);
        }
        if (!ret2._isFateSealed())
          ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj) {
        var ret2 = tryConvertToPromise(obj);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var context = getContext2();
        if (!((bitField & 50397184) === 0)) {
          var handler2, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler2 = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler2 = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler2 = didReject;
          }
          async.invoke(settler, target, {
            handler: util.contextBind(context, handler2),
            promise,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver, context);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler())
          return;
        var bitField = this._bitField;
        this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
      };
      Promise2.prototype._setNoAsyncGuarantee = function() {
        this._bitField = (this._bitField | 536870912) & ~134217728;
      };
      Promise2.prototype._receiverAt = function(index2) {
        var ret2 = index2 === 0 ? this._receiver0 : this[index2 * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index2) {
        return this[index2 * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index2) {
        return this[index2 * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index2) {
        return this[index2 * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index2) {
        var fulfill = follower._fulfillmentHandlerAt(index2);
        var reject = follower._rejectionHandlerAt(index2);
        var promise = follower._promiseAt(index2);
        var receiver = follower._receiverAt(index2);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, context) {
        var index2 = this._length();
        if (index2 >= 65535 - 4) {
          index2 = 0;
          this._setLength(0);
        }
        if (index2 === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = util.contextBind(context, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = util.contextBind(context, reject);
          }
        } else {
          var base = index2 * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = util.contextBind(context, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = util.contextBind(context, reject);
          }
        }
        this._setLength(index2 + 1);
        return index2;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0)
          return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2))
          return this._fulfill(value);
        if (shouldBind)
          this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0)
            promise._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(maybePromise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        if (executor === INTERNAL)
          return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler2, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj2;
            x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
          } else {
            x = tryCatch2(handler2).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch2(handler2).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        if (x === NEXT_FILTER) {
          promise._reject(value);
        } else if (x === errorObj2) {
          promise._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
          promise._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing())
          ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler2, receiver, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise)
            promise._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch2(handler2).call(receiver, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler2 === reflectHandler2) {
            promise._fulfill(reflectHandler2.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler2 === "function") {
          if (!isPromise) {
            handler2.call(receiver, value, promise);
          } else {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler2, receiver, value, promise);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise);
            } else {
              receiver._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler2 = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler2 === "function") {
          if (!(promise instanceof Promise2)) {
            handler2.call(receiver, value, promise);
          } else {
            this._settlePromiseFromHandler(handler2, receiver, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler2, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler2, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index2) {
        var base = index2 * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
          this._dereferenceTrace();
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler2 = this._fulfillmentHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler2, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler2 = this._rejectionHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler2, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        es52.defineProperty(Promise2.prototype, Symbol.toStringTag, {
          get: function() {
            return "Object";
          }
        });
      }
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
      require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug);
      require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async);
      Promise2.Promise = Promise2;
      Promise2.version = "3.7.2";
      require_call_get()(Promise2);
      require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
      require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_settle()(Promise2, PromiseArray, debug);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_timers()(Promise2, INTERNAL, debug);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
      require_any()(Promise2);
      require_each()(Promise2, INTERNAL);
      require_filter()(Promise2, INTERNAL);
      util.toFastProperties(Promise2);
      util.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({a: 1});
      fillTypes({b: 2});
      fillTypes({c: 3});
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug.setBounds(Async.firstLineError, util.lastLineError);
      return Promise2;
    };
  }
});

// node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/bluebird/js/release/bluebird.js"(exports2, module2) {
    "use strict";
    var old;
    if (typeof Promise !== "undefined")
      old = Promise;
    function noConflict() {
      try {
        if (Promise === bluebird)
          Promise = old;
      } catch (e) {
      }
      return bluebird;
    }
    var bluebird = require_promise()();
    bluebird.noConflict = noConflict;
    module2.exports = bluebird;
  }
});

// .svelte-kit/netlify/entry.js
__markAsModule(exports);
__export(exports, {
  handler: () => handler
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
var import_http = __toModule(require("http"));
var import_https = __toModule(require("https"));
var import_zlib = __toModule(require("zlib"));
var import_stream = __toModule(require("stream"));
var import_util = __toModule(require("util"));
var import_crypto = __toModule(require("crypto"));
var import_url = __toModule(require("url"));
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var src = dataUriToBuffer;
var {Readable} = import_stream.default;
var wm = new WeakMap();
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
var Blob = class {
  constructor(blobParts = [], options2 = {}) {
    let size = 0;
    const parts = blobParts.map((element) => {
      let buffer;
      if (element instanceof Buffer) {
        buffer = element;
      } else if (ArrayBuffer.isView(element)) {
        buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
      } else if (element instanceof ArrayBuffer) {
        buffer = Buffer.from(element);
      } else if (element instanceof Blob) {
        buffer = element;
      } else {
        buffer = Buffer.from(typeof element === "string" ? element : String(element));
      }
      size += buffer.length || buffer.size || 0;
      return buffer;
    });
    const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
    wm.set(this, {
      type: /[^\u0020-\u007E]/.test(type) ? "" : type,
      size,
      parts
    });
  }
  get size() {
    return wm.get(this).size;
  }
  get type() {
    return wm.get(this).type;
  }
  async text() {
    return Buffer.from(await this.arrayBuffer()).toString();
  }
  async arrayBuffer() {
    const data = new Uint8Array(this.size);
    let offset = 0;
    for await (const chunk of this.stream()) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    return data.buffer;
  }
  stream() {
    return Readable.from(read(wm.get(this).parts));
  }
  slice(start = 0, end = this.size, type = "") {
    const {size} = this;
    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(relativeEnd - relativeStart, 0);
    const parts = wm.get(this).parts.values();
    const blobParts = [];
    let added = 0;
    for (const part of parts) {
      const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size2 <= relativeStart) {
        relativeStart -= size2;
        relativeEnd -= size2;
      } else {
        const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
        blobParts.push(chunk);
        added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
        relativeStart = 0;
        if (added >= span) {
          break;
        }
      }
    }
    const blob = new Blob([], {type: String(type).toLowerCase()});
    Object.assign(wm.get(blob), {size: span, parts: blobParts});
    return blob;
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
  static [Symbol.hasInstance](object) {
    return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
};
Object.defineProperties(Blob.prototype, {
  size: {enumerable: true},
  type: {enumerable: true},
  slice: {enumerable: true}
});
var fetchBlob = Blob;
var FetchBaseError = class extends Error {
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};
var FetchError = class extends FetchBaseError {
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob = (object) => {
  return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
var isAbortSignal = (object) => {
  return typeof object === "object" && object[NAME] === "AbortSignal";
};
var carriage = "\r\n";
var dashes = "-".repeat(2);
var carriageLength = Buffer.byteLength(carriage);
var getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
var getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
var INTERNALS$2 = Symbol("Body internals");
var Body = class {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (import_util.types.isAnyArrayBuffer(body)) {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else if (isFormData(body)) {
      boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
      body = import_stream.default.Readable.from(formDataIterator(body, boundary));
    } else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS$2] = {
      body,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof import_stream.default) {
      body.on("error", (err) => {
        const error3 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
        this[INTERNALS$2].error = error3;
      });
    }
  }
  get body() {
    return this[INTERNALS$2].body;
  }
  get bodyUsed() {
    return this[INTERNALS$2].disturbed;
  }
  async arrayBuffer() {
    const {buffer, byteOffset, byteLength} = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
    const buf = await this.buffer();
    return new fetchBlob([buf], {
      type: ct
    });
  }
  async json() {
    const buffer = await consumeBody(this);
    return JSON.parse(buffer.toString());
  }
  async text() {
    const buffer = await consumeBody(this);
    return buffer.toString();
  }
  buffer() {
    return consumeBody(this);
  }
};
Object.defineProperties(Body.prototype, {
  body: {enumerable: true},
  bodyUsed: {enumerable: true},
  arrayBuffer: {enumerable: true},
  blob: {enumerable: true},
  json: {enumerable: true},
  text: {enumerable: true}
});
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let {body} = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    if (error3 instanceof FetchBaseError) {
      throw error3;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone = (instance, highWaterMark) => {
  let p1;
  let p2;
  let {body} = instance;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new import_stream.PassThrough({highWaterMark});
    p2 = new import_stream.PassThrough({highWaterMark});
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS$2].body = p1;
    body = p2;
  }
  return body;
};
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  }
  if (isFormData(body)) {
    return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
  }
  if (body instanceof import_stream.default) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const {body} = request;
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  if (isFormData(body)) {
    return getFormDataLength(request[INTERNALS$2].boundary);
  }
  return null;
};
var writeToStream = (dest, {body}) => {
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
};
var validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(err, "code", {value: "ERR_INVALID_HTTP_TOKEN"});
    throw err;
  }
};
var validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    const err = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(err, "code", {value: "ERR_INVALID_CHAR"});
    throw err;
  }
};
var Headers2 = class extends URLSearchParams {
  constructor(init2) {
    let result = [];
    if (init2 instanceof Headers2) {
      const raw = init2.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name, value]));
      }
    } else if (init2 == null)
      ;
    else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
      const method = init2[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init2));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init2].map((pair) => {
          if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : void 0;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value = value.toLowerCase();
    }
    return value;
  }
  forEach(callback) {
    for (const name of this.keys()) {
      callback(this.get(name), name);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
};
Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
  result[property] = {enumerable: true};
  return result;
}, {}));
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
var redirectStatus = new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};
var INTERNALS$1 = Symbol("Response internals");
var Response2 = class extends Body {
  constructor(body = null, options2 = {}) {
    super(body, options2);
    const status = options2.status || 200;
    const headers = new Headers2(options2.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS$1] = {
      url: options2.url,
      status,
      statusText: options2.statusText || "",
      headers,
      counter: options2.counter,
      highWaterMark: options2.highWaterMark
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  get highWaterMark() {
    return this[INTERNALS$1].highWaterMark;
  }
  clone() {
    return new Response2(clone(this, this.highWaterMark), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  url: {enumerable: true},
  status: {enumerable: true},
  ok: {enumerable: true},
  redirected: {enumerable: true},
  statusText: {enumerable: true},
  headers: {enumerable: true},
  clone: {enumerable: true}
});
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
};
var INTERNALS = Symbol("Request internals");
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS] === "object";
};
var Request = class extends Body {
  constructor(input, init2 = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    let method = init2.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
    super(inputBody, {
      size: init2.size || input.size || 0
    });
    const headers = new Headers2(init2.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init2) {
      signal = init2.signal;
    }
    if (signal !== null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS] = {
      method,
      redirect: init2.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
    this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
    this.counter = init2.counter || input.counter || 0;
    this.agent = init2.agent || input.agent;
    this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
  }
  get method() {
    return this[INTERNALS].method;
  }
  get url() {
    return (0, import_url.format)(this[INTERNALS].parsedURL);
  }
  get headers() {
    return this[INTERNALS].headers;
  }
  get redirect() {
    return this[INTERNALS].redirect;
  }
  get signal() {
    return this[INTERNALS].signal;
  }
  clone() {
    return new Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: {enumerable: true},
  url: {enumerable: true},
  headers: {enumerable: true},
  redirect: {enumerable: true},
  clone: {enumerable: true},
  signal: {enumerable: true}
});
var getNodeRequestOptions = (request) => {
  const {parsedURL} = request[INTERNALS];
  const headers = new Headers2(request[INTERNALS].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let {agent} = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const requestOptions = {
    path: parsedURL.pathname + search,
    pathname: parsedURL.pathname,
    hostname: parsedURL.hostname,
    protocol: parsedURL.protocol,
    port: parsedURL.port,
    hash: parsedURL.hash,
    search: parsedURL.search,
    query: parsedURL.query,
    href: parsedURL.href,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return requestOptions;
};
var AbortError = class extends FetchBaseError {
  constructor(message, type = "aborted") {
    super(message, type);
  }
};
var supportedSchemas = new Set(["data:", "http:", "https:"]);
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = src(request.url);
      const response2 = new Response2(data, {headers: {"Content-Type": data.typeFull}});
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const {signal} = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        const locationURL = location2 === null ? null : new URL(location2, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error3) {
                reject(error3);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch2(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
        reject(error3);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
          reject(error3);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error3) => {
              reject(error3);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error3) => {
              reject(error3);
            });
          }
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
globalThis.fetch = fetch2;
globalThis.Response = Response2;
globalThis.Request = Request;
globalThis.Headers = Headers2;

// node_modules/@sveltejs/kit/dist/ssr.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive2(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive2(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive2(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive2(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return {set, update, subscribe};
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status,
  error: error3,
  branch,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error3) {
    error3.stack = options2.get_stack(error3);
  }
  if (branch) {
    branch.forEach(({node, loaded, fetched, uses_credentials}) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({node}) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = {head: "", html: "", css: {code: "", map: null}};
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"></script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error4) => {
      throw new Error(`Failed to serialize session data: ${error4.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error3)},
					nodes: [
						${branch.map(({node}) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page.path)},
						query: new URLSearchParams(${s$1(page.query.toString())}),
						params: ${s$1(page.params)}
					}
				}` : "null"}
			});
		</script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({url, body: body2, json}) => {
    return body2 ? `<script type="svelte-data" url="${url}" body="${hash(body2)}">${json}</script>` : `<script type="svelte-data" url="${url}">${json}</script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({head, body})
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error3) {
  if (!error3)
    return null;
  let serialized = try_serialize(error3);
  if (!serialized) {
    const {name, message, stack} = error3;
    serialized = try_serialize({name, message, stack});
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  if (loaded.error) {
    const error3 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    const status = loaded.status;
    if (!(error3 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error3}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return {status: 500, error: error3};
    }
    return {status, error: error3};
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
function resolve(base, path) {
  const baseparts = path[0] === "/" ? [] : base.slice(1).split("/");
  const pathparts = path[0] === "/" ? path.slice(1).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  return `/${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  context,
  is_leaf,
  is_error,
  status,
  error: error3
}) {
  const {module: module2} = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        if (options2.read && url.startsWith(options2.paths.assets)) {
          url = url.replace(options2.paths.assets, "");
        }
        if (url.startsWith("//")) {
          throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
        }
        let response;
        if (/^[a-zA-Z]+:/.test(url)) {
          response = await fetch(url, opts);
        } else {
          const [path, search] = url.split("?");
          const resolved = resolve(request.path, path);
          const filename = resolved.slice(1);
          const filename_html = `${filename}/index.html`;
          const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
          if (asset) {
            if (options2.read) {
              response = new Response(options2.read(asset.file), {
                headers: {
                  "content-type": asset.type
                }
              });
            } else {
              response = await fetch(`http://${page.host}/${asset.file}`, opts);
            }
          }
          if (!response) {
            const headers = {...opts.headers};
            if (opts.credentials !== "omit") {
              uses_credentials = true;
              headers.cookie = request.headers.cookie;
              if (!headers.authorization) {
                headers.authorization = request.headers.authorization;
              }
            }
            if (opts.body && typeof opts.body !== "string") {
              throw new Error("Request body must be a string");
            }
            const rendered = await respond({
              host: request.host,
              method: opts.method || "GET",
              headers,
              path: resolved,
              rawBody: opts.body,
              query: new URLSearchParams(search)
            }, options2, {
              fetched: url,
              initiator: route
            });
            if (rendered) {
              if (state.prerender) {
                state.prerender.dependencies.set(resolved, rendered);
              }
              response = new Response(rendered.body, {
                status: rendered.status,
                headers: rendered.headers
              });
            }
          }
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: {...context}
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error3;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
async function respond_with_error({request, options: options2, state, $session, status, error: error3}) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      context: loaded.context,
      is_leaf: false,
      is_error: true,
      status,
      error: error3
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error3,
      branch,
      page
    });
  } catch (error4) {
    options2.handle_error(error4);
    return {
      status: 500,
      headers: {},
      body: error4.stack
    };
  }
}
async function respond$1({request, options: options2, state, $session, route}) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id && options2.load_component(id)));
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? leaf.ssr : options2.ssr,
    router: "router" in leaf ? leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: null
    };
  }
  let branch;
  let status = 200;
  let error3;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state,
              route,
              page,
              node,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({status, error: error3} = loaded.loaded);
            }
          } catch (e) {
            options2.handle_error(e);
            status = 500;
            error3 = e;
          }
          if (error3) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let error_loaded;
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state,
                    route,
                    page,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error3
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (e) {
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error3
            });
          }
        }
        branch.push(loaded);
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status,
      error: error3,
      branch: branch && branch.filter(Boolean),
      page
    });
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
}
async function render_page(request, route, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  if (route) {
    const response = await respond$1({
      request,
      options: options2,
      state,
      $session,
      route
    });
    if (response) {
      return response;
    }
    if (state.fetched) {
      return {
        status: 500,
        headers: {},
        body: `Bad request in load function: failed to fetch ${state.fetched}`
      };
    }
  } else {
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 404,
      error: new Error(`Not found: ${request.path}`)
    });
  }
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
async function render_route(request, route) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (handler2) {
    const match = route.pattern.exec(request.path);
    const params = route.params(match);
    const response = await handler2({...request, params});
    if (response) {
      if (typeof response !== "object") {
        return error(`Invalid response from route ${request.path}: expected an object, got ${typeof response}`);
      }
      let {status = 200, body, headers = {}} = response;
      headers = lowercase_keys(headers);
      const type = headers["content-type"];
      if (type === "application/octet-stream" && !(body instanceof Uint8Array)) {
        return error(`Invalid response from route ${request.path}: body must be an instance of Uint8Array if content type is application/octet-stream`);
      }
      if (body instanceof Uint8Array && type !== "application/octet-stream") {
        return error(`Invalid response from route ${request.path}: Uint8Array body must be accompanied by content-type: application/octet-stream header`);
      }
      let normalized_body;
      if (typeof body === "object" && (!type || type === "application/json")) {
        headers = {...headers, "content-type": "application/json"};
        normalized_body = JSON.stringify(body);
      } else {
        normalized_body = body;
      }
      return {status, body: normalized_body, headers};
    }
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        map.get(key).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield key;
      }
    }
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value;
      }
    }
  }
};
function parse_body(req) {
  const raw = req.rawBody;
  if (!raw)
    return raw;
  const [type, ...directives] = req.headers["content-type"].split(/;\s*/);
  if (typeof raw === "string") {
    switch (type) {
      case "text/plain":
        return raw;
      case "application/json":
        return JSON.parse(raw);
      case "application/x-www-form-urlencoded":
        return get_urlencoded(raw);
      case "multipart/form-data": {
        const boundary = directives.find((directive) => directive.startsWith("boundary="));
        if (!boundary)
          throw new Error("Missing boundary");
        return get_multipart(raw, boundary.slice("boundary=".length));
      }
      default:
        throw new Error(`Invalid Content-Type ${type}`);
    }
  }
  return raw;
}
function get_urlencoded(text) {
  const {data, append} = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  const nope = () => {
    throw new Error("Malformed form data");
  };
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    nope();
  }
  const {data, append} = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          nope();
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      nope();
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !incoming.path.split("/").pop().includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    return await options2.hooks.handle({
      request: {
        ...incoming,
        headers: lowercase_keys(incoming.headers),
        body: parse_body(incoming),
        params: null,
        locals: {}
      },
      resolve: async (request) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: {ssr: false, router: true, hydrate: true},
            status: 200,
            error: null,
            branch: [],
            page: null
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_route(request, route) : await render_page(request, route, options2, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body)}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: null
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        return await render_page(request, null, options2, state);
      }
    });
  } catch (e) {
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// node_modules/svelte/internal/index.mjs
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var tasks = new Set();
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
var resolved_promise = Promise.resolve();
var seen_callbacks = new Set();
var outroing = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({$$});
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, {$$slots = {}, context = new Map()} = {}) => {
      on_destroy = [];
      const result = {title: "", head: "", css: new Set()};
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
    }
    connectedCallback() {
      const {on_mount} = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// node_modules/playwright/index.mjs
var import_index = __toModule(require_playwright3());
var chromium = import_index.default.chromium;
var firefox = import_index.default.firefox;
var webkit = import_index.default.webkit;
var selectors = import_index.default.selectors;
var devices = import_index.default.devices;
var errors = import_index.default.errors;

// .svelte-kit/output/server/app.js
var import_bluebird = __toModule(require_bluebird());
var css$1 = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n</script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {stores} = $$props;
  let {page} = $$props;
  let {components} = $$props;
  let {props_0 = null} = $$props;
  let {props_1 = null} = $$props;
  let {props_2 = null} = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$1);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1j55zn5"}">${navigated ? `${escape2(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({head, body}) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var options = null;
function init(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-15d05ab0.js",
      css: ["/./_app/assets/start-a8cd1609.css"],
      js: ["/./_app/start-15d05ab0.js", "/./_app/chunks/vendor-598bc7c1.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error22) => String(error22),
    handle_error: (error22) => {
      console.error(error22.stack);
      error22.stack = options.get_stack(error22);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var empty = () => ({});
var manifest = {
  assets: [{"file": "favicon.png", "size": 1571, "type": "image/png"}],
  layout: ".svelte-kit/build/components/layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: [".svelte-kit/build/components/layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/word\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return index$1;
      })
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({request, resolve: resolve2}) => resolve2(request))
});
var module_lookup = {
  ".svelte-kit/build/components/layout.svelte": () => Promise.resolve().then(function() {
    return layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error2;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index;
  })
};
var metadata_lookup = {".svelte-kit/build/components/layout.svelte": {"entry": "/./_app/layout.svelte-afc5b06d.js", "css": [], "js": ["/./_app/layout.svelte-afc5b06d.js", "/./_app/chunks/vendor-598bc7c1.js"], "styles": null}, ".svelte-kit/build/components/error.svelte": {"entry": "/./_app/error.svelte-762a89f6.js", "css": [], "js": ["/./_app/error.svelte-762a89f6.js", "/./_app/chunks/vendor-598bc7c1.js"], "styles": null}, "src/routes/index.svelte": {"entry": "/./_app/pages/index.svelte-714dbfc6.js", "css": ["/./_app/assets/pages/index.svelte-1dac8d9e.css"], "js": ["/./_app/pages/index.svelte-714dbfc6.js", "/./_app/chunks/vendor-598bc7c1.js"], "styles": null}};
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
init({paths: {"base": "", "assets": "/."}});
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({...request, host}, options, {prerender});
}
var searchLarousse = async (word) => {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto(`https://www.larousse.fr/dictionnaires/francais/${word}`);
  const wordExists = await page.isVisible(".Definitions");
  if (!wordExists) {
    await browser.close();
    return Promise.reject("Not found");
  }
  const [catgram, definition] = await Promise.all([
    await page.textContent(".CatgramDefinition"),
    await page.textContent(".Definitions .DivisionDefinition:first-child")
  ]);
  await browser.close();
  return {catgram, definition, source: "Larousse"};
};
var searchLittr\u00E9 = async (word) => {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto(`https://www.littre.org/definition/${word}`);
  const wordExists = await page.isVisible(".definition");
  if (!wordExists) {
    await browser.close();
    return Promise.reject("Not found");
  }
  const [catgram, definition] = await Promise.all([
    await page.getAttribute(".entete b abbr", "title"),
    await page.textContent(".corps li:first-child") || ""
  ]);
  await browser.close();
  return {catgram, definition, source: "Littr\xE9"};
};
var searchRobert = async (word) => {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto(`https://dictionnaire.lerobert.com/definition/${word}`);
  const wordExists = await page.isVisible("#definitions");
  if (!wordExists) {
    await browser.close();
    return Promise.reject("Not found");
  }
  const [catgram, definition] = await Promise.all([
    await page.textContent(".d_cat"),
    await page.textContent(".d_dfn:first-child")
  ]);
  await browser.close();
  return {catgram, definition, source: "Robert"};
};
var {Promise: Promise$1} = import_bluebird.default;
async function get({
  query
}) {
  const word = query.get("word") || "";
  const response = await searchWord(word);
  return {
    body: {
      response: response || "Ce mot n'existe pas, looser !"
    }
  };
}
var searchWord = async (word) => {
  return await Promise$1.any([searchLarousse(word), searchRobert(word), searchLittr\u00E9(word)]).catch(Promise$1.AggregateError, () => {
    return null;
  });
};
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get
});
var Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${slots.default ? slots.default({}) : ``}`;
});
var layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Layout
});
function load({error: error22, status}) {
  return {props: {error: error22, status}};
}
var Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {status} = $$props;
  let {error: error22} = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error22 !== void 0)
    $$bindings.error(error22);
  return `<h1>${escape2(status)}</h1>

<p>${escape2(error22.message)}</p>


${error22.stack ? `<pre>${escape2(error22.stack)}</pre>` : ``}`;
});
var error2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error2,
  load
});
var css = {
  code: "body{margin:0;padding:0;font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\n			'Open Sans', 'Helvetica Neue', sans-serif;display:flex;justify-content:center;height:100vh;font-size:19px;box-sizing:border-box}form.svelte-x9372i{display:flex}input.svelte-x9372i{border-radius:4px;border:3px solid #000;width:100%;padding:5px}.text-capitalize.svelte-x9372i::first-letter{text-transform:capitalize}.container.svelte-x9372i{width:30vw;padding:2rem}@media(max-width: 1250px){.container.svelte-x9372i{width:85vw}}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script lang=\\"typescript\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nimport { onMount } from 'svelte';\\nlet value;\\nlet searchResult;\\nlet loading = false;\\nlet input;\\nonMount(function () {\\n    input.focus();\\n});\\nfunction handleSubmit() {\\n    return __awaiter(this, void 0, void 0, function* () {\\n        if (value.trim()) {\\n            loading = true;\\n            const url = \`/word?word=\${value}\`;\\n            const res = yield fetch(url);\\n            const { response } = yield res.json();\\n            searchResult = response;\\n            loading = false;\\n        }\\n    });\\n}\\n</script>\\n\\n<div class=\\"container\\">\\n\\t<h1>Ritournelle dico</h1>\\n\\n\\t<form on:submit|preventDefault={handleSubmit}>\\n\\t\\t<input bind:value bind:this={input} disabled={loading} />\\n\\t</form>\\n\\n\\t{#if loading}\\n\\t\\t<p>Je cherche...</p>\\n\\t{/if}\\n\\n\\t{#if !loading && searchResult}\\n\\t\\t{#if searchResult.definition}\\n\\t\\t\\t<div>\\n\\t\\t\\t\\t<p class=\\"text-capitalize\\">{searchResult.catgram}</p>\\n\\t\\t\\t\\t<p><b>D\xE9finition:</b> {searchResult.definition}</p>\\n\\t\\t\\t\\t<p><b>Source:</b> {searchResult.source}</p>\\n\\t\\t\\t</div>\\n\\t\\t{:else}\\n\\t\\t\\t<p>Ce mot n'existe pas... coup dur</p>\\n\\t\\t{/if}\\n\\t{/if}\\n</div>\\n\\n<style>\\n\\t:global(body) {\\n\\t\\tmargin: 0;\\n\\t\\tpadding: 0;\\n\\t\\tfont-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\\n\\t\\t\\t'Open Sans', 'Helvetica Neue', sans-serif;\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: center;\\n\\t\\theight: 100vh;\\n\\t\\tfont-size: 19px;\\n\\t\\tbox-sizing: border-box;\\n\\t}\\n\\n\\tform {\\n\\t\\tdisplay: flex;\\n\\t}\\n\\n\\tinput {\\n\\t\\tborder-radius: 4px;\\n\\t\\tborder: 3px solid #000;\\n\\t\\twidth: 100%;\\n\\t\\tpadding: 5px;\\n\\t}\\n\\n\\t.text-capitalize::first-letter {\\n\\t\\ttext-transform: capitalize;\\n\\t}\\n\\n\\t.container {\\n\\t\\twidth: 30vw;\\n\\t\\tpadding: 2rem;\\n\\t}\\n\\n\\t@media (max-width: 1250px) {\\n\\t\\t.container {\\n\\t\\t\\twidth: 85vw;\\n\\t\\t}\\n\\t}\\n</style>\\n"],"names":[],"mappings":"AAwDS,IAAI,AAAE,CAAC,AACd,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;GAC7F,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,CAC1C,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,KAAK,CACb,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,UAAU,AACvB,CAAC,AAED,IAAI,cAAC,CAAC,AACL,OAAO,CAAE,IAAI,AACd,CAAC,AAED,KAAK,cAAC,CAAC,AACN,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,GAAG,AACb,CAAC,AAED,8BAAgB,cAAc,AAAC,CAAC,AAC/B,cAAc,CAAE,UAAU,AAC3B,CAAC,AAED,UAAU,cAAC,CAAC,AACX,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,AACd,CAAC,AAED,MAAM,AAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AAC3B,UAAU,cAAC,CAAC,AACX,KAAK,CAAE,IAAI,AACZ,CAAC,AACF,CAAC"}`
};
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  (function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve2) {
        resolve2(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let value;
  let input;
  onMount(function() {
    input.focus();
  });
  $$result.css.add(css);
  return `<div class="${"container svelte-x9372i"}"><h1>Ritournelle dico</h1>

	<form class="${"svelte-x9372i"}"><input ${""} class="${"svelte-x9372i"}"${add_attribute("value", value, 1)}${add_attribute("this", input, 1)}></form>

	${``}

	${``}
</div>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});

// .svelte-kit/netlify/entry.js
async function handler(event) {
  const {path, httpMethod, headers, rawQuery, body, isBase64Encoded} = event;
  const query = new URLSearchParams(rawQuery);
  const rawBody = headers["content-type"] === "application/octet-stream" ? new TextEncoder("base64").encode(body) : isBase64Encoded ? Buffer.from(body, "base64").toString() : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (rendered) {
    return {
      isBase64Encoded: false,
      statusCode: rendered.status,
      headers: rendered.headers,
      body: rendered.body
    };
  }
  return {
    statusCode: 404,
    body: "Not found"
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
